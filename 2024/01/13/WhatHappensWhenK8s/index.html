<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>当我执行 kubectl create 时发生了什么[译] - PowerfooI 的个人博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Somewhere - PowerfooI&#039;s Zone"><meta name="msapplication-TileImage" content="/img/apple-touch-icon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Somewhere - PowerfooI&#039;s Zone"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="144x144" href="/img/apple-touch-icon.png"><meta name="description" content="翻译自 What happens when … Kubernetes edition!。我认为这篇文章写得生动有趣，且在关键位置都给出了有价值的链接，引导进一步的阅读学习，让我有了重读并翻译的冲动。  如果我希望往 Kubernetes 集群当中部署 nginx，我大概率会在命令行输入下面这样的命令并敲下回车键： 1kubectl create deployment nginx --image&amp;#x3D;"><meta property="og:type" content="blog"><meta property="og:title" content="当我执行 kubectl create 时发生了什么[译]"><meta property="og:url" content="https://powerfooi.github.io/2024/01/13/WhatHappensWhenK8s/"><meta property="og:site_name" content="PowerfooI 的个人博客"><meta property="og:description" content="翻译自 What happens when … Kubernetes edition!。我认为这篇文章写得生动有趣，且在关键位置都给出了有价值的链接，引导进一步的阅读学习，让我有了重读并翻译的冲动。  如果我希望往 Kubernetes 集群当中部署 nginx，我大概率会在命令行输入下面这样的命令并敲下回车键： 1kubectl create deployment nginx --image&amp;#x3D;"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://powerfooi.github.io/gallery/covers/Kubernetes-Logo.jpg"><meta property="article:published_time" content="2024-01-13T14:15:49.000Z"><meta property="article:modified_time" content="2024-08-04T02:32:30.245Z"><meta property="article:author" content="PowerfooI"><meta property="article:tag" content="Reading"><meta property="article:tag" content="CloudNative"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://powerfooi.github.io/gallery/covers/Kubernetes-Logo.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://powerfooi.github.io/2024/01/13/WhatHappensWhenK8s/"},"headline":"当我执行 kubectl create 时发生了什么[译]","image":["https://powerfooi.github.io/gallery/covers/Kubernetes-Logo.jpg"],"datePublished":"2024-01-13T14:15:49.000Z","dateModified":"2024-08-04T02:32:30.245Z","author":{"@type":"Person","name":"PowerfooI"},"publisher":{"@type":"Organization","name":"PowerfooI 的个人博客","logo":{"@type":"ImageObject","url":{"text":"Somewhere - PowerfooI's Zone"}}},"description":"翻译自 What happens when … Kubernetes edition!。我认为这篇文章写得生动有趣，且在关键位置都给出了有价值的链接，引导进一步的阅读学习，让我有了重读并翻译的冲动。  如果我希望往 Kubernetes 集群当中部署 nginx，我大概率会在命令行输入下面这样的命令并敲下回车键： 1kubectl create deployment nginx --image&#x3D;"}</script><link rel="canonical" href="https://powerfooi.github.io/2024/01/13/WhatHappensWhenK8s/"><link rel="alternate" href="/atom.xml" title="PowerfooI 的个人博客" type="application/atom+xml"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?371b1d983749aad213c30979122b6579";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-TNMDKQMTYG" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-TNMDKQMTYG');</script><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Somewhere - PowerfooI&#039;s Zone</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/PowerfooI"><i class="fab fa-github"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/gallery/covers/Kubernetes-Logo.jpg" alt="当我执行 kubectl create 时发生了什么[译]"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-13T14:15:49.000Z" title="1/13/2024, 10:15:49 PM">2024-01-13</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span><span class="level-item">1 小时读完 (大约12081个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">当我执行 kubectl create 时发生了什么[译]</h1><div class="content"><blockquote>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><p>翻译自 <a href="https://github.com/jamiehannaford/what-happens-when-k8s">What happens when … Kubernetes edition!</a>。我认为这篇文章写得生动有趣，且在关键位置都给出了有价值的链接，引导进一步的阅读学习，让我有了重读并翻译的冲动。</p>
</blockquote>
<p>如果我希望往 Kubernetes 集群当中部署 nginx，我大概率会在命令行输入下面这样的命令并敲下回车键：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment nginx --image=nginx --replicas=3</span><br></pre></td></tr></table></figure>

<p>几秒之后，我应该能看到三个 nginx 的 pod 散布在集群的工作节点上。这很神奇！但这个过程背后究竟发生了什么？</p>
<p>关于 Kubernetes 的惊人的特点是，它通过用户友好的 API 处理工作负载的部署。其中的复杂性被简单的抽象隐藏起来。但为了充分理解它所提供的价值，了解其内部工作原理也是很有用的。本指南将引导您了解从客户端 kubectl 到 kubelet 的请求的完整生命周期，并在必要时链接到源代码（或者相关文档和博客）来进一步说明正在发生的事情。</p>
<p>这是一份不断修订的文档。如果您发现可以改进或重写的地方，欢迎贡献！</p>
<span id="more"></span>

<h1 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a>kubectl</h1><h2 id="校验和生成器"><a href="#校验和生成器" class="headerlink" title="校验和生成器"></a>校验和生成器</h2><p>好的，我们开始吧。我们刚刚在终端里敲击了回车键，现在会发生什么？</p>
<p>首先 kubectl 会进行客户端校验，该过程保证了应当出错的请求尽早地出错，而不是在发送给 kube-apiserver 之后再返回错误，例如创建了一个不支持的资源或者一个<a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubectl/cmd/run/run.go#L264">异常的镜像名</a>。这个校验过程通过减少不必要的负载提升了系统的性能。</p>
<p>校验完成后，kubectl 开始组装将要发送到 kube-apiserver 的 HTTP 请求。任何希望访问或者改变 Kubernetes 系统状态的请求都会经过 API server 并最终与 etcd 进行交互。kubectl 也一样，为了构建这样的 HTTP 请求，kubectl 使用了名为<a href="https://github.com/kubernetes/kubernetes/blob/426ef9335865ebef43f682da90796bd8bf976637/docs/devel/kubectl-conventions.md#generators">生成器</a>的抽象来完成序列化过程。</p>
<p>可能不太明显的是，我们实际上可以使用 <code>kubectl run</code> 指定多个资源类型，而不仅仅是 Deployments。为了实现这一点，如果没有使用 <code>--generator</code> 标志显式指定生成器名称，kubectl 将<a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubectl/cmd/run/run.go#L319-L339">推断</a>出资源的类型。</p>
<p>例如，具有 <code>--restart-policy=Always</code> 标志的资源被视为 Deployments，而具有 <code>--restart-policy=Never</code> 的资源被视为 Pods。kubectl 还会确定是否需要触发其他操作，例如记录命令（用于滚动更新或审计），或者该命令只是通过 <code>--dry-run</code> 标志来指定的模拟运行。</p>
<p>在意识到我们想要创建一个 Deployment 之后，kubectl 将使用 <code>DeploymentAppsV1</code> 生成器根据我们提供的参数生成一个<a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubectl/generate/versioned/run.go#L237">运行时对象</a>。“运行时对象”是一个通用术语，用于表示资源。</p>
<h2 id="API-组别和版本的协商"><a href="#API-组别和版本的协商" class="headerlink" title="API 组别和版本的协商"></a>API 组别和版本的协商</h2><p>在继续之前需要指出的是，Kubernetes 使用 “API 组” 这样的版本化 API。API 组的目的是将相似的资源进行分类，以求更容易理解。它还提供了一个比单一的单体 API 更好的选择。Deployment 的 API 组名为 <code>apps</code>，最新的版本是 <code>v1</code>。这就是为什么在 Deployment 的清单的顶部需要使用 <code>type apiVersion: apps/v1</code>。</p>
<p>无论如何，在 kubectl 生成运行时对象之后，它开始<a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubectl/cmd/run/run.go#L674-L686">查找适当的 API 组和版本</a>，并<a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubectl/cmd/run/run.go#L705-L708">组装一个版本化的客户端</a>，该客户端知道资源的各种 REST 语义。这个发现阶段被称为版本协商，其中 kubectl 扫描远程 API 上的 <code>/apis</code> 路径，取回所有可能的 API 组。由于 kube-apiserver 在此路径上以 OpenAPI 格式公开其模式文档，所以客户端可以轻松完成 API 发现。</p>
<p>为了提高性能，kubectl 还将 OpenAPI 模式<a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/staging/src/k8s.io/cli-runtime/pkg/genericclioptions/config_flags.go#L234">缓存</a>到 <code>~/.kube/cache/discovery</code> 目录中。如果你想看到这个 API 发现的过程，可以尝试删除该目录，并运行一个带有最大值 <code>-v</code> 标志的命令，之后可以看到所有试图找到这些 API 版本的 HTTP 请求。有很多！</p>
<p>最后一步是实际<a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubectl/cmd/run/run.go#L709">发送</a> HTTP 请求。一旦发送请求并收到成功的响应，kubectl 将根据<a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubectl/cmd/run/run.go#L459">预期的输出格式</a>打印出成功消息。</p>
<h2 id="客户端认证"><a href="#客户端认证" class="headerlink" title="客户端认证"></a>客户端认证</h2><p>在之前的步骤中我们没有提到客户端认证，这是在发送 HTTP 请求之前处理的，所以现在让我们来看看这个过程。</p>
<p>为了成功发送请求，kubectl 需要进行身份验证。用户凭据基本上都存储在位于磁盘上的 kubeconfig 文件中，但该文件可以存储在不同的位置。为了定位它，kubectl 执行以下操作：</p>
<ul>
<li>如果提供了 <code>--kubeconfig</code> 标志，则使用该文件。</li>
<li>如果定义了 <code>$KUBECONFIG</code> 环境变量，则使用该变量。</li>
<li>否则，查找<a href="https://github.com/kubernetes/client-go/blob/release-1.21/tools/clientcmd/loader.go#L43">推荐的主目录</a>，如 <code>~/.kube</code>，并使用找到的第一个文件。</li>
</ul>
<p>解析文件后，kubectl 确定要使用的当前上下文、要指向的当前集群以及与当前用户关联的任何身份验证信息。如果用户提供了特定标志的值（例如 <code>--username</code>），则优先使用这些值，并将覆盖 kubeconfig 中指定的值。一旦获得这些信息，kubectl 将补全客户端的配置，以便适当地组装 HTTP 请求：</p>
<ul>
<li>x509 证书使用 <a href="https://github.com/kubernetes/client-go/blob/82aa063804cf055e16e8911250f888bc216e8b61/rest/transport.go#L80-L89">tls.TLSConfig</a> 发送，这也包括根 CA</li>
<li>Bearer token 放置在 “Authorization” HTTP 头中<a href="https://github.com/kubernetes/client-go/blob/c6f8cf2c47d21d55fa0df928291b2580544886c8/transport/round_trippers.go#L314">发送</a></li>
<li>用户名和密码通过 HTTP 基本身份验证<a href="https://github.com/kubernetes/client-go/blob/c6f8cf2c47d21d55fa0df928291b2580544886c8/transport/round_trippers.go#L223">发送</a></li>
<li>OpenID 身份验证过程由用户在之前手动处理，会生成一个像 Bearer token 一样发送的 token</li>
</ul>
<h1 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h1><h2 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h2><p>我们的请求已经发送出去了，太棒了！接下来呢？该轮到 kube-apiserver 出场了。正如我们之前提到的，kube-apiserver 是客户端和系统组件用来持久化和获取集群状态的主要接口。为了开展其工作，它需要能够验证请求者的身份。这个过程被称为身份验证。</p>
<p>kube-apiserver 如何对请求进行身份验证呢？当服务器首次启动时，它会查看用户提供的所有 <a href="https://kubernetes.io/docs/admin/kube-apiserver/">CLI 标志</a>，并组装一个合适的身份验证器列表。举个例子：如果传入了 <code>--client-ca-file</code> 参数，它会添加 x509 身份验证器；如果看到 <code>--token-auth-file</code> 参数，它会将 token 身份验证器添加到列表中。每次接收到请求时，它会<a href="https://github.com/kubernetes/apiserver/blob/51bebaffa01be9dc28195140da276c2f39a10cd4/pkg/authentication/request/union/union.go#L54">通过身份验证器链验证请求，直到有一个成功为止</a>：</p>
<ul>
<li><a href="https://github.com/kubernetes/apiserver/blob/51bebaffa01be9dc28195140da276c2f39a10cd4/pkg/authentication/request/x509/x509.go#L60">x509 验证处理程序</a>将验证 HTTP 请求是否使用由 CA 根证书签名的 TLS 密钥进行加密。</li>
<li><a href="https://github.com/kubernetes/apiserver/blob/51bebaffa01be9dc28195140da276c2f39a10cd4/pkg/authentication/request/bearertoken/bearertoken.go#L38">bearer token 验证处理程序</a>将验证 HTTP 请求中提供的令牌（在 HTTP Header 中 Authorization 字段中指定）是否存在于 <code>--token-auth-file</code> 参数指定的磁盘文件中。</li>
<li><a href="https://github.com/kubernetes/apiserver/blob/51bebaffa01be9dc28195140da276c2f39a10cd4/plugin/pkg/authenticator/request/basicauth/basicauth.go#L37">basic auth 验证处理程序</a>将类似地确保 HTTP 请求的基本身份验证凭据与其自身的本地状态匹配。</li>
</ul>
<p>如果每个身份验证器都失败，<a href="https://github.com/kubernetes/apiserver/blob/20bfbdf738a0643fe77ffd527b88034dcde1b8e3/pkg/authentication/request/union/union.go#L71">该请求将失败</a>，并返回一个聚合错误。如果身份验证成功，Header 中 <code>Authorization</code> 字段将被删除，并将<a href="https://github.com/kubernetes/apiserver/blob/e30df5e70ef9127ea69d607207c894251025e55b/pkg/endpoints/filters/authentication.go#L71-L75">用户信息添加</a>到其上下文中。这使得之后的步骤（例如鉴权和准入）能够访问先前确立的用户身份。</p>
<h2 id="请求鉴权"><a href="#请求鉴权" class="headerlink" title="请求鉴权"></a>请求鉴权</h2><p>好的，请求已经发送出去，kube-apiserver 已成功验证我们的身份。松了一口气！然而，我们还没有结束。我们可能是我们自己说的那个身份，但我们是否有权限执行此操作呢？毕竟，身份和权限是不同的。为了让请求继续执行，kube-apiserver 需要对请求进行鉴权。</p>
<p>kube-apiserver 处理鉴权的方式与身份验证非常相似：根据输入的标志，它将组装一个鉴权器链，针对每个传入的请求依次运行。如果所有鉴权器都拒绝请求，请求将导致 <code>Forbidden</code> 的响应，并且<a href="https://github.com/kubernetes/apiserver/blob/e30df5e70ef9127ea69d607207c894251025e55b/pkg/endpoints/filters/authorization.go#L60">不再继续处理改请求</a>。如果单个鉴权器批准请求，请求将继续进行。</p>
<p>Kubernetes v1.8 提供的一些鉴权器示例包括：</p>
<ul>
<li><a href="https://github.com/kubernetes/apiserver/blob/d299c880c4e33854f8c45bdd7ab599fb54cbe575/plugin/pkg/authorizer/webhook/webhook.go#L143">webhook</a>，与集群外的 HTTP(S) 服务进行交互；</li>
<li><a href="https://github.com/kubernetes/kubernetes/blob/77b83e446b4e655a71c315ad3f3890dc2a220ccf/pkg/auth/authorizer/abac/abac.go#L223">ABAC</a>，强制执行在静态文件中定义的策略；</li>
<li><a href="https://github.com/kubernetes/kubernetes/blob/8db5ca1fbb280035b126faf0cd7f0420cec5b2b6/plugin/pkg/auth/authorizer/rbac/rbac.go#L43">RBAC</a>，强制执行由管理员作为 k8s 资源添加的 RBAC 角色；</li>
<li><a href="https://github.com/kubernetes/kubernetes/blob/dd9981d038012c120525c9e6df98b3beb3ef19e1/plugin/pkg/auth/authorizer/node/node_authorizer.go#L67">Node</a>，确保节点客户端（即 kubelet）只能访问托管在自身上的资源。</li>
</ul>
<p>可以通过查看每个鉴权器的 <code>Authorize</code> 方法，了解它们的工作原理。</p>
<h2 id="准入控制"><a href="#准入控制" class="headerlink" title="准入控制"></a>准入控制</h2><p>好的，到目前为止，我们已经通过了 kube-apiserver 的身份验证和请求鉴权。那接下来呢？从 kube-apiserver 的角度来看，它相信我们是谁并允许请求继续执行，但在 Kubernetes 中，系统的其他部分对于什么应该和不应该发生有严格的要求。这时候<a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-are-they">准入控制器</a>就开始发挥作用了。</p>
<p>虽然鉴权的重点是判断用户是否有权限，但准入控制器拦截请求以确保其符合集群的更大范围的预期和规则。它们是对象持久化到 etcd 之前的最后一道控制屏障，因此它们封装了剩余的系统检查，以确保操作不会产生意外或负面的结果。</p>
<p>准入控制器的工作方式类似于验证器和鉴权器，但有一个区别：与验证器和授权器链不同，如果单个准入控制器校验失败，整个链条将中断，请求将失败。</p>
<p>准入控制器设计的真正精妙之处在于其专注于促进可扩展性。每个控制器都存储为 <a href="https://github.com/kubernetes/kubernetes/tree/master/plugin/pkg/admission"><code>plugin/pkg/admission</code> 目录</a>中的插件，并且被设计为满足一个小接口。然后，每个控制器都被编译到主要的 kubernetes 二进制文件中。</p>
<p>准入控制器通常按照功能分为资源管理、安全性、默认设置和引用一致性几类。以下是一些负责资源管理的准入控制器的示例：</p>
<p><code>InitialResources</code>：根据过去的使用情况为容器的资源设置默认限制。<br><code>LimitRanger</code>：为容器的请求和限制设置默认值，或对某些资源配置上限（例如内存不超过 2GB，默认为 512MB）。<br><code>ResourceQuota</code>：在命名空间内统计或拒绝分配一定数量的对象（pod、rc、service 负载均衡器）或总消耗的资源（CPU、内存、磁盘）。</p>
<h1 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h1><p>到目前为止，Kubernetes 已经完全检查了传入的请求，并且允许其继续执行。接下来，kube-apiserver 对 HTTP 请求进行反序列化，从中构建运行时对象（类似于 kubectl 的生成器的逆过程），并将它们持久化到数据存储中。让我们来详细解析一下这个过程。</p>
<p>kube-apiserver 怎么知道接受我们的请求时该做什么呢？在任何请求被处理之前都有一系列复杂的步骤。让我们从起点开始，也就是二进制文件首次运行时：</p>
<ol>
<li>当 <code>kube-apiserver</code> 二进制文件运行时，它创建一个<a href="https://github.com/kubernetes/kubernetes/blob/1795a98eebe58fcce3b9b0a8af35d10bf91cee5b/cmd/kube-apiserver/app/server.go#L174">服务器链</a>，用于支持 apiserver 的聚合。这只是支持多个 apiserver 的一种方式，我们不需要担心这个。</li>
<li>在这个过程中，会创建一个<a href="https://github.com/kubernetes/kubernetes/blob/1795a98eebe58fcce3b9b0a8af35d10bf91cee5b/cmd/kube-apiserver/app/server.go#L210">通用的 apiserver</a> 作为默认实现。</li>
<li>生成的 OpenAPI 模式补充了 <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/server/config.go#L149">apiserver 的配置</a>。</li>
<li>kube-apiserver 然后遍历模式中指定的所有 API 组，并为每个 API 组配置一个<a href="https://github.com/kubernetes/kubernetes/blob/c7a1a061c3dc5acabcc0c35b3b96a6935dccf546/pkg/master/master.go#L410">存储供应器</a>作为通用的存储抽象，kube-apiserver 在访问或修改资源状态时需要与其进行交互。</li>
<li>对于每个 API 组，它还会遍历每个组版本，并为每个 HTTP 路由<a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/groupversion.go#L92">安装 REST 映射</a>。这让 kube-apiserver 能够正常映射请求，并在找到匹配项后把请求代理给正确的逻辑处理。</li>
<li>对于我们的特定用例，会注册一个 <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/installer.go#L710">POST 处理程序</a>，该处理程序将进一步代理给一个<a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L37">创建资源的处理程序</a>。</li>
</ol>
<p>截至目前，kube-apiserver 已经完全了解了存在的路由和内部映射，在请求到来时能将其转发到正确的处理程序和存储供应器。现在设想我们的 HTTP 请求已经到达：</p>
<ol>
<li>如果处理程序链能够将请求与一组模式匹配（即我们注册的路由），它将把请求分发到为<a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/server/handler.go#L143">该路由注册的专用处理程序</a>。否则，它将回退到<a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/server/mux/pathrecorder.go#L248">基于路径的处理程序</a>（例如调用 <code>/apis</code> 时的情况）。如果没有为该路径注册处理程序，则会调用一个未找到的处理程序，导致返回 404 错误。</li>
<li>幸运的是，我们有一个名为 <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L37"><code>createHandler</code></a> 的注册路由！它的工作原理是什么呢？首先，它会解码 HTTP 请求并执行基本验证，例如确保提供的 JSON 与我们对版本化 API 资源的预期相符。</li>
<li><a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L93-L104">进行审计和最终的准入</a>。</li>
<li><a href="https://github.com/kubernetes/apiserver/blob/19667a1afc13cc13930c40a20f2c12bbdcaaa246/pkg/registry/generic/registry/store.go#L327">通过代理给存储供应器</a>将资源<a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L111">保存到 etcd 中</a>。通常，etcd 键的形式为 <code>&lt;namespace&gt;/&lt;name&gt;</code>，但这也是可配置的。</li>
<li>捕获任何创建时的错误，最后存储供应器执行 <code>get</code> 调用以确保对象实际上已创建。然后，如果需要进行其他的最终处理，它会调用任何创建后(Post-create)处理程序和装饰器。</li>
<li><a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L131-L142">构建</a>并返回 HTTP 响应。</li>
</ol>
<p>步骤很多！通过追溯这些步骤，我们能看到 apiserver 实际上做了多少工作。所以总结一下：我们的 Deployment 资源现在存在于 etcd 中。但是其中还有一些尚未完成的流程，所以目前我们还没办法看到它…</p>
<h1 id="初始化器"><a href="#初始化器" class="headerlink" title="初始化器"></a>初始化器</h1><p>在将对象持久化到数据存储中后，只有在一系列<a href="https://kubernetes.io/docs/admin/extensible-admission-controllers/#initializers">初始化器</a>运行完成之后，该对象才会对 apiserver 或调度程序完全可见。初始化器是与资源类型相关联的控制器，在资源对外界可见之前对资源执行相关逻辑操作。如果某个资源类型没有注册任何初始化器，则会跳过此初始化步骤，资源会立即对外可见。</p>
<p>正如<a href="https://ahmet.im/blog/initializers/">许多优质的博客文章</a>介绍的，这是一个强大的功能，因为它让我们能够执行通用的引导操作。例如：</p>
<ul>
<li>将代理边车容器注入到公开端口 80 的 Pod 中，或者具有特定注释的 Pod 中。</li>
<li>向特定命名空间中的所有 Pod 注入带有测试证书的卷。</li>
<li>如果一个 Secret 的长度小于 20 个字符（例如密码），阻止其创建。</li>
</ul>
<p><code>initializerConfiguration</code> 对象允许我们声明哪些初始化器应该针对特定的资源类型运行。想象一下，如果我们希望在每次创建 Pod 时运行自定义的初始化器，我们可以这样做：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">admissionregistration.k8s.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">InitializerConfiguration</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">custom-pod-initializer</span></span><br><span class="line"><span class="attr">initializers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">podimage.example.com</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="attr">apiVersions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">v1</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">pods</span></span><br></pre></td></tr></table></figure>

<p>创建完这个配置后，它会将 <code>custom-pod-initializer</code> 添加到每个 Pod 的 <code>metadata.initializers.pending</code> 字段中。初始化器控制器会定期扫描新的 Pods。当初始化器检测到一个 Pod 的 pending 字段中有自己的名称时，它会执行相应的逻辑。完成逻辑处理后，它会从 pending 列表中移除自己的名称。只有列表中第一个名称的初始化器才能对资源进行操作。当所有的初始化器完成逻辑处理并且 <code>pending</code> 字段为空时，该对象将被认为已经初始化。</p>
<p>细心的你可能已经发现了一个潜在的问题。如果资源在 kube-apiserver 中不可见，用户自定义的控制器如何处理这些资源呢？为了解决这个问题，kube-apiserver 提供了一个 <code>?includeUninitialized</code> 查询参数，它返回所有对象，包括未初始化的对象。</p>
<h1 id="控制循环"><a href="#控制循环" class="headerlink" title="控制循环"></a>控制循环</h1><h2 id="Deployments-控制器"><a href="#Deployments-控制器" class="headerlink" title="Deployments 控制器"></a>Deployments 控制器</h2><p>现在我们的 Deployment 记录已存储在 etcd 中，并且任何初始化逻辑都已完成。接下来的步骤涉及设置 Kubernetes 所依赖的资源拓扑结构。我们可以这样想，一个 Deployment 实际上只是一组 ReplicaSet，而一个 ReplicaSet 是一组 Pod。那么 Kubernetes 是如何通过一个 HTTP 请求来创建这样的多层级结构的呢？这其实是 Kubernetes 内置的控制器的作用。</p>
<p>Kubernetes 在整个系统中广泛地使用“控制器”。控制器是一个异步逻辑，用来将 Kubernetes 系统的当前状态与期望的状态进行协调(reconcile)。每个控制器都有自己的任务，并和 <code>kube-controller-manager</code> 组件一起并行运行。让我们先介绍接管工作的第一个控制器，即 Deployment 的控制器。</p>
<p>在 Deployment 的记录存储到 etcd 并初始化后，kube-apiserver 使其对外可见。当这个新的资源可用时，它会被 Deployment 控制器检测到，Deployment 控制器的工作是监听对 Deployment 记录的变动。在我们的例子里，控制器通过 informer 为资源新建的事件注册了一个<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/deployment/deployment_controller.go#L122">特定的回调函数</a>（有关此内容的更多信息，请参见下文）。</p>
<p>当我们的 Deployment 首次可用时，这个回调处理程序将被执行，并首先<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/deployment/deployment_controller.go#L170">将对象添加到内部工作队列</a>中。当控制器处理我们的对象时，它通过标签选择器查询 kube-apiserver <a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/deployment/deployment_controller.go#L572">检查</a>出我们的 Deployment 没有与之<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/deployment/deployment_controller.go#L633">关联的 ReplicaSet 或 Pod 记录</a>。有趣的是，这个同步过程是与状态无关的：新的记录和老的记录协调方式相同。</p>
<p>在发现没有对应的 ReplicaSet 或者 Pod 记录后，它会通过一个<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/deployment/sync.go#L385">弹性进程</a>创建一个 ReplicaSet 资源，为其分配一个标签选择器，并给它分配版本号为 1。ReplicaSet 的 PodSpec 是从 Deployment 的配置清单中复制过来的，当然也包括其他相关的元数据。在此之后，有时还需要更新 Deployment 记录（例如，如果设置了处理截止时间）。</p>
<p>之后会<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/deployment/sync.go#L70">更新 Deployment 的状态</a>，并重新进入相同的协调循环，直到 Deployment 达到期望的完成状态。由于 Deployment 控制器只关注创建 ReplicaSet，因此这个协调阶段需要由下一个控制器继续进行，也就是 ReplicaSet 控制器。</p>
<h2 id="ReplicaSets-控制器"><a href="#ReplicaSets-控制器" class="headerlink" title="ReplicaSets 控制器"></a>ReplicaSets 控制器</h2><p>在前面的步骤中，Deployment 控制器为我们的 Deployment 创建了第一个 ReplicaSet，但我们还没有看到 Pod。这之后 ReplicaSet 控制器将发挥作用！它的任务是监听 ReplicaSet 及其依赖资源（Pod）的生命周期。与大多数其他控制器一样，它通过在特定事件上触发处理程序来实现这个功能。</p>
<p>首先我们来看资源创建事件。当创建了一个 ReplicaSet（由部署控制器负责）时，ReplicaSet 控制器会<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/replicaset/replica_set.go#L583">检查新 ReplicaSet 的状态</a>，并发现当前状态与预期状态之间存在的差异。然后它尝试通过<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/replicaset/replica_set.go#L460">增加 ReplicaSet 的 Pod 数量</a>来调解这个状态。它非常谨慎地创建这些 Pod，确保 ReplicaSet 的突发计数（它从其父级部署继承的）始终保持匹配。</p>
<p>Pod 的也是<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/replicaset/replica_set.go#L487">批量创建</a>的，从 <code>SlowStartInitialBatchSize</code> 开始，每次成功创建后扩大一倍，以一种类似于“慢启动”的方式进行。这样做的目的是减轻同时出现大量 Pod 启动失败时（例如，由于资源配额不足）引发 kube-apiserver 负载过高，同时能够减少不必要的 HTTP 请求。如果组件会失败报错，我们最好以对其他系统组件的影响最小的方式来优雅地失败！</p>
<p>Kubernetes 通过 Owner References（这是子资源中的一个字段，用来引用其父级的 UID）来保证对象的层级结构。这不仅确保一旦由控制器管理的资源被删除，子资源就会被垃圾回收，还为父资源提供了一种有效的方式以避免它们争夺子资源（设想一下两个父级认为它们拥有同一个子资源的情况！）。</p>
<p>Owner Reference 设计的另一个微妙好处是它是有状态的：如果任何控制器重新启动，由于资源拓扑结构独立于控制器，它的宕机状态不会影响更多的组件。这种对隔离的关注也包含在控制器本身的设计中：它们不应该管理它们没有明确声明拥有的资源。控制器应该在所有权的声明中进行选择，并且不干扰、不共享。</p>
<p>无论如何，回到 Owner Reference！有时系统中会出现“孤立”(orphaned)的资源，该情况通常由以下原因导致：</p>
<ul>
<li>删除了父资源，但没有删除其子资源。</li>
<li>垃圾回收策略禁止删除子资源。</li>
</ul>
<p>发生这种情况时，控制器将确保孤立资源被一个新的父级资源接管。多个父级资源可以竞争接管子资源，但只有一个会成功（其余的父级资源将收到验证错误）。</p>
<h2 id="Informers"><a href="#Informers" class="headerlink" title="Informers"></a>Informers</h2><p>正如你可能已经注意到的那样，一些控制器（例如如 RBAC 鉴权器或 Deployment 控制器）需要查询集群状态以正常工作。以 RBAC 鉴权器为例，我们知道当请求到达时，验证器将保存用户状态的初始信息以备后用。然后，RBAC 鉴权器将使用改信息来查询用户在 etcd 中关联的所有角色以及角色绑定。控制器应该如何访问和修改这些资源？在 Kubernetes 中往往通过 informer 来解决。</p>
<p>informer 是一种允许控制器通过简单的订阅存储事件来获取它们关注的资源的设计范式。除了提供良好的抽象外，它还处理了许多细节，例如缓存（缓存很重要，因为它减少了与 kube-apiserver 的不必要的连接，并减少了服务器和控制器端重复序列化的开销）。通过该设计，控制器还可以用线程安全的方式进行交互，而不必担心干扰其他任何人。</p>
<p>有关 informer 在控制器中的工作方式的细节，可以参阅这篇<a href="http://borismattijssen.github.io/articles/kubernetes-informers-controllers-reflectors-stores">博客</a>。</p>
<h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><p>在上述所有控制器运行完成后，我们在 etcd 中存储了一个 Deployment、一个 ReplicaSet 和三个 Pod，并且可以通过 kube-apiserver 查询到它们。然而我们的 Pod 仍处在 <code>Pending</code> 状态，因为它们尚未被调度到节点上。解决这个问题的最后一个控制器是调度器(Scheduler)。</p>
<p>调度器作为控制平面的一个独立组件运行，并且以与其他控制器相同的方式工作：它监听事件并尝试调解状态。在这种情况下，调度器<a href="https://github.com/kubernetes/kubernetes/blob/master/plugin/pkg/scheduler/factory/factory.go#L190">筛选</a>出 PodSpec 中 <code>NodeName</code> 字段为空的 Pod，并尝试寻找一个适合该 Pod 的节点。</p>
<p>为了找到一个适合的节点，调度器使用特定的调度算法。默认调度算法的工作方式如下：</p>
<ol>
<li><p>当调度器启动时，会<a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/plugin/pkg/scheduler/algorithmprovider/defaults/defaults.go#L65-L81">注册一系列默认的谓词(Predicates)</a>。这些谓词实际上是函数，这些函数根据节点是否适合托管 Pod 来进行<a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/plugin/pkg/scheduler/core/generic_scheduler.go#L117">过滤</a>。例如，如果 PodSpec 明确要求一定的 CPU 或 RAM 资源，容量不足而无法满足这些要求的节点将被排除在 Pod 之外（资源容量计算为总容量减去当前运行容器的资源请求总和）。</p>
</li>
<li><p>一旦选择了合适的节点，会对过滤后的节点<a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/plugin/pkg/scheduler/core/generic_scheduler.go#L354-L360">运行一系列优先级函数</a>，以对它们的适合程度进行排序。例如，为了在系统中分散工作负载，调度器会倾向于资源富裕的节点（因为这表示较少的工作负载正在运行）。在运行这些函数时，它会为每个节点分配一个数值等级。然后选择排名最高的节点进行调度。</p>
</li>
</ol>
<p>调度算法找到节点后，调度器会<a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/plugin/pkg/scheduler/scheduler.go#L336-L342">创建一个绑定对象</a>，其 Name 和 UID 与 Pod 匹配，其 ObjectReference 字段包含所选节点的名称，然后通过 POST 请求将其<a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/plugin/pkg/scheduler/factory/factory.go#L1095">发送到 apiserver</a>。</p>
<p>当 kube-apiserver 接收到此绑定对象时，注册表会反序列化对象并更新 Pod 对象上的以下字段：将 NodeName <a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/pkg/registry/core/pod/storage/storage.go#L170">设置</a>为 ObjectReference 中的节点名称，<a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/pkg/registry/core/pod/storage/storage.go#L174-L176">添加相关的注解</a>，并将其 <code>PodScheduled</code> 状态条件<a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/pkg/registry/core/pod/storage/storage.go#L177-L180">设置</a>为 <code>True</code>。</p>
<p>一旦调度器将 Pod 调度到节点上，该节点上的 kubelet 就可以开始接管并进行部署。真是令人兴奋！</p>
<p>提示：自定义调度器时谓词和优先级函数都是可扩展的，并且可以使用 <code>--policy-config-file</code> 标志进行定义。这提供了一定程度的灵活性。管理员还可以在独立的 Deployment 中运行自定义调度器（具有自定义处理逻辑的控制器）。如果 PodSpec 包含 <code>schedulerName</code>，Kubernetes 将把该 Pod 的调度交给已注册在该名称下的调度器。</p>
<h1 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h1><h2 id="Pod-同步"><a href="#Pod-同步" class="headerlink" title="Pod 同步"></a>Pod 同步</h2><p>好的，主要的控制器循环已经完成，呼！总结一下：HTTP 请求通过了身份验证、鉴权和准入控制阶段；一个 Deployment、一个 ReplicaSet 和三个 Pod 资源被持久化到了 etcd 中；一系列初始化程序已经运行；最后，每个 Pod 被调度到了一个合适的节点上。然而到目前为止我们所有推演的状态完全存在于 etcd 中。接下来的步骤涉及将状态分发到工作节点上，这是 Kubernetes 这样的分布式系统的核心目标！接下来的过程是通过一个叫做 kubelet 的组件来实现的。我们开始吧！</p>
<p>kubelet 是在 Kubernetes 集群的每个节点上运行的代理程序，负责管理 Pod 的生命周期等任务。这意味着它处理了从 Pod（实际上只是 Kubernetes 的一个概念）到其构建块（容器）的所有转换逻辑。它还处理与挂载卷、容器日志、垃圾回收等相关逻辑以及许多其他重要事项。</p>
<p>一个便于理解的方法是：可以把 kubelet 看做一个控制器！它会每隔 20 秒（可配置）从 kube-apiserver 查询 Pod，过滤出 <code>NodeName</code> 与该 kubelet 所在<a href="https://github.com/kubernetes/kubernetes/blob/3b66adb8bc6929e1205bcb2bc32f380c39be8381/pkg/kubelet/config/apiserver.go#L34">节点名称匹配</a>的 Pod。一旦获得该 Pod 的列表，它会通过与自己的内部缓存进行比较来检测新增的 Pod，当比较存在差异时开始同步状态。我们来看看这个同步过程是什么样的：</p>
<ol>
<li>如果正在创建 Pod（我们的 Pod 正在创建中！），kubelet 会<a href="https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet.go#L1519">注册</a>一些用于在 Prometheus 中跟踪 Pod 延迟的启动指标。</li>
<li>然后，它<a href="https://github.com/kubernetes/kubernetes/blob/dd9981d038012c120525c9e6df98b3beb3ef19e1/pkg/kubelet/kubelet_pods.go#L1287">生成一个 PodStatus 对象</a>，表示 Pod 当前阶段的状态。Pod 的阶段是其生命周期中的高度总结。阶段包括 <code>Pending</code>、<code>Running</code>、<code>Succeeded</code>、<code>Failed</code> 和 <code>Unknown</code>。生成这个状态相当复杂，所以我们来详细了解一下具体发生了什么：</li>
</ol>
<ul>
<li>首先，按顺序执行一系列同步处理程序 <code>PodSyncHandlers</code>。每个处理程序都检查 Pod 是否仍应驻留在节点上。如果它们中的任何一个决定该 Pod 不再属于该节点，Pod 的阶段将<a href="https://github.com/kubernetes/kubernetes/blob/dd9981d038012c120525c9e6df98b3beb3ef19e1/pkg/kubelet/kubelet_pods.go#L1293-L1297">变为</a> <code>PodFailed</code>，并最终被从该节点中驱逐出去。例子包括在超过 <code>activeDeadlineSeconds</code> 后驱逐 Pod（在 Job 资源中常用）。</li>
<li>接下来，根据其初始化和实际容器的状态确定 Pod 的阶段。由于我们的容器尚未启动，容器被归为<a href="https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet_pods.go#L1244">等待状态</a>。Pod 在拥有等待容器时的阶段为 <a href="https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet_pods.go#L1258-L1261"><code>Pending</code></a>。</li>
<li>最后，根据容器的状态确定 Pod 的条件。由于我们的容器尚未由容器运行时创建，<a href="https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/status/generate.go#L70-L81">它将把 <code>PodReady</code> 条件设置为 False</a>。</li>
</ul>
<ol start="3">
<li>生成 PodStatus 后，它将被发送给 Pod 的状态管理器，后者负责通过 apiserver 异步更新 etcd 记录。</li>
<li>接下来，一系列准入处理程序会确保 Pod 具有正确的安全权限。这包括校验 <a href="https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet.go#L883-L884">AppArmor 配置文件和 <code>NO_NEW_PRIVS</code></a> 等。在此阶段被拒绝的 Pod 将永远保持在 <code>Pending</code> 状态。</li>
<li>如果指定了 <code>cgroups-per-qos</code> 运行时标志，kubelet 将为 Pod 创建 cgroups 并应用资源参数。这是为了给 Pod 提供更好的服务质量(QoS)。</li>
<li>为 Pod <a href="https://github.com/kubernetes/kubernetes/blob/dd9981d038012c120525c9e6df98b3beb3ef19e1/pkg/kubelet/kubelet_pods.go#L772">创建数据目录</a>。这包括 Pod 的目录（通常为 <code>/var/run/kubelet/pods/&lt;podID&gt;</code>）、卷目录（<code>&lt;podDir&gt;/volumes</code>）和插件目录（<code>&lt;podDir&gt;/plugins</code>）。</li>
<li>卷管理器将<a href="https://github.com/kubernetes/kubernetes/blob/2723e06a251a4ec3ef241397217e73fa782b0b98/pkg/kubelet/volumemanager/volume_manager.go#L330">绑定并等待</a> Spec.Volumes 中定义的所有相关卷。根据要挂载的卷的类型的不同，某些 Pod 可能需要等待更长时间（例如云存储或 NFS 卷）。</li>
<li><a href="https://github.com/kubernetes/kubernetes/blob/dd9981d038012c120525c9e6df98b3beb3ef19e1/pkg/kubelet/kubelet_pods.go#L788">从 apiserver 中查询</a>在 <code>Spec.ImagePullSecrets</code> 中定义的所有密钥，以便后续注入到容器中。</li>
<li>最后由容器运行时(CRI)来运行容器（下面将详细描述）。</li>
</ol>
<h2 id="CRI-和暂停容器"><a href="#CRI-和暂停容器" class="headerlink" title="CRI 和暂停容器"></a>CRI 和暂停容器</h2><p>我们现在已经完成了大部分的配置工作，容器已经准备好启动了。负责启动容器的软件被称为容器运行时（例如 <code>Docker</code> 或 <code>rkt</code> ）。</p>
<p>为了更好的扩展性，自 Kubernetes v1.5.0 以来，kubelet 一直在使用称为 CRI（Container Runtime Interface）的概念与具体的容器运行时进行交互。简而言之，CRI 提供了 kubelet 与特定运行时实现之间的抽象接口。通信通过 <a href="https://github.com/google/protobuf">protocol buffers</a> 完成（类似于更快的 JSON），并使用 <a href="https://grpc.io/">gRPC API</a>（一种非常适合执行 Kubernetes 操作的 API 类型）。这是一个非常酷的想法，因为通过使用 kubelet 和容器运行时之间的定义合约，容器编排的具体实现细节变得相对不重要，唯一重要的是合约。这使得可以用最小的开销添加新的运行时，因为我们不需要更改核心 Kubernetes 代码！</p>
<p>话题岔开太远了，让我们回到部署容器的过程本身。当一个 Pod 首次启动时，<a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/pkg/kubelet/kuberuntime/kuberuntime_sandbox.go#L51">kubelet 调用 RunPodSandbox</a> 远程过程调用（RPC）。沙盒 Sandbox 是 CRI 术语，用来描述一组容器，在 Kubernetes 术语中就是一个 Pod。这个术语被刻意地设计得比较模糊，以便对于其他可能实际上不使用容器的运行时（比如基于虚拟化的运行时，其中的沙盒可能是一个虚拟机）也适用。</p>
<p>在我们的例子中，我们使用的是 Docker。在这个运行时中，创建一个沙盒其实是创建一个暂停容器。暂停容器作为 Pod 中所有其他容器的父容器，承载了许多工作负载容器将要使用的 Pod 级资源。这些“资源”是 Linux 的命名空间（IPC、网络、PID）。如果你对 Linux 中容器的工作原理不熟悉，我们进行一个简短的复习。Linux 内核具有命名空间的概念，允许主机操作系统划分出一组专用资源（例如 CPU 或内存），并将其提供给一个进程，就好像它是世界上唯一使用这些资源的进程一样。在这里，Cgroups 也很重要，因为它们是 Linux 管理资源分配的方式（有点像监管资源使用的警察）。Docker 使用这两个内核特性来运行具有足够资源和强制隔离的进程。要了解更多信息，请查看 b0rk 的精彩文章<a href="https://jvns.ca/blog/2016/10/10/what-even-is-a-container/">《容器到底是什么》</a>。</p>
<p>暂停容器提供了一种托管所有这些命名空间并允许子容器共享它们的方式。处在同一个网络命名空间的好处是同一个 Pod 中的容器可以使用 localhost 相互引用。暂停容器的第二个角色与 PID 命名空间的工作原理有关。在这些类型的命名空间中，进程形成一个层次树，顶部的初始化进程负责“清理”已经退出的进程。要了解这是如何工作的更多信息，请查看这篇<a href="https://www.ianlewis.org/en/almighty-pause-container">精彩的博客</a>。在创建完暂停容器后，它会被存档到磁盘上，并启动运行。</p>
<h2 id="CNI-和-Pod-通信"><a href="#CNI-和-Pod-通信" class="headerlink" title="CNI 和 Pod 通信"></a>CNI 和 Pod 通信</h2><p>现在，我们的 Pod 已经有了个基本的骨架：一个承载所有命名空间以实现跨 Pod 通信的暂停容器。但是其中的网络是如何生效的，又该如何进行设置呢？</p>
<p>当 kubelet 为一个 Pod 设置网络时，它将任务委派给一个名为 CNI 的插件。CNI 代表容器网络插件 Container Network Interface，其工作方式类似于 Container Runtime Interface。简而言之，CNI 是一个抽象层，允许不同的网络供应程序使用不同的容器网络实现。kubelet 通过将 JSON 数据（配置文件位于 <code>/etc/cni/net.d</code>）经过 stdin 传送给相关的 CNI 二进制文件（位于 <code>/opt/cni/bin</code>）与注册好的插件进行交互。这是一个 JSON 配置的示例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cniVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.3.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;bridge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cnio0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;isGateway&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ipMasq&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ipam&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;host-local&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ranges&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">[</span><span class="punctuation">&#123;</span> <span class="attr">&quot;subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;POD_CIDR&#125;&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;routes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span> <span class="attr">&quot;dst&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0/0&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>它还通过环境变量 <code>CNI_ARGS</code> 指定了 Pod 的附加元数据，例如它们的名称和命名空间。</p>
<p>接下来发生的步骤取决于具体的 CNI 插件，我们先来看看网桥(<code>bridge</code>) CNI 插件的工作流程：</p>
<ol>
<li>首先，网桥插件将在主机的根网络命名空间中设置一个本地 Linux 网桥（bridge），以服务于该主机上的所有容器。</li>
<li>然后，它将在暂停容器的网络命名空间中插入一个接口（一对 veth 的一端），并将另一端连接到网桥（bridge）上。最好将一对 veth 想象成一个大管道：一端连接到容器，另一端在根网络命名空间中，使得数据包在两者之间进行传递。</li>
<li>接下来，网桥插件应该为暂停容器的网卡分配一个 IP 地址并设置路由，这使得 Pod 拥有了自己的 IP 地址。IP 地址分配是委派给在 JSON 配置中指定的 IPAM 提供程序来完成的。</li>
</ol>
<ul>
<li>IPAM 插件与主要的网络插件类似：它们通过二进制文件调用，拥有标准化的接口。每个 IPAM 插件必须确定容器接口的 IP&#x2F;子网，以及网关和路由，并将这些信息返回给主插件。最常见的 IPAM 插件称为 <code>host-local</code>，它从预定义的地址范围中分配 IP 地址。它将状态存储在主机的文件系统上，以确保在单个主机上 IP 地址的唯一性。</li>
</ul>
<ol start="4">
<li>至于 DNS，kubelet 将向 CNI 插件提供内部 DNS 服务器的 IP 地址，CNI 插件将确保容器的 <code>resolv.conf</code> 文件设置正确。</li>
</ol>
<p>上述步骤都完成后，CNI 插件会向 kubelet 返回 JSON 数据说明操作的结果。</p>
<h2 id="跨节点通信"><a href="#跨节点通信" class="headerlink" title="跨节点通信"></a>跨节点通信</h2><p>到目前为止，我们已经解释了容器如何连接到主机，但主机之间如何通信呢？当位于不同机器上的两个 Pod 想要通信时，就自然会涉及节点间的通信。</p>
<p>通常，节点间通信是通过一种称为覆盖网络（overlay networking）的概念实现的，它是一种在多个主机之间动态同步路由的方式。一个流行的覆盖网络供应者是 Flannel。安装完成后，它的核心任务是在集群中的多个节点之间提供第 3 层的 IPv4 网络。Flannel 不控制容器如何与主机进行网络连接（这是 CNI 的工作，请记住），而是控制主机之间的流量传输。为此，它为主机分配一个子网，并在 etcd 中注册这个子网。随后，它保持集群路由的本地表示，并将传出数据包封装在 UDP 数据报中，确保其到达正确的主机。要了解更多信息，请参阅 <a href="https://github.com/coreos/flannel">CoreOS 的文档</a>。</p>
<h2 id="容器启动"><a href="#容器启动" class="headerlink" title="容器启动"></a>容器启动</h2><p>所有关于网络的过程都已经介绍了。接下来还剩下什么呢？好吧，我们需要真正地启动工作负载容器。</p>
<p>一旦沙盒初始化完成并处于活动状态，kubelet 就可以开始为其创建容器。它首先启动在 PodSpec 中定义的<a href="https://github.com/kubernetes/kubernetes/blob/5adfb24f8f25a0d57eb9a7b158db46f9f46f0d80/pkg/kubelet/kuberuntime/kuberuntime_manager.go#L690">所有 init 容器</a>，然后再启动主要的容器本身。具体过程如下：</p>
<ol>
<li><a href="https://github.com/kubernetes/kubernetes/blob/5f9f4a1c5939436fa320e9bc5973a55d6446e59f/pkg/kubelet/kuberuntime/kuberuntime_container.go#L90">拉取容器的镜像</a>。PodSpec 中定义的加密信息（secrets）都将用于私有的镜像仓库；</li>
<li>通过 CRI <a href="https://github.com/kubernetes/kubernetes/blob/5f9f4a1c5939436fa320e9bc5973a55d6446e59f/pkg/kubelet/kuberuntime/kuberuntime_container.go#L115">创建容器</a>。沙盒会先从父 PodSpec 中生成一个 ContainerConfig 结构体（其中定义了命令、镜像、标签、挂载点、设备、环境变量等），然后通过 protobuf 将其发送给 CRI 插件。以 Docker 举例，它会反序列化有效的负载并生成自己的配置结构以发送到 Docker 的守护进程 API。在此过程中，它会向容器中注入一些元数据标签，例如容器类型、日志路径、沙盒 ID。</li>
<li>然后，它将使用 CPU 管理器（CPU manager）注册容器。CPU 管理器是 1.8 中的一个新的 alpha 功能，它使用 <code>UpdateContainerResources</code> CRI 方法将容器分配到本地节点上的一组 CPU。</li>
<li>接下来容器被<a href="https://github.com/kubernetes/kubernetes/blob/5f9f4a1c5939436fa320e9bc5973a55d6446e59f/pkg/kubelet/kuberuntime/kuberuntime_container.go#L135">启动</a>。</li>
<li>如果注册了任何后启动（post-start）的容器生命周期钩子，它们将被<a href="https://github.com/kubernetes/kubernetes/blob/5f9f4a1c5939436fa320e9bc5973a55d6446e59f/pkg/kubelet/kuberuntime/kuberuntime_container.go#L156-L170">执行</a>。钩子可以是 <code>Exec</code> 类型（在容器内执行特定命令）或 <code>HTTP</code> 类型（针对容器端点执行 HTTP 请求）。如果 PostStart 钩子运行时间过长、挂起或失败，容器将永远无法变成 <code>running</code> 状态。</li>
</ol>
<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>好的，终于完成了。</p>
<p>经过所有这些步骤，我们应该在一个或多个工作节点上运行着 3 个容器。所有的网络、卷和加密信息都已由 kubelet 配置完成，并通过 CRI 插件转换为容器。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>当我执行 kubectl create 时发生了什么[译]</p><p><a href="https://powerfooi.github.io/2024/01/13/WhatHappensWhenK8s/">https://powerfooi.github.io/2024/01/13/WhatHappensWhenK8s/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>PowerfooI</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-01-13</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-08-04</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Reading/">Reading</a><a class="link-muted mr-2" rel="tag" href="/tags/CloudNative/">CloudNative</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=660fc46b8643100019977f2b&amp;product=inline-share-buttons&amp;source=platform" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/02/03/ReadSourceOfControllerRuntime/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Controller-runtime 源码阅读</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/12/31/WhiteDeerPlain/"><span class="level-item">用两年读完《白鹿原》</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "fb8530a12ee28d96f7231e7f66355724",
            repo: "powerfooI.github.io",
            owner: "powerfooI",
            clientID: "de634a427346094182ce",
            clientSecret: "977edb8eca9693667f47bdbb9ab33c9739f1c494",
            admin: ["powerfooI"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/logo.png" alt="PowerfooI"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">PowerfooI</p><p class="is-size-6 is-block">码农，努力成为软件工程师</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>浙江杭州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">35</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">37</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/PowerfooI" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#kubectl"><span class="level-left"><span class="level-item">1</span><span class="level-item">kubectl</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#校验和生成器"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">校验和生成器</span></span></a></li><li><a class="level is-mobile" href="#API-组别和版本的协商"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">API 组别和版本的协商</span></span></a></li><li><a class="level is-mobile" href="#客户端认证"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">客户端认证</span></span></a></li></ul></li><li><a class="level is-mobile" href="#kube-apiserver"><span class="level-left"><span class="level-item">2</span><span class="level-item">kube-apiserver</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#身份验证"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">身份验证</span></span></a></li><li><a class="level is-mobile" href="#请求鉴权"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">请求鉴权</span></span></a></li><li><a class="level is-mobile" href="#准入控制"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">准入控制</span></span></a></li></ul></li><li><a class="level is-mobile" href="#etcd"><span class="level-left"><span class="level-item">3</span><span class="level-item">etcd</span></span></a></li><li><a class="level is-mobile" href="#初始化器"><span class="level-left"><span class="level-item">4</span><span class="level-item">初始化器</span></span></a></li><li><a class="level is-mobile" href="#控制循环"><span class="level-left"><span class="level-item">5</span><span class="level-item">控制循环</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Deployments-控制器"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">Deployments 控制器</span></span></a></li><li><a class="level is-mobile" href="#ReplicaSets-控制器"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">ReplicaSets 控制器</span></span></a></li><li><a class="level is-mobile" href="#Informers"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">Informers</span></span></a></li><li><a class="level is-mobile" href="#调度器"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">调度器</span></span></a></li></ul></li><li><a class="level is-mobile" href="#kubelet"><span class="level-left"><span class="level-item">6</span><span class="level-item">kubelet</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Pod-同步"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">Pod 同步</span></span></a></li><li><a class="level is-mobile" href="#CRI-和暂停容器"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">CRI 和暂停容器</span></span></a></li><li><a class="level is-mobile" href="#CNI-和-Pod-通信"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">CNI 和 Pod 通信</span></span></a></li><li><a class="level is-mobile" href="#跨节点通信"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">跨节点通信</span></span></a></li><li><a class="level is-mobile" href="#容器启动"><span class="level-left"><span class="level-item">6.5</span><span class="level-item">容器启动</span></span></a></li></ul></li><li><a class="level is-mobile" href="#回顾"><span class="level-left"><span class="level-item">7</span><span class="level-item">回顾</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">学习</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%9A%8F%E7%AC%94/"><span class="level-start"><span class="level-item">随笔</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-15T14:38:41.000Z">2025-02-15</time></p><p class="title"><a href="/2025/02/15/LearnReactAgain/">再次认识 React</a></p><p class="categories"><a href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-12-31T00:46:33.000Z">2024-12-31</time></p><p class="title"><a href="/2024/12/31/ForMy2024/">2024 年终总结</a></p><p class="categories"><a href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-12-25T14:20:38.000Z">2024-12-25</time></p><p class="title"><a href="/2024/12/25/UseMacLikeWindows/">像使用 Windows 一样使用 MacOS</a></p><p class="categories"><a href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-12-04T15:20:06.000Z">2024-12-04</time></p><p class="title"><a href="/2024/12/04/WriteCodeWithCursor/">用 Cursor 快速搭建软件原型</a></p><p class="categories"><a href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-10-27T12:24:12.000Z">2024-10-27</time></p><p class="title"><a href="/2024/10/27/GoodByeBeijing/">再见北京 👋</a></p><p class="categories"><a href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/AI/"><span class="tag">AI</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AccessControl/"><span class="tag">AccessControl</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI-CD/"><span class="tag">CI/CD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CloudNative/"><span class="tag">CloudNative</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Coding/"><span class="tag">Coding</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Deployment/"><span class="tag">Deployment</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docs/"><span class="tag">Docs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ECMAScript/"><span class="tag">ECMAScript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GC/"><span class="tag">GC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Github/"><span class="tag">Github</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go/"><span class="tag">Go</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GraphQL/"><span class="tag">GraphQL</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Lint/"><span class="tag">Lint</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MacOS/"><span class="tag">MacOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NPM/"><span class="tag">NPM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Network/"><span class="tag">Network</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RAG/"><span class="tag">RAG</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React/"><span class="tag">React</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Reading/"><span class="tag">Reading</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Security/"><span class="tag">Security</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tools/"><span class="tag">Tools</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TypeScript/"><span class="tag">TypeScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VSCode/"><span class="tag">VSCode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Vue/"><span class="tag">Vue</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Web-Server/"><span class="tag">Web Server</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows/"><span class="tag">Windows</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%91%E6%B8%B8%E6%88%8F/"><span class="tag">云游戏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%8D%E7%AB%AF/"><span class="tag">前端</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"><span class="tag">小程序</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%BB%E7%BB%93/"><span class="tag">总结</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%91%84%E5%BD%B1/"><span class="tag">摄影</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B8%B8%E6%88%8F/"><span class="tag">游戏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B8%B8%E8%AE%B0/"><span class="tag">游记</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"><span class="tag">胡思乱想</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"><span class="tag">读后感</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Somewhere - PowerfooI&#039;s Zone</a><p class="is-size-7"><span>&copy; 2025 PowerfooI</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Visit GitHub Profile" href="https://github.com/powerfooi/"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>