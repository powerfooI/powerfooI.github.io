<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>好久不见，前端再见</title>
      <link href="2022/05/09/GoodbyeFrontEnd/"/>
      <url>2022/05/09/GoodbyeFrontEnd/</url>
      
        <content type="html"><![CDATA[<p>断断续续写前端项目也有好几年了，从大二接触 Javascript 和 Vue 时的兴奋，到接触小程序和 React 时的“渐入佳境”，再到这段时间的感到无比疲惫，我希望我在前端开发上大规模投入的阶段先暂告一段落了。为什么有这样的疲惫感呢？原因总结起来有以下几点：</p><ol><li>前端开发面临的大多不是技术问题，是产品问题或美学问题，最终目标是让用户满意；</li><li>前端开发过于琐碎，需要处理的细枝末节极多，每个页面元素都有相应的状态需要管理；</li><li>前端难于抽象，对应到用户上则表现为具体业务需求是千变万化的。</li></ol><span id="more"></span><h2 id="写前端的疲惫感"><a href="#写前端的疲惫感" class="headerlink" title="写前端的疲惫感"></a>写前端的疲惫感</h2><p>从技术上来说绝大部分前端应用并不需要考虑代码的优化，而是需要“取悦”用户，这应该是最让我无法忍受的了。因为前端应用面向最终用户，看得见摸得着的应用就会让用户有点评的冲动，而除了基本的程序正确性问题外，诸如“我觉得这里不好看”这样主观且不确定的问题占绝大多数。相较于后端而言，前端应用面向的用户不知道也不关注技术问题，他们对应用提出的问题是不收敛的，且提出问题的同时往往伴随着需求变动。</p><p>而回归到技术上，与其说是我选择了前端框架，不如说是我选择的 UI 组件库替我焊死了框架的门，真正做到 <code>面向 UI 组件库的编程</code> 。目前我们普遍使用的 React + AntDesign 的组合已经成了标准配置，图快写出来的所有的应用外观上和代码上都几乎一样，让我有些视觉疲劳和精神疲劳。</p><p>疲劳状态下需要转移注意力，换换脑子接触新的东西，近期发现了重编译时的轻量前端框架 <a href="https://svelte.dev"><code>Svelte</code></a> 的确让我耳目一新，简单清晰的 API 和朴素的文件布局和它的名字完全吻合，让人觉得 Web 开发又回到了似曾相识的从前的模样，熟悉又清新。但很快美梦就破碎了，当我准备用它重构自己用 React 写的网站时发现消息提示，模态对话框，表单验证等前端开发常见场景问题都没有太好的解决方案。回顾了 Bootstrap，有刀耕火种的味道。可能我属于“急于求成”“基础不扎实”的前端开发者吧，如果有时间和机会好好打磨 UI 组件，调整样式和布局应该能够达到非常好的效果。但 React + AntDesign 就跟吃快餐一样，风味欠佳但是效率很高。</p><p><strong>现在我觉得是实际业务选择了我，前端框架选择了我</strong>。</p><h2 id="当我谈写代码时我谈些什么"><a href="#当我谈写代码时我谈些什么" class="headerlink" title="当我谈写代码时我谈些什么"></a>当我谈写代码时我谈些什么</h2><p>当我提到写代码，脑海里想的是借助程序充分利用计算机的能力，达到我需要完成的计算任务。程序的状态应被准确地刻画，程序的输入输出应被良定义，程序的边界应当较为清晰，程序的正确性可以被验证…而这些与前端开发不能说是毫不相干，也可以说是相去甚远。</p><p>人是会犯错的，用动态语言写代码错误频出，而因为我能力有限，用动态语言写前端代码只会使得错误跟我玩捉迷藏，更何况还得面对各路用户提出的需求和美学问题。我希望我写代码时能够保持足够长的、不被打扰的专注时间，让我可以设计并实现程序，而不是时不时考虑表格 A 缺了字段，按钮 B 应当换成主色等琐碎的问题。下面这张图就是上个月某两周的代码提交次数统计情况，在前端应用的开发中需要处理的事情和写的代码都是极其琐碎且没有局部性的。我不认为这么多次的提交都具备平均的单位价值，但可以体现写的代码是东一榔头西一棒子的。</p><img src="/2022/05/09/GoodbyeFrontEnd/dashboard.png" class="" title="某两周的提交次数统计"><p>当然这些都是我的主观感受，无知者无畏，我只是窥到了前端的冰山一角便自觉全面接触后难以接受想着要逃。我很喜欢 Vue React Svelte 这些项目，也希望有朝一日可以自己可以搭建出这样的框架。用框架写前端应用和实现前端框架是完全不一样的概念，前者针对业务，后者面向系统。我计划在之后的时间里深入到软件系统的设计与实现当中，在可接触的项目范围内开始转向后端于我而言是理想的开端。编写相似的业务代码给我带来的技术提升和成就感与日俱减，尤其是我饶有兴致地用颇为巧妙的方法实现的前端应用被用户主观地认为“不好看”或者“不易用”时，很难避免这些对应用本身的批评转嫁到自己身上，实现得不好可能也有，但是这种因素占比是多少呢？</p><blockquote><p>希望一人独处的念头，始终不变地存于心中。所以一天跑一小时，来确保只属于自己的沉默的时间，对我的精神健康来说，成了具有重要意义的功课。至少在跑步时不需要和任何人交流，不必听任何人说话，只需眺望周围的风光，凝视自己即可。这是任何东西都无法替代的宝贵时刻。</p><p>—— 村上春树</p></blockquote><h2 id="写前端的收获"><a href="#写前端的收获" class="headerlink" title="写前端的收获"></a>写前端的收获</h2><p>抱怨了这么多，不是想表达我对前端开发的深恶痛绝，而是“爱之深责之切”(?)。我仍会关注前端领域的发展，甚至还会在自己的网站里尝试新的前端技术，但对于我而言它已经成为“庐山烟雨浙江潮”。它给我带来的收获有几方面，最主要的就是产品思维、审美提升和巩固 Web 基础。</p><p>首先产品思维就是站在用户的角度思考产品的问题，以用户为中心。而用户就是更注重产品的美观性、易用性而不注重实现方法和程序效率，软件产品本身不仅是代码和程序，美术素材、按钮图标、菜单样式等等都是其中重要的部分。因为前端应用直接面向最终用户，所以前端开发其实也是在做产品，当然如果纯粹机械地将原型图还原成前端应用则另当别论。</p><p>审美提升则是主观和隐性的。因为我所做的前端应用大多是 ToB 模式，不同于电商类应用，没有引流新用户的需要，所以几乎所有界面都是简约风格的，久而久之我对应用的设计风格就有了简约的偏好。最直接的影响是发现“丑”的应用数量增多，间接影响是当我听完一段应用的功能描述后可以在脑海里描摹出大致的页面设计方案，何处需要做一些留白，元素如何合理布局，如何让页面观感舒适等。审美的提升不仅体现在页面实现上，也体现在代码风格上，能写美观的地方我会尽量优化，目录结构、文件命名、甚至是注释的写法也要统一(<code>/** */</code>、<code>//</code>、<code>/* */</code>)。</p><p>巩固 Web 基础的巩固则直截了当，<code>DOM API</code>、<code>Typescript</code>、<code>浏览器兼容性</code> 甚至是 <code>jQuery</code> 等杂七杂八的东西都有接触，也开始封装发布自己的 UI 组件和实用工具 NPM 包，成为 NPM 包玩家。Svelte 的出现也把基于 Virtual DOM 前端框架的势头稍微拉回了经典的开发风格，让我体验了一把文艺复兴。</p><h2 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h2><p>前段时间业余时间学习了 Rust，希望能够借助 Rust 的学习路径复习操作系统、计算机组成原理和数据库原理等基础知识。阅读 Rust 的中英文文档及博客后深感深切感受到了大一从 C/C++ 上没有感受到的魅力，Rust 编译器像严格的编程教练，用极为严格的语法要求我们写出合规合法的代码，这样一来通过编译器检查的代码就已经达到较高的标准；Rust 中 <code>所有权</code> 和 <code>生命周期</code> 的机制也十分巧妙，能够最大限度地避免内存泄漏和野指针的问题；作为 Mozilla 推出的现代编程语言，内建的类库和原生的 API 都比较趁手。</p><p>3月末 Golang 发布了 1.18 正式版，终于推出了泛型编程的特性，到现在还没有真正上手写呢，是时候体验一番了。</p><p>后续计划主要用 Golang 或 Rust 这两种编程语言，配合 GraphQL 搭建可拓展的后端服务；自己整体的工程方向朝着微服务、云原生的方向靠拢，尽量扎进计算机系统的核心和底层。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端开发 </tag>
            
            <tag> 胡思乱想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打包发布 React 组件库</title>
      <link href="2022/03/12/PublishNpmPackageOfReactComponents/"/>
      <url>2022/03/12/PublishNpmPackageOfReactComponents/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>「代码写了不测等于白写」我总是跟身边的朋友这样调侃。然而我们写前端项目时很难在代码层面进行测试，大部分函数都是基于事件响应，接收用户输入的参数，并对页面组件或数据产生一定副作用，Mock 起来很麻烦。所以前端项目的测试往往都是端到端测试，即模拟用户在页面上进行操作，测试路径越离奇越好，因为无法提前预知用户会如何使用，所以最好在测试时可劲儿造。</p><p>曾经还会想着用 Cypress 等自动化工具进行端到端测试，例如用代码定义【打开某页面–&gt;拖拽滑动条至页面下方–&gt;点击输入框使之获取焦点–&gt;输入“Hello world”–&gt;按下回车–&gt;等待页面响应–&gt;观察响应是否符合预期】这个过程，但只要遇到元素稍多的页面，编写测试用例的过程就会变得机械呆板。</p><p><strong>如果组件足够小，内容够聚焦，那么测一下也不是不可以。</strong>因为想在不同的项目中复用同一套富文本编辑组件(体积比较大，且包含机器构建的JS)，我把它单独提出来作为 NPM 包发布以便各个项目安装使用。这当中编码和测试都遇到了一些问题。</p><span id="more"></span><h2 id="打包经过"><a href="#打包经过" class="headerlink" title="打包经过"></a>打包经过</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>既然要在不同项目之间共用，那该组件肯定至少已经应用到一个项目中。所以最终目标就是把项目中原先引入的组件完全替换成为 NPM 包版本的组件后，所有富文本编辑预览功能都照常。</p><h3 id="原先组件结构"><a href="#原先组件结构" class="headerlink" title="原先组件结构"></a>原先组件结构</h3><figure class="highlight typescript"><figcaption><span>CKEditorFormFields.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./some-styles.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CKEditor &#125; <span class="keyword">from</span> <span class="string">&quot;@ckeditor/ckeditor5-react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> CustomBuildEditor <span class="keyword">from</span> <span class="string">&#x27;@ckeditor/ckeditor5-custom-build&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CKEditorInput: React.FC&lt;ControllableFormFieldProps&gt; = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">   * ...</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CKEditorRenderer: React.FC&lt;ControllableFormFieldProps&gt; = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">   * ...</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原先的组件定义基本上如上面片段所示，其中 <code>CustomBuildEditor</code> 利用了 <a href="https://ckeditor.com/ckeditor-5/">CKEditor5</a> 的<a href="https://ckeditor.com/ckeditor-5/online-builder/">自定义构建</a>，算是按项目需要选取必要功能构建出来的编辑器母版，它本身的使用方法很 HTML，不太适合直接用在 React 项目里，需要用 <code>@ckeditor/ckeditor5-react</code> 进行包装。</p><p>而这个 <code>CustomBuildEditor</code> 是自定义构建工具编译好之后打包好后（后续用 <code>ckeditor-dist</code> 称呼）下载到本地的，如果不用 NPM 包的话需要在几个项目间复制粘贴。或许因为我们项目用的是 TS，无法直接从本地目录下直接引入，所以我们用 package.json 依赖的文件链接定义了一个叫做 <code>@ckeditor/ckeditor5-custom-build</code> 的假包供代码引入使用，但这个方法<strong>时而奏效时而报错</strong>，或是<strong>在张三电脑上能用而李四电脑上用不了</strong>。可以确保解决问题的方法是将该 <code>ckeditor-dist</code> 目录复制到 <code>node_modules</code> 当中，但是这样过于原始。于是决定有时间研究一下 NPM 打包。</p><h3 id="Hello-richtext"><a href="#Hello-richtext" class="headerlink" title="Hello-richtext"></a>Hello-richtext</h3><p>目标富文本组件包名叫做 <code>Hello-richtext</code>，它需要依赖我们自定义构建的富文本编辑器母版，所以首先将 <code>ckeditor-dist</code> 单独作为一个 NPM 包发布到我们团队的私有制品库中，就起名为 <code>ckeditor-custom-build</code>。</p><p>把 <code>ckeditor-custom-build</code> 加入到依赖中，原先组件中包含的所有文件都复制到 <code>Hello-richtext</code> 的代码目录中。利用 <code>tsc</code> 以 <code>&quot;target&quot;: &quot;ESNest&quot;</code> 的配置将 <code>.tsx</code> 格式的文件编译为 <code>.js</code> 和 <code>.d.ts</code> 文件，或许这也是最终在前端项目中被应用时的引入形式。</p><p>随后利用 <a href="https://jestjs.io/">Jest</a> 和 <a href="https://testing-library.com/docs/react-testing-library/intro/">React Testing Library</a> 写下了如下的测试用例。</p><figure class="highlight javascript"><figcaption><span>render.test.jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">&#x27;@testing-library/react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Form &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; CKEditorInput, CKEditorRenderer &#125; <span class="keyword">from</span> <span class="string">&#x27;../dist/CKEditorFormFields&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@testing-library/jest-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">&#x27;matchMedia&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">value</span>: jest.fn().mockImplementation(<span class="function">(<span class="params">query</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">matches</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">media</span>: query,</span><br><span class="line">    <span class="attr">onchange</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">addListener</span>: jest.fn(), <span class="comment">// Deprecated</span></span><br><span class="line">    <span class="attr">removeListener</span>: jest.fn(), <span class="comment">// Deprecated</span></span><br><span class="line">    <span class="attr">addEventListener</span>: jest.fn(),</span><br><span class="line">    <span class="attr">removeEventListener</span>: jest.fn(),</span><br><span class="line">    <span class="attr">dispatchEvent</span>: jest.fn(),</span><br><span class="line">  &#125;)),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TestForm = <span class="function">() =&gt;</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Form</span> <span class="attr">initialValues</span>=<span class="string">&#123;&#123;</span> <span class="attr">renderer:</span> &#x27;&lt;<span class="attr">p</span>&gt;</span>Hello world!<span class="tag">&lt;/&gt;</span>&#x27; &#125;&#125;&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Form.Item</span> <span class="attr">label</span>=<span class="string">&quot;Mock Input&quot;</span> <span class="attr">name</span>=<span class="string">&quot;input&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">CKEditorInput</span> <span class="attr">data-testid</span>=<span class="string">&quot;input-field&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Form.Item</span> <span class="attr">label</span>=<span class="string">&quot;Mock Renderer&quot;</span> <span class="attr">name</span>=<span class="string">&quot;renderer&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">CKEditorRenderer</span> <span class="attr">data-testid</span>=<span class="string">&quot;renderer-field&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;test rendering&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  render(<span class="xml"><span class="tag">&lt;<span class="name">TestForm</span> /&gt;</span></span>).debug()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="启动测试时遇到的问题"><a href="#启动测试时遇到的问题" class="headerlink" title="启动测试时遇到的问题"></a>启动测试时遇到的问题</h3><p>只要富文本编辑器能够正常渲染就成功了，所以首次运行测试我比较保守，只定义了简单的表单并把自定义的两个组件作为表单项置入其中，并尝试将渲染结果用 <code>render().debug()</code> 的方式打印出来看看是否正确渲染。</p><p>但是启动 Jest 之后遇到了一系列问题，下面列举了我遇到的问题以及相关的解决方案。</p><ol><li>无法解析 <code>.jsx</code> 格式文件，通过安装 <code>@babel/preset-react</code> 插件并创建 <code>babel.config.js</code> 应用该插件解决；</li><li>提示 ‘react’ 这个包没有导出 default，通过安装 <code>@types/react</code> 和 <code>@babel/preset-env</code> 解决，其中 babel 插件同样需要应用到配置文件中；</li><li>提示没有 <code>window.matchMedia</code> 方法，直接通过 <code>Object.defineProperty</code> 给 <code>window</code> 打上补丁（<a href="https://jestjs.io/docs/26.x/manual-mocks#mocking-methods-which-are-not-implemented-in-jsdom">官方建议</a>）；</li><li>无法解析 <code>CKEditorFormField</code> 中引入的 <code>.css</code> 文件，通过安装 <code>identity-obj-proxy</code> 依赖，并在 Jest 配置文件的 <code>moduleNameMapper</code> 属性中加入 <code>&quot;\\.(css|less)$&quot;: &quot;identity-obj-proxy&quot;</code> 解决；</li></ol><p>稍微麻烦些的就是上面4点，当然还有一些其他的必要的依赖也是需要安装的，这里给出局部 <code>package.json</code>，Jest 和 Babel 的配置分别如下：</p><figure class="highlight json"><figcaption><span>package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Hello-richtext&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.0.1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;jest&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;tsc&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;richtext&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;react&quot;</span>: <span class="string">&quot;^17.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@ckeditor/ckeditor5-react&quot;</span>: <span class="string">&quot;^3.0.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@ckeditor/ckeditor5-build-classic&quot;</span>: <span class="string">&quot;^31.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ckeditor5-custom-build&quot;</span>: <span class="string">&quot;0.0.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;antd&quot;</span>: <span class="string">&quot;^4.16.13&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;@babel/core&quot;</span>: <span class="string">&quot;^7.17.5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@babel/preset-env&quot;</span>: <span class="string">&quot;^7.16.4&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@babel/preset-react&quot;</span>: <span class="string">&quot;^7.16.7&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@testing-library/dom&quot;</span>: <span class="string">&quot;^8.11.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@testing-library/jest-dom&quot;</span>: <span class="string">&quot;^5.16.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@testing-library/react&quot;</span>: <span class="string">&quot;^12.1.4&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@types/jest&quot;</span>: <span class="string">&quot;^27.4.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@types/react&quot;</span>: <span class="string">&quot;^17.0.39&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-jest&quot;</span>: <span class="string">&quot;^27.5.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;identity-obj-proxy&quot;</span>: <span class="string">&quot;^3.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;jest&quot;</span>: <span class="string">&quot;^27.5.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react-dom&quot;</span>: <span class="string">&quot;^17.0.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react-test-renderer&quot;</span>: <span class="string">&quot;^17.0.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ts-node&quot;</span>: <span class="string">&quot;^10.7.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;typescript&quot;</span>: <span class="string">&quot;^4.1.2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><figcaption><span>jest.config.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">coverageProvider</span>: <span class="string">&quot;v8&quot;</span>,</span><br><span class="line">  <span class="attr">moduleNameMapper</span>: &#123;</span><br><span class="line">    <span class="string">&quot;\\.(css|less)$&quot;</span>: <span class="string">&quot;identity-obj-proxy&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">testEnvironment</span>: <span class="string">&quot;jsdom&quot;</span>,</span><br><span class="line">  <span class="comment">// 其他均为默认</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>babel.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [</span><br><span class="line">    [<span class="string">&#x27;@babel/preset-env&#x27;</span>, &#123;<span class="attr">targets</span>: &#123;<span class="attr">node</span>: <span class="string">&#x27;current&#x27;</span>&#125;&#125;],</span><br><span class="line">    [<span class="string">&#x27;@babel/preset-react&#x27;</span>, &#123; <span class="attr">targets</span>: &#123; <span class="attr">node</span>: <span class="string">&#x27;current&#x27;</span> &#125; &#125;],</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试补全"><a href="#测试补全" class="headerlink" title="测试补全"></a>测试补全</h3><p>解决<a href="#启动测试时遇到的问题">上一节</a>遇到的问题之后，测试脚本可以顺利运行了，需要稍微补全一下测试用例。因为 <code>CKEditorInput</code> 从 <code>ckeditor-custom-build</code> 中加载 <code>CKEditor</code> 时采用了异步加载，所以用 rlr 的 <code>render()</code> 第一时间拿到的页面源码内显示该方法仍在加载中。通过 <code>screen.logTestingPlaygroundURL()</code> 方法可以获取 <strong>Debug Playground</strong> 的访问链接，用浏览器打开可以看到下图的内容，清楚明了。利用它还能获取如何查询页面元素的提示。</p><img src="/2022/03/12/PublishNpmPackageOfReactComponents/debug-playground.png" class=""><p>我期望两个组件都正常渲染，如果 <code>CKEditorInput</code> 组件需要异步加载，那么设置等待即可。测试用例补充为下面的样子：</p><figure class="highlight javascript"><figcaption><span>render.test.jsx (2)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防止加载时间稍长引发 jest timeout 的问题</span></span><br><span class="line">jest.setTimeout(<span class="number">60000</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;test rendering&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  render(<span class="xml"><span class="tag">&lt;<span class="name">TestForm</span> /&gt;</span></span>).debug()</span><br><span class="line">  screen.logTestingPlaygroundURL()</span><br><span class="line">  <span class="keyword">await</span> waitFor(<span class="function">() =&gt;</span> screen.getByText(<span class="regexp">/hello world!/i</span>), &#123;</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">30000</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">await</span> waitFor(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 根据 debug() 的返回结果发现: </span></span><br><span class="line">    <span class="comment">// 可以通过获取 &quot;段落&quot; 这个工具栏提示字样来判断是否已经渲染出富文本编辑器</span></span><br><span class="line">    screen.debug()</span><br><span class="line">    screen.getByText(<span class="regexp">/段落/i</span>)</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">30000</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="打包、发布完成"><a href="#打包、发布完成" class="headerlink" title="打包、发布完成"></a>打包、发布完成</h2><p>测试完成后，利用 <code>npm publish</code> 命令将 <code>Hello-richtext</code> 发布到团队的私有制品库中，完成打包流程。在两个实际项目中安装 <a href="mailto:`Hello-richtext@0.0.1">`Hello-richtext@0.0.1</a>` 后，组件切实可用。</p><p>这次打包发布 React “组件库”的经历给了我几点体会，</p><ol><li>首先是学习和实践了 React 组件的测试流程，加深了自己对于前端项目测试的理解；</li><li>其次让自己构建 NPM 包的流程更规范，之前发布的几个 NPM 包因为图方便求速度都没有写测试，<strong>没测等于没写</strong>；</li><li>在目前两个可能未来更多的项目开发中事实上地提升了代码复用度和开发体验，原先富文本编辑在各个项目间维护…挺麻烦的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端开发 </tag>
            
            <tag> React </tag>
            
            <tag> NPM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年我希望...</title>
      <link href="2022/01/15/SomethingFor2022/"/>
      <url>2022/01/15/SomethingFor2022/</url>
      
        <content type="html"><![CDATA[<p>新年的元月已然过半，但直到现在我才能说我完成了上一年的工作。我一直在追求“忙的时候闲一点，闲的时候忙一点”的从容，这一年大部分时间是保持着这个状态的，让我非常欣慰。但是真正从学生身份蜕变成“开发者”“软件工程师”（或者“社畜”？其实即使是自嘲我也不太喜欢这个词），还是有着截然不同的感受和体会的。对于2022也有着无数的憧憬。</p><span id="more"></span><h2 id="2021上半年：课程时代尾声"><a href="#2021上半年：课程时代尾声" class="headerlink" title="2021上半年：课程时代尾声"></a>2021上半年：课程时代尾声</h2><p>2021年上半年我研一，为了一年上完所有的课我这个学期仍然是课程满满的，与此同时课题组的项目也开始安排给我。在课程任务和项目进度的双重压力下，我会想着“尽快结束这样的生活节奏，争取早日回归生活的正轨”，但这个状态持续一小段时间之后我逐渐与之和解了，与其认定只用考虑学习的生活是正轨，不如接受多线程地生活才是当下社会当中每个人都需要具备的基础能力这个事实。</p><p>那么话又说回来，我认为我的多线程能力还是不错的，因为在主业之外我一直以来都或多或少地参与到学院、学校的学生工作中。在相对一板一眼的计算机知识、代码编写和需要社交活动的谈话开会、学生事务之间频繁切换也没有被我归入困扰我的事情当中。这样长期以来的“训练”让我对社交行为本身脱了敏，甚至有时还会主动发起社交活动；也让我对“同时处理很多事情”这个现象习以为常。</p><p>随着课程结课，我有了更多的时间可以投入到课题组项目里。我在课题组的工作投入在一定范围内是正反馈的：投入时间增加产出增加 –&gt; 工作产出增加 –&gt; 安排给我的工作增多 –&gt; 投入时间增加。实验室有位同学开玩笑地说我是“劳模”，每天都早早来到实验室但很晚才回寝。这个状态从暑假一直持续到现在，我自己是乐在其中了。我在课题组里承担的工作让我拥有了难以替代性，在这个过程当中我收获的知识、激励还有认可都成了我齿轮转动的润滑剂——即使有的时候这种难以替代性也带来不小的压力。这个反馈过程却有点像我高中的学习历程：<strong>认真学习带来的收获主、客观上都有助于我继续认真学习</strong>，学习换成工作也受用。我觉得这样的状态是比较难得的，我享受这一状态。Sybil说我很幸运，学的专业做的工作都是自己喜欢的，所以能够保持自驱，我觉得确实是这样。</p><h2 id="2021下半年：偶然与想象"><a href="#2021下半年：偶然与想象" class="headerlink" title="2021下半年：偶然与想象"></a>2021下半年：偶然与想象</h2><p>喜欢记录为什么不拍照呢？我在5月入手了一台富士相机，并立马带上它去了青岛。不深挖构图角度也不用Photoshop，光是拨动相机滚轮，摁下相机快门在任何一处拍下软糯或嶙峋的云彩，波光粼粼的海面还是叶影斑驳的片片树荫、铺满和煦光影的高矮楼房，都让我感受到极为愉悦。虽然没有太多机会到外面旅游，但在学校里面简单记录四时风景也是很好的体验。</p><img src="/2022/01/15/SomethingFor2022/cloud-on-mountain.jpg" class=""><p>8月开始捡起闲置已久的吉他，在琴包里放了近两年，音孔部分的琴弦竟然有些锈迹斑斑。完全从零开始学，在不懂乐理的情况下，我照着吉他入门教材学习了几个基本的和弦。弹唱的曲子从教材里比较简单的《送别》到自己感兴趣的《杀死那个石家庄人》《平凡之路》等等，也逐渐意识到自己水平有限需要加强练习。下面这张图虽然没有标识我的所有练琴记录，但可以大致体现我的练琴状态：有段时间练习比较密集，有段时间又比较松懈，指尖和食指侧的茧长了又消。以前听人说吉他很简单，可能跟“Python很简单”道理一样吧，我到目前为止我学到稍微深入一点的技巧也只有横按和泛音而已。</p><img src="/2022/01/15/SomethingFor2022/guitar-practice.jpg" class=""><p>11月我跟Sybil恋爱了。记得那天我怀着难以压抑的心情写下了一封两页纸的信，信的内容我已经不能全部回忆出来了，但那份心情却恍如昨日。从系馆回到宿舍区时已经是凌晨，那天晚上的风不同寻常的湿润，月亮在薄雾后面显得朦胧，在分别之际我扭捏地叫住她说“我想跟你说件事”，说完之后把信给她，我们在一起了。<br>恋爱改变了我的生活轨迹，我依旧每天努力工作，但生活的一切都被她点亮了，我很感谢她。我们从两个地方相向奔赴，“在离人群不远的地方携手同行”。</p><p>这半年没有课程没有作业的时间里，原本以为会枯燥乏味的生活却过得很丰富，果然<strong>生活是需要偶然与想象的</strong>。</p><h2 id="2022的小目标"><a href="#2022的小目标" class="headerlink" title="2022的小目标"></a>2022的小目标</h2><p>2022年还剩下350天，剩余的95%时间里我希望自己可以有更多从容不迫、处变不惊的心态和能力，有“彼可取而代也”、不惧跃入人海的傲骨和锐气；对待喜欢的人要满怀热情，对待讨厌的人要爱憎分明。之前总说“想的多了，做的就少”，务虚的话简单说说就好，人不能总活在空中楼阁。给我的2022定几个务实些的小目标（排序不分先后，包括但不限于）：</p><ul><li>每个季度至少读两本<strong>非技术类</strong>书目；</li><li>每个月至少更新一次博客，类型不限；</li><li>每两周至少看一部非<strong>所谓商业片</strong>的电影；</li><li>每周至少锻炼一次，有氧/无氧、室内/室外均可；</li><li>协助所带班级内每位同学捋清未来职业发展规划；</li><li>学习乐理，能够转换吉他谱和五线谱；</li><li>开源至少<code>3个代码仓库</code>，做些有意思的开发。</li></ul><p>以上。2022来年再会。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 胡思乱想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 基础</title>
      <link href="2021/08/15/NginxBasics-1/"/>
      <url>2021/08/15/NginxBasics-1/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Nginx 读作 <code>engine x</code>，是一个高性能的 HTTP 和反向代理服务器，还能用作邮件代理服务器或是通用的 TCP/UDP 代理服务器。有过后端程序部署经历的同学应该会有所了解，用 Nginx 能够很方便地完成反向代理、服务静态文件、实现负载均衡、接入HTTPS协议等任务。</p><p>根据官方文档里面写到的，除了提供静态文件服务、反向代理和负载均衡等功能之外，还提供以下包括单不限于若干个方面的支持：</p><ol><li>FastCGI, uwsgi 之类服务器和反向代理服务器的缓存支持；</li><li>以域名/IP为基础的虚拟服务器、Keep-alive 和流水线链接的支持；</li><li>访问日志、错误日志的输出和格式化，带缓存的日志写机制；</li><li>3xx-5xx 错误码重定向，根据正则表达式重写URI (Rewrite)；</li><li>基于客户端地址的访问控制和函数调用；</li><li>HTTP referer 的验证、支持除了 GET 外的几种 HTTP 方法： PUT/DELETE/COPY/MOVE/MKCOL；</li><li>FLV/MP4 的流播放、响应限流、限制单点的并发连接数和请求数；</li><li>等等…（上面只列了我读得懂的）</li></ol><p>Nginx 的功能实在太多了，在这里全部列出来不太可能。一直以来我对 Nginx 都停留在“配置是什么，work 就行”的态度。因为这周程序部署时遇到的一点问题，上网搜了好多帖子、博客寻求解决方法那种捉襟见肘、有病乱投医的样子让我觉得很狼狈。借此为契机，决定周末看一下 Nginx 的官方文档。nginx 旧版的官网文档组织混乱，建议移步 <a href="https://docs.nginx.com/">Nginx Plus (Nginx 的商业版)官网</a>。Nginx 和 Nginx Plus 的对比<a href="https://www.nginx.com/products/nginx/compare-models">放在这里</a>。</p><span id="more"></span><h2 id="基本功能概况"><a href="#基本功能概况" class="headerlink" title="基本功能概况"></a>基本功能概况</h2><h3 id="Name-IP-based-Virtual-servers"><a href="#Name-IP-based-Virtual-servers" class="headerlink" title="Name/IP-based Virtual servers"></a>Name/IP-based Virtual servers</h3><p>Nginx 接收到请求之后会首先决定让哪个 server 来接受这个请求。在 nginx 的配置文件中使用 <code>server</code> 这个指令可以定义“服务器”区域，当然最后到底是谁处理这个请求也是看 server 是如何定义的。下面是示例代码块：</p><figure class="highlight bash"><figcaption><span>demo.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen      80;</span><br><span class="line">    server_name example.org www.example.org;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen      80;</span><br><span class="line">    server_name example.net www.example.net;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen      80;</span><br><span class="line">    server_name example.com www.example.com;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置文件定义了 3 个服务器，都监听了 *:80 端口。Nginx 接收到请求之后会转发给 <code>server_name</code> 字段与请求头中的 <code>Host</code> 字段相同的 server 进行处理。如果没有完全对应的 Server 那么请求会被转发到默认服务器进行处理。<code>default_server</code> 是 <code>listen</code> 指令的可选参数，如果在端口号后加上 <code>default_server</code> 表示这个服务器是默认服务器。<strong>如果没有任何 server 有 <code>default_server</code>，那配置文件中定义的第一个 server 就是默认的服务器</strong>。</p><p>对 <code>listen</code> 中的 IP 地址进行配置也是可行的。下面再看一个配置文件：</p><figure class="highlight bash"><figcaption><span>demo2.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen      192.168.1.1:80;</span><br><span class="line">    server_name example.org www.example.org;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen      192.168.1.1:80;</span><br><span class="line">    server_name example.net www.example.net;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen      192.168.1.2:80;</span><br><span class="line">    server_name example.com www.example.com;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置文件下，Nginx 会先判断请求的 IP，再判断 <code>server_name</code> 字段。</p><h3 id="Locations"><a href="#Locations" class="headerlink" title="Locations"></a>Locations</h3><h4 id="路径配置规则"><a href="#路径配置规则" class="headerlink" title="路径配置规则"></a>路径配置规则</h4><p>在 <code>server</code> 区域之中，可以定义若干个 <code>location</code> 区域。<code>location</code> 指令可以根据请求的 URI 将请求分发到不同的代理或者不同的静态文件目录中，后面提到的所有 <code>location</code> 配置都在 <code>server</code> 区域之中。</p><p><code>location prefix</code> 匹配符合 <code>prefix</code> 前缀的 URI，如果一个请求的 URI 匹配了很多 location 的 prefix 那么请求会被分发到 prefix 定义最长的 location 块中。另外，<code>location</code> 指令还可以有标识符配置：</p><ol><li><code>location = path</code> 表示 URI 需要准确的等于 path 才会落到这个 location 区域进行处理；</li><li><code>location ~ regex</code> 表示 URI 匹配相应的正则表达式。如果是 <code>~*</code> 的话，是忽略大小写的；</li><li><code>location ^~ prefix</code> 表示这个 prefix 匹配的话，不考虑相应的正则表达式；</li></ol><h4 id="匹配优先级"><a href="#匹配优先级" class="headerlink" title="匹配优先级"></a>匹配优先级</h4><p>要找到最好的 <code>location</code> 块来匹配一个 URI，Nginx 会先匹配所有的 prefix，然后再匹配所有的正则表达式。但是 Nginx 会给正则表达式更高的优先级，除非有 <code>^~</code> 标识符。准确的匹配流程如下：</p><ol><li>将 URI 与所有的 prefix 进行比对；</li><li>如果 <code>=</code> 标识符的 location 命中了，直接使用该 location 进行处理，匹配过程终止；</li><li>如果有 <code>^~</code> 标识符标识某个 prefix，则后续不用正则表达式检测这个 prefix 命中的 URI；</li><li>保存最长的匹配的 prefix；</li><li>将 URI 与所有的正则表达式进行比对；</li><li>如果 URI 匹配到某个正则表达式，立即停止比对，用这个正则表达式对应的 location 进行处理；</li><li>如果没有正则表达式匹配，用第 4 步保存的最长的 prefix 来处理。</li></ol><p>那么根据这个流程，在配置 <code>/</code> 对应的处理方式时，使用 <code>=</code> 标识符能够提高 Nginx 的响应速度。</p><h4 id="root-index-proxy-pass"><a href="#root-index-proxy-pass" class="headerlink" title="root, index, proxy_pass"></a>root, index, proxy_pass</h4><p><code>root</code>, <code>index</code>, <code>proxy_pass</code> 是几个在 <code>location</code> 区域内常用的指令，这里专门查一下它们的用法。</p><ul><li><code>root path</code> 用文件系统路径来表示，表示在这个 location 中从哪个目录找静态文件来服务；</li><li><code>index file ...</code> 定义首页文件，按照给定顺序注意匹配，最后一个文件名可以是绝对路径；</li><li><code>proxy_pass url</code> 将请求转发到某个代理服务器上。</li></ul><h3 id="变量和改写"><a href="#变量和改写" class="headerlink" title="变量和改写"></a>变量和改写</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在 Nginx 的配置文件中可以使用以 <code>$</code> 开头的变量，和 linux 的 shell 变量相似。Nginx 预定义了很多变量如 <code>$remote_addr</code> 表示客户端的 IP 地址，<code>$uri</code> 表示目前 URI 的值。用户也可以使用 <a href="https://nginx.org/en/docs/http/ngx_http_rewrite_module.html#set">set</a> 和 <a href="https://nginx.org/en/docs/http/ngx_http_map_module.html#map">map</a> 这两个指令在配置文件中自定义变量。</p><p>Nginx 内置的变量列表在这里可以查看：<a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#variables">core HTTP</a></p><h4 id="改写"><a href="#改写" class="headerlink" title="改写"></a>改写</h4><p><strong>return</strong> 使用 <code>return code [url/&quot;string&quot;]</code> 可以给请求返回相应的状态码，或者直接以 <code>30x</code> 的状态码跳转到后续的 <code>url</code>，以 <code>200</code> 的状态码返回一个 string。</p><figure class="highlight bash"><figcaption><span>demoReturn.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location /wrong/url &#123;</span><br><span class="line">    <span class="built_in">return</span> 404;</span><br><span class="line">&#125;</span><br><span class="line">location /permanently/moved/url &#123;</span><br><span class="line">    <span class="built_in">return</span> 301 http://www.example.com/moved/here;</span><br><span class="line">&#125;</span><br><span class="line">location /text/url &#123;</span><br><span class="line">    <span class="built_in">return</span> 200 <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>rewrite</strong> 使用 <code>rewrite regex target cmd</code> 可以将 regex 匹配的路径改写到 target，cmd 这个参数有 <code>break</code> 和 <code>last</code> 这两个最常用的。它们俩的区别有两点：</p><ul><li><code>last</code> 会终止在当前 server 或者 location 区域当中的 rewrite 执行，但是重写到 target 之后落在新的 location 中的 rewrite（如果有的话）还是会继续执行；</li><li><code>break</code> 终止当前背景下的 rewrite 执行之外，新的 location 中的 rewrite 也不会执行。</li></ul><p>rewrite 的例子可以看下面的配置：</p><figure class="highlight bash"><figcaption><span>demoRewrite.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location /users/ &#123;</span><br><span class="line">    rewrite ^/users/(.*)$ /show?user=<span class="variable">$1</span> <span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    rewrite ^(/download/.*)/media/(\w+)\.?.*$ <span class="variable">$1</span>/mp3/<span class="variable">$2</span>.mp3 last;</span><br><span class="line">    rewrite ^(/download/.*)/audio/(\w+)\.?.*$ <span class="variable">$1</span>/mp3/<span class="variable">$2</span>.ra  last;</span><br><span class="line">    <span class="built_in">return</span>  403;</span><br><span class="line">    <span class="comment"># 可以组合使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次走马观花看了一篇最基础的教程有了较多的新认识，服务静态文件、反向代理、压缩和解压缩、内容缓存等等内容在 Nginx Plus 的文档中都有比较系统的讲解，之后有需要或者有时间的时候再看看吧。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 部署 </tag>
            
            <tag> Nginx </tag>
            
            <tag> 文档阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何相对优雅地使用 GraphQL</title>
      <link href="2021/07/23/UseGraphQLElegantly/"/>
      <url>2021/07/23/UseGraphQLElegantly/</url>
      
        <content type="html"><![CDATA[<p>关于 GraphQL，它的<a href="https://graphql.org/">官网</a>(需要科学上网)是这样介绍的：</p><blockquote><p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。</p></blockquote><p>作为 RESTful API 的竞品，GraphQL 从开源之初就备受关注，一是因为它是由 Facebook 开源的项目，二是它<strong>挑战了 RESTful API 的地位</strong>，这是很关键的一点。RESTful API 利用 URI 的具体内容和请求方法来区分请求的资源或者方法，其中的资源 URI 容易与路由路径产生混淆和重复；资源数量达到一定的数目之后，如何给资源 URI 起名或许也是一件困难的事情。而 GraphQL 则鼓励开发者将所有需要请求的信息显式的写在请求体当中，精确到具体的字段，不多也不少。</p><p>我参与的几个项目都是用 GraphQL 作为 API 的基础，我总结出了一个在前端相对优雅地使用 GraphQL 的方法。这篇博客不讨论 GraphQL 的基本概念，主要介绍这个方法。（为省篇幅，这篇博客里面的代码均不做异常处理）</p><span id="more"></span><h2 id="GraphQL-的原始用法"><a href="#GraphQL-的原始用法" class="headerlink" title="GraphQL 的原始用法"></a>GraphQL 的原始用法</h2><p>GraphQL 在前端的表现其实并不新奇：根据定义好的 schema，前端用 post 请求将 query string 和可选的 variables 包装在 body 当中传给后端的某个节点，后端正确响应之后以前端查询的结构将数据返回。</p><h3 id="利用基础方法"><a href="#利用基础方法" class="headerlink" title="利用基础方法"></a>利用基础方法</h3><p>那么根据这个基础我们就能够想到在代码中的用法了，首先在 api.js 中定义一个请求的基础方法：</p><figure class="highlight javascript"><figcaption><span>api/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">graphql</span>(<span class="params">q, vars</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> resp = <span class="keyword">await</span> $axios(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: BASE_URL + <span class="string">&#x27;/api/graphql&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">query</span>: q,</span><br><span class="line">      <span class="attr">variables</span>: vars,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="attr">token</span>: getYourToken(),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> resp.data.data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在所有需要请求的地方使用这个基础方法就可以完成 graphql 的请求，可以直接把请求参数嵌在具体的请求方法里面，也可以使用 variables 的方法（但这样会需要在字符串中多写些变量定义）。</p><figure class="highlight javascript"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; graphql &#125; <span class="keyword">from</span> <span class="string">&#x27;./api&#x27;</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getPerson1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> resp = <span class="keyword">await</span> graphql(</span><br><span class="line">    <span class="string">`query &#123;</span></span><br><span class="line"><span class="string">      person(id: <span class="subst">$&#123;id&#125;</span>) &#123;</span></span><br><span class="line"><span class="string">        id name address </span></span><br><span class="line"><span class="string">        age gender mobile</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;`</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getPerson2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> resp = <span class="keyword">await</span> graphql(</span><br><span class="line">    <span class="string">`query ($id: ID!) &#123;</span></span><br><span class="line"><span class="string">        person(id: $id) &#123;</span></span><br><span class="line"><span class="string">          id name address </span></span><br><span class="line"><span class="string">          age gender mobile</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;`</span>,</span><br><span class="line">    &#123; id &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="体验糟糕的查询字符串"><a href="#体验糟糕的查询字符串" class="headerlink" title="体验糟糕的查询字符串"></a>体验糟糕的查询字符串</h3><p>或许你觉得上面的方法还可以接受，但是如果变量中存在数组、枚举值和布尔值时，直接在 query string 中插入变量的体验就会变的很糟糕。像下面这样，我这辈子都不再想见到这样的写法。</p><figure class="highlight javascript"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">heyGuys</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> guys = [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;carol&#x27;</span>, <span class="string">&#x27;dave&#x27;</span>]</span><br><span class="line">  <span class="keyword">const</span> resp = <span class="keyword">await</span> graphql(<span class="string">`</span></span><br><span class="line"><span class="string">    query &#123;</span></span><br><span class="line"><span class="string">      heyGuys(guys: [<span class="subst">$&#123;guys.map((n) =&gt; <span class="string">&#x27;&quot;&#x27;</span> + n + <span class="string">&#x27;&quot;&#x27;</span>).join(<span class="string">&#x27;,&#x27;</span>)&#125;</span>])</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  `</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统一管理查询字符串"><a href="#统一管理查询字符串" class="headerlink" title="统一管理查询字符串"></a>统一管理查询字符串</h3><p>在逻辑代码中写大量的 query string 不太利于维护，为此可以将所有字符串分类整理好统一管理。例如放在某个 <code>documents.js</code> 文件内，其他地方需要请求的时候直接从该文件导入即可。这样可以在真正的业务逻辑中避免大量的字符串。</p><figure class="highlight javascript"><figcaption><span>api/documents.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getPersonDoc = <span class="string">`</span></span><br><span class="line"><span class="string">  query ($id: ID!) &#123;</span></span><br><span class="line"><span class="string">    person(id: $id) &#123;</span></span><br><span class="line"><span class="string">      id name address </span></span><br><span class="line"><span class="string">      age gender mobile</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;`</span></span><br></pre></td></tr></table></figure><h3 id="问题仍然存在"><a href="#问题仍然存在" class="headerlink" title="问题仍然存在"></a>问题仍然存在</h3><p>上面统一管理查询字符串的体验还凑合，但是真正开发起来就会发现有以下几个问题绕不开：</p><ol><li>我如何知道一个字符串对应的变量应该是什么？只能查看字符串本身的定义；</li><li>我写字符串的时候如何获得代码提示呢？还是说我只能对着后端的 schema 逐字段慢慢写呢？</li><li>既然都统一管理了查询字符串，是不是还得再封装一层查询方法呢？这样业务逻辑处的代码还能更省。</li><li>如果都用字符串如何使用 Fragment 呢？（或许可以看一下 <a href="https://github.com/apollographql/graphql-tag">graphql-tag</a>）</li></ol><h2 id="更好的方法：代码生成"><a href="#更好的方法：代码生成" class="headerlink" title="更好的方法：代码生成"></a>更好的方法：代码生成</h2><p>如果完成一个请求需要先写查询字符串，再封装一个关于这个查询字符串的请求方法，开发效率不会很高。可以看到上面的代码很多都是琐碎且平凡的，既然如此，可以尝试生成代码。为此我们需要了解以下的包或者插件：</p><ol><li><code>@graphql-codegen</code>: <a href="https://www.graphql-code-generator.com/">graphql 代码生成器</a>，一个 npm 包。通过定义的 schema 和 operation 生成包含请求方法的 typescript 文件；</li><li><code>GraphQL</code>: vscode 插件，用作写 <code>.graphql</code> 文件时的自动补全；</li></ol><h3 id="配置-graphql-codegen"><a href="#配置-graphql-codegen" class="headerlink" title="配置 @graphql-codegen"></a>配置 @graphql-codegen</h3><p>按照该包官方文档的指示进行安装配置即可，不需要太多的配置。其官网上还有下图所示的 live example，非常容易弄懂。</p><img src="/2021/07/23/UseGraphQLElegantly/live.png" class="" title="@graphql-codegen 官网的 live example"><p>我在开发中一般会配置两个代码生成配置文件，一个用于同步后端、生成代码补全所依赖的 schema 文件，一个用于生成 operation 对应的请求方法。如下是两个配置文件的大致内容。</p><figure class="highlight yml"><figcaption><span>schema.codegen.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">generates:</span></span><br><span class="line">  <span class="string">./graphql/schema.graphql:</span></span><br><span class="line">    <span class="attr">schema:</span> <span class="string">&#x27;BASE_URL/api/graphql&#x27;</span></span><br><span class="line">    <span class="attr">plugins:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">schema-ast</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><figcaption><span>operation.codegen.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">generates:</span> </span><br><span class="line">  <span class="string">./api/demo.ts:</span></span><br><span class="line">  <span class="attr">documents:</span> <span class="string">&#x27;./graphql/operations.graphql&#x27;</span></span><br><span class="line">  <span class="attr">schema:</span> <span class="string">&#x27;BASE_URL/api/graphql&#x27;</span> <span class="comment"># 或者直接使用 &#x27;./graphql/schema.graphql&#x27;</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">typescript</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">typescript-operations</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">typescript-graphql-request</span></span><br></pre></td></tr></table></figure><p>配置文件中的 <code>plugins</code> 配置项是关键。<code>schema.codegen.yml</code> 中的 <code>schema-ast</code> 是生成 schema 的 graphql 文件；<code>operation.codegen.yml</code> 中的 <code>typescript-*</code> 则是生成请求方法所依赖的插件。我这里给出的是使用 <a href="https://github.com/prisma-labs/graphql-request">graphql-request</a> 的例子，<code>graphql-request</code> 是一个轻量、简洁，支持 ts 和 promise-based API 的 GraphQL 客户端，在前后端都能使用。</p><p>生成请求方法所依赖的插件根据项目特点选定，例如 <code>graphql-request</code> 这个插件我用在 Vue2.x 的项目当中，而在 React 的项目中我是用的插件是 <code>React-Query Hooks</code>。每个插件对应的基础库的特点不一样，生成的代码风格也不尽相同，根据需要灵活选择即可。</p><h3 id="编写-operations"><a href="#编写-operations" class="headerlink" title="编写 operations"></a>编写 operations</h3><p>operations 顾名思义就是操作，在 GraphQL 里面操作分为 <code>query</code> 和 <code>mutation</code>，编写具名操作会被 <code>@graphql-codegen</code> 转换成为请求方法。下面给一个例子：</p><figure class="highlight plaintext"><figcaption><span>schema.graphql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">enum Gender &#123;</span><br><span class="line">  Female</span><br><span class="line">  Male</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Person &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  address: String!</span><br><span class="line">  age: Int!</span><br><span class="line">  gender: Gender!</span><br><span class="line">  mobile: String!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Query &#123;</span><br><span class="line">  persons: [Person!]!</span><br><span class="line">  person(id: ID!): Person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Mutation &#123;</span><br><span class="line">  setPersonGender(id: ID!, gender: Gender!): Boolean</span><br><span class="line">  greet(id: ID!): String!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>operations.graphql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">query getPersons &#123;</span><br><span class="line">  persons &#123;</span><br><span class="line">    id name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">query getPerson($id: ID!) &#123;</span><br><span class="line">  person(id: $id) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    address</span><br><span class="line">    age</span><br><span class="line">    gender</span><br><span class="line">    mobile</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutation sayHello($id: ID!) &#123;</span><br><span class="line">  greet(id: $id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为用了 vscode 的插件 <code>GraphQL</code>，所以在写 operations 的时候其实是有代码补全的，开发体验比较好，下图是在 vscode 上的代码补全，在 jetBrains 的 IDE 上面的代码自动补全应该会更完善。</p><img src="/2021/07/23/UseGraphQLElegantly/codeSection.png" class="" title="写 .graphql 文件时的代码补全"><h3 id="生成-typescript-代码"><a href="#生成-typescript-代码" class="headerlink" title="生成 typescript 代码"></a>生成 typescript 代码</h3><p>写完上面的 schema 和 operations 之后，运行 <code>graphql-codegen --config operations.codegen.yml</code> 即在 <code>./api</code> 目录下可生成一个 <code>demo.ts</code> 文件。其中包含了下面这样的代码：</p><figure class="highlight typescript"><figcaption><span>api/demo.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 省略了很多</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultWrapper: SdkFunctionWrapper = <span class="function">(<span class="params">action, _operationName</span>) =&gt;</span> action();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getSdk</span>(<span class="params">client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getPersons(variables?: GetPersonsQueryVariables, requestHeaders?: Dom.RequestInit[<span class="string">&quot;headers&quot;</span>]): <span class="built_in">Promise</span>&lt;GetPersonsQuery&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> withWrapper(<span class="function">(<span class="params">wrappedRequestHeaders</span>) =&gt;</span> client.request&lt;GetPersonsQuery&gt;(GetPersonsDocument, variables, &#123;...requestHeaders, ...wrappedRequestHeaders&#125;), <span class="string">&#x27;getPersons&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    getPerson(variables: GetPersonQueryVariables, requestHeaders?: Dom.RequestInit[<span class="string">&quot;headers&quot;</span>]): <span class="built_in">Promise</span>&lt;GetPersonQuery&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> withWrapper(<span class="function">(<span class="params">wrappedRequestHeaders</span>) =&gt;</span> client.request&lt;GetPersonQuery&gt;(GetPersonDocument, variables, &#123;...requestHeaders, ...wrappedRequestHeaders&#125;), <span class="string">&#x27;getPerson&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    sayHello(variables: SayHelloMutationVariables, requestHeaders?: Dom.RequestInit[<span class="string">&quot;headers&quot;</span>]): <span class="built_in">Promise</span>&lt;SayHelloMutation&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> withWrapper(<span class="function">(<span class="params">wrappedRequestHeaders</span>) =&gt;</span> client.request&lt;SayHelloMutation&gt;(SayHelloDocument, variables, &#123;...requestHeaders, ...wrappedRequestHeaders&#125;), <span class="string">&#x27;sayHello&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Sdk = ReturnType&lt;<span class="keyword">typeof</span> getSdk&gt;;</span><br></pre></td></tr></table></figure><p>可以看到 <code>getSdk</code> 这个函数会返回一个对象，其中包含了刚刚在在 <code>operations.graphql</code> 中定义的几个操作。这样就从类型上锁定了这个方法的名字、参数以及返回值。这对于项目维护和开发来说无疑都是利好的。</p><h3 id="使用生成的代码"><a href="#使用生成的代码" class="headerlink" title="使用生成的代码"></a>使用生成的代码</h3><p>因为真正使用的请求方法肯定是要鉴权的，我们需要再调整一下生成的代码，看到上面 <code>demo.ts</code> 中的 <code>defaultWrapper</code> 函数了吗？我们只需要在调用 <code>getSdk</code> 时传入自定义的 Wrapper 即可。下面给个例子：</p><figure class="highlight typescript"><figcaption><span>api/index.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getSdk <span class="keyword">as</span> getDemoSdk &#125; <span class="keyword">from</span> <span class="string">&#x27;./demo&#x27;</span></span><br><span class="line"><span class="keyword">const</span> getClientOptions = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> apiWrapper = <span class="keyword">async</span> &lt;T&gt;<span class="function">(<span class="params">action: (headers?: Record&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;) =&gt; <span class="built_in">Promise</span>&lt;T&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> headers = &#123; <span class="string">&#x27;token&#x27;</span>: getYourToken() &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> action(headers)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> demoClient = getDemoSdk(<span class="keyword">new</span> GraphQLClient(<span class="string">&#x27;/api/graphql&#x27;</span>, getClientOptions()), apiWrapper)</span><br></pre></td></tr></table></figure><p>在需要用到的地方只需要导入 <code>demoClient</code> 即可，我们再用几行代码重写一遍上面的 <code>getPerson</code> 函数：</p><figure class="highlight javascript"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; demoClient &#125; <span class="keyword">from</span> <span class="string">&#x27;./api&#x27;</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getPerson3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> resp = <span class="keyword">await</span> demoClient.getPerson(&#123; id &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端开发 </tag>
            
            <tag> GraphQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记2021年小程序大赛</title>
      <link href="2021/07/20/TheThirdMiniprogramCompetition/"/>
      <url>2021/07/20/TheThirdMiniprogramCompetition/</url>
      
        <content type="html"><![CDATA[<p>从本科到现在总共参加过三次微信小程序大赛，前几天刚完成赛区决赛的答辩，心想着以后应该都不想再参加了，于是想记录一下这次的参赛经历。</p><h2 id="2018-和-2020"><a href="#2018-和-2020" class="headerlink" title="2018 和 2020"></a>2018 和 2020</h2><h3 id="2018-阴差阳错"><a href="#2018-阴差阳错" class="headerlink" title="2018 阴差阳错"></a>2018 阴差阳错</h3><p>微信小程序从 2017 年正式上线博得广大关注，在第二年 2018 年春季，微信就推出了全国高校微信小程序开发大赛，吸引了很多大学生参加，我就是其中一个。正在读大二的我报名了一位学长组织的 SRT(Student Research Training) 项目，原本的题目是要开发一款在线客服平台。然而当时已经把项目申请里面提到的客服平台提前完成了，于是我们真正做的就变成了小程序。甚至还用这个小程序参加了第一届的微信小程序大赛。</p><span id="more"></span><p>虽然做的东西和项目选题没太大关系，不记得当时具体开发的小程序有些什么功能，最后也没有拿到什么奖项（但隐约记得有证书）但通过这项目我第一次接触到了 Javascript、Vue 和微信小程序这些新东西，也认识了几位非常靠谱的队友（在之后的课程作业组队当中也延续了组队），我的收获不少，所以还是非常感谢这次项目经历的。</p><h3 id="2020-毫无波澜"><a href="#2020-毫无波澜" class="headerlink" title="2020 毫无波澜"></a>2020 毫无波澜</h3><p>第二次是在 2020 年用课题组的一个项目参加的比赛，进了华北赛区的决赛，但着实因为我们准备的不够充分而且其他队伍的作品也比较优秀，我们最终也止步于此。得到这个结果我不是特别遗憾，因为我在准备赛区答辩时就有了心理预期，所以说这次参加比赛的内心感受就是毫无波澜吧。</p><h2 id="2021-年"><a href="#2021-年" class="headerlink" title="2021 年"></a>2021 年</h2><h3 id="小程序背景"><a href="#小程序背景" class="headerlink" title="小程序背景"></a>小程序背景</h3><p>如果说对第二次参加比赛的小程序我只是一知半解，那么今年参加比赛的作品我就是了如指掌。因为这是我们大三学期上《软件工程》课程时做的课程作业，它的背景是给学校艺教中心开发一套能够方便琴房管理和琴房预约的系统。</p><p>本来以为这个作业像往常那样只停留在“作业”这个层面，不会有实际使用价值。但是授课老师认为我们组做得不错，于是真正帮我们联系到了艺教中心的老师开了个会。会上艺教中心老师对我们的系统非常满意，这让我们喜出望外，但同时也给我们提了一些问题，例如还没有接入清华校内统一身份认证接口、没有接入校内支付接口等等，但我们相信后面都可以解决的。</p><p>那个学期过得很快，我们组的作品获得了 A 的评分，但是我们小程序的上线过程却不那么顺利：因为要接入校内的接口，我们需要把程序部署到校内的服务器上，之后经历了漫长的申请服务器、申请域名、申请安全扫描、申请证书、申请身份认证接口权限、申请财务接口权限等流程，期间还经历了新冠疫情爆发回不了学校的一个学期以及需求变动重新开发新模块… 功夫不负有心人，终于万事俱备申请上线了，那报名参加比赛吧。小程序名字叫做“掌上艺教”。</p><h3 id="定位和需求分析"><a href="#定位和需求分析" class="headerlink" title="定位和需求分析"></a>定位和需求分析</h3><h4 id="小程序的定位"><a href="#小程序的定位" class="headerlink" title="小程序的定位"></a>小程序的定位</h4><p>掌上艺教是一个涵盖清华大学艺术教育中心琴房租赁和课程管理的一站式系统。面向三类不同的用户，他提供不同的功能。<br>面向在校师生、教职工和居民，掌上艺教提供了校内外两种安全高效的身份认证方式，认证用户可查看琴房空闲时间、预约琴房、在线付款、查看订单和核验电子票等；面向艺教中心开课教师，除了琴房预约外，还提供课程申报、志愿填报等功能；艺教办公室老师可以使用系统的管理后台应用对琴房租赁和课程业务进行管理；</p><h4 id="需求痛点"><a href="#需求痛点" class="headerlink" title="需求痛点"></a>需求痛点</h4><p>清华大学艺教中心历史悠久，业务众多。它每年开设艺术类选修课程 160 门次，指导学生艺术团 12 支队伍共 1300 名队员的排练，同时需要管理校内众多文艺场馆。</p><p>但是艺教中心目前的业务存在<strong>信息化不足、办公效率低</strong>的问题。表现在具体的业务当中有以下两个方面：</p><ol><li><p><strong>在琴房业务中</strong>，艺教中心采用“办卡储值，打孔消费”这样比较原始的机制，容易造成浪费和卡片丢失的问题；同学们要想预约琴房只能亲自去艺教中心询问是否有空余的琴房，这样费时又费力；另外，老师如果想查询、统计和备份数据或者是进行用户管理就很难办到了。这样的局面对于老师管理琴房和同学预约使用琴房来说都非常麻烦。</p></li><li><p><strong>在课程管理上</strong>，开课教师和办公室老师们通过邮件和微信沟通开课意向和期望志愿缺乏系统性，而且在邮件或微信往来过程中信息很容易丢失；最最要命的是，收集到课程信息后，办公室老师需要把 160 门课程的开课时间、上课地点手动地排在一张 Excel 大表里。手动操作出错的概率很高，但是一旦出错会给开课教师、艺教中心和学校教务带来很大的麻烦。下面这张图片就是手动排课时用的表格截图，当然这只是冰山一角。</p></li></ol><img src="/2021/07/20/TheThirdMiniprogramCompetition/manuallySchedule.png" class="" title="手动排课的表格"><p>我们的系统就是要解决上述的痛点。</p><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>我们开发了<strong>掌上艺教小程序</strong>和与之配套的两个管理后台（分别对应<strong>琴房和课程业务</strong>），其中小程序的主要功能有：</p><ol><li><strong>身份认证：</strong>对校内外用户分别进行相应的身份认证，对接清华大学统一身份认证；</li><li><strong>查看课程表：</strong>开课教师能够查看当前学期自己开课的课程表；</li><li><strong>课程信息查看：</strong>开课教师能够查看自己或者其他教师所开课程的信息；</li><li><strong>开课意向填报：</strong>开课征集期间，任课教师可以在小程序中填写开课意向和排课志愿；</li><li><strong>排课信息确认：</strong>艺教办公室老师在后台生成排课表之后，开课教师能够查看并确认课表是否符合预期；</li><li><strong>琴房浏览：</strong>使用掌上艺教能查看艺教中心对外开放租赁的琴房列表并查看它们的信息如空闲时间、租赁单价、位置简介等；</li><li><strong>支付定金：</strong>预订琴房后可在线支付定金，完成支付后将获取订单核验二维码；</li><li><strong>代金券折扣：</strong>支付定金时可使用代金券抵扣指定额度的琴房定金；</li><li><strong>电子票核验：</strong>琴房入检人员可以扫描支付完成的订单二维码核验信息并准入。</li></ol><p>课程管理后台的主要功能有：</p><ol><li><strong>课程信息管理：</strong>可以对系统内课程信息进行增删改查，包括但不限于某一学期内开课教师所创建的课程；</li><li><strong>教学场地资源管理：</strong>可在系统中维护教学场地包括教室地点、教室容量、教室属性等在内的信息；</li><li><strong>排课表生成与调整：</strong>开课教师提交完成排课志愿后，系统将根据开课教师的志愿信息和在系统中设置的权重策略，对所有课程进行自动编排。自动生成出的课表可以进行手动调整；</li><li><strong>后台账号管理：</strong>可以对人员进行账号管理，包括启用/禁用账号、账号密码重置及权限管理；</li><li><strong>教师名单维护：</strong>通过维护教师名单可控制哪些用户能够使用排课系统；</li><li><strong>通知公告：</strong>在管理后台可使用富文本编辑器编辑发布通知公告，并查看教师们的阅览情况（已读或者未读）。</li></ol><p>琴房管理后台的主要功能有：</p><ol><li><strong>琴房信息维护：</strong>可以对琴房列表和琴房信息进行维护，包括琴房名称、位置、头图和占用规则（规律性占用）等；</li><li><strong>订单管理：</strong>可以通过姓名、手机号、证件号、预约时间段、预约琴房等条件进行订单查询与统计，并查看或修改订单详情；</li><li><strong>用户管理：</strong>可通过姓名、手机号、证件号等字段查询用户详情，进入用户详情可将用户纳入黑名单、查看用户的订单和代金券等；</li><li><strong>用户组管理：</strong>通过设置用户组对琴房的预约权限、租赁单价和用户列表，可以实现用户的权限管理和租赁单价管理；</li><li><strong>代金券管理：</strong>可向指定用户手动发放代金券或向指定用户组周期性发放代金券用于琴房定金抵扣。</li></ol><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><img src="/2021/07/20/TheThirdMiniprogramCompetition/architecture.png" class="" title="系统架构图"><p>系统架构方面，我们选用了 Vue.js 作为 Web 应用的开发框架，小程序则使用微信原生框架进行开发。前后端通讯方面我们使用的是 <a href="https://graphql.org/">GraphQL</a>（可能需要科学上网），这和传统的 RESTful API 相比有很多优点，在这里就不展开说了。后端则借鉴了流行的微服务架构的思想，把两部分后端服务进行了实现和部署上的拆分（可以看到两个后端服务的开发语言都不一样），同时两个服务都采取了容器化的部署方式，极大地降低了开发和运维成本，同时减少了系统整体不可用的风险。</p><p>后端服务拆分实现部署的开发方式我们还是第一次采用，这确实给我们的系统带来了很高的灵活性，技术栈的选择也更加自由。而且，通过实现服务间通信，各个实体之间的交流更加密切，可以做到更多有趣的事情。例如微信小程序用户的登录状态存在一个服务 A 上，当另一个服务 B 也需要用到该状态时，可以通过直接向 A 发请求拿到相应的信息。在我们的系统当中，服务间通信是直接发 HTTP 请求，以前实习时做的系统用的是 <a href="https://grpc.io/">gRPC</a> 和 <a href="https://developers.google.com/protocol-buffers/docs/overview">protobuf</a> 来完成的。不过本质都差不多。</p><h3 id="比赛结果"><a href="#比赛结果" class="headerlink" title="比赛结果"></a>比赛结果</h3><p>赛区决赛当天晚上其实就已经出结果了，我们的小程序是华北赛区第 5 名，是三次比赛当中名次最高的了。虽然可能进不了全国决赛，但是我还是能够接受这个名次的。前几名的作品确实有着非常好的产品定位（例如第 2 名“帮你学拼音打字”目标是帮助中老年人学习使用手机拼音打字）和非常高的完成度（例如第 1 名“方仔照相馆”），我们的小程序作为一款在校内使用的半开放式小程序，格局比起他们的来说还是小了不少。</p><h2 id="最后的感想"><a href="#最后的感想" class="headerlink" title="最后的感想"></a>最后的感想</h2><p>2021 年的微信小程序大赛其实已经稍见颓势，从取消微信小游戏赛道这方面就能看出微信不太重视这场比赛了。参赛作品的<strong>多样性和创新性也随着时间的推移逐渐降低</strong>，越来越难以见到让人眼前一亮的好的作品。所以比赛不再受重视也不奇怪，微信一开始推出这个比赛就是想借助有热情有活力的大学生群体带动小程序的市场，而到了 2019~2020 年微信小程序其实已经占据市场主导地位，不再需要依靠比赛来扩大影响力了。</p><p>另外比赛的风气也不太好，2020 年的华北赛区决赛好像就出现了相互举报的状况，有点无语也有点无聊。不知道明年这个比赛还会不会办下去，不过就算继续办我也不太想再参与：我的热情被小程序开发消磨掉不少，也没有太多创新的点子想付诸小程序开发。小程序对于用户来说有着很不错的体验，但是对于我们开发者来说小程序是处处受限的前端应用，这也不能用那也不行。没错现在我已经不想“用户至上”了，我想做更纯粹一些的开发。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
            <tag> 胡思乱想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我毕业了</title>
      <link href="2021/06/29/Graduation2021/"/>
      <url>2021/06/29/Graduation2021/</url>
      
        <content type="html"><![CDATA[<p>从 2016 年 8 月来到清华上学，到现在已经快要五年了。近期借着学校给给 2020 届补办毕业典礼的契机，得以穿上学士服跟朋友们同学们一起拍毕业照。课程学习生活暂告一段落，心里有很多感慨不吐不快。</p><p>大概从以下几个方面来聊一聊吧：专业选择给我的影响，清华之于我的意义以及自己的成长和收获。</p><h2 id="专业选择"><a href="#专业选择" class="headerlink" title="专业选择"></a>专业选择</h2><p>用 697 分的高考分数结束了漫长枯燥的高中生活之后，我进入了清华大学软件学院学习，专业名称是<strong>软件工程</strong>。其实我填报志愿时对清华的专业不是很了解，在招生组老师和学长学姐的介绍之下选择了这个和计算机相关性最大的专业。（对没错，当时我们省不招计算机）</p><span id="more"></span><h3 id="差距很大"><a href="#差距很大" class="headerlink" title="差距很大"></a>差距很大</h3><p>作为小镇做题家的零基础计算机小白，在入学之后很快地就感受到了和其他同学的差距，尤其是编程作业一些同学一小时完成而我要花上一下午甚至一整天的时候。清华的学期中学习压力很大，<strong>26 学分</strong>左右的课程基本上意味着一周五天都是课，每天都有作业要做。当时编程能力十分落后带来的影响导致一些基础数理课也有些吃紧，好在最后都没有触到挂科这个的情况。我经常问我室友或者年级里的其他同学作业问题，怕总是问一个同学把他问烦我就在一些同学之间来回换着问。<strong>在这里要由衷感谢几位大神和我的室友们。</strong></p><h3 id="兴趣渐浓"><a href="#兴趣渐浓" class="headerlink" title="兴趣渐浓"></a>兴趣渐浓</h3><p>我从小就对电脑这东西比较感兴趣，不管是电脑游戏还是一些电脑应用，总是喜欢自己捣鼓。来到软件学院也算是得偿所愿，尤其是很多课程的大作业（或许有的学校叫做“课程设计”）都是写游戏，很对我的胃口。本科应该一共写了 3 个游戏，虽然质量都很差，但是写的过程还是快乐的。我发现我喜欢自己造一些东西出来，写一个游戏、发布一个包或者库、开发一个系统这些都是比较吸引我的事情。<strong>比起考试这样的紧张刺激的课程考核形式，开发游戏或者系统这样成果看得见摸得着的事情，让我觉得更加踏实。</strong>可能总的来说我还是比较希望规避不确定性，拥抱更多的确定性吧。或许这也从一个方面体现了其实我不是天赋型选手，勤能补拙应该是我需要考虑的第一要义。</p><p>大三上了《软件工程》这门课，和另外三个队友真刀真枪的开发一个系统：需求分析、原型设计、技术选型、数据库设计、功能实现、系统测试、文档撰写这些软工流程我们完整地体验了下来，最后课程成绩比较好。我也发现了我确实挺喜欢写代码的。后来的数据库、计算机网络等课程，包括后来到旷视实习的经历都进一步加深了我的兴趣。让我逐渐明晰喜欢的事情。</p><h3 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h3><p>开发的琴房预约系统目前已经上线，虽然之前的队友不太有热情来维护这个项目了，但是就算是我一个人我也会把这个项目好好维护到我自己毕业；作为辅导员，我自己开发了一个系统给自己和同学们用来查询成绩和排名，也给其他辅导员开发了一个计算排名和查询成绩的网站；面对新颖的、高效的、优雅的技术我总是会心生向往，很难控制自己想去了解一下的冲动，可能就是喜欢折腾吧。每次想尝试一个东西我都会在 github 上创建一个叫做 XXX-taste 的 repository，现在类似的 repo 好像已经有十来个了。我觉得目前我对我所做的事情还是保有相当的热情，也愿意为之投入更多的时间。</p><h2 id="清华之于我"><a href="#清华之于我" class="headerlink" title="清华之于我"></a>清华之于我</h2><p>在清华待了五年，要说它给我带来了什么或者让我失去了什么可能很难用言语梳理出来，列一下现在能想到的几点吧：</p><ol><li><p>清华给我上的第一课就是接受平凡，在高中三年大大小小的考试中我很少考第二名，但是到了清华要接受自己是个计算机小白，排名只在中等水平的事实。</p></li><li><p>如果拿不了95分，那么80分也挺好，好好完成课业任务，心态要稳。与其跟别人在成绩上卷，不如做自己感兴趣的、有意义的事情。</p></li><li><p>大学里学的不只是课内知识，更要学习待人处事的方法，增强面对挫折的勇气，拓宽所处世界的视野。</p></li><li><p>朋友很重要，尤其在校园这个小社会当中，他们就是自己的靠山了。</p></li><li><p>入党是一件非常庄严的事情，如果不是明确清晰地认同党的路线和纲领，请不要申请入党或者发展这样的同学。</p></li><li><p>不要总是窝在寝室打游戏，户外真实的风和阳光比游戏中的虚拟更加美好。</p></li></ol><h2 id="总结和展望"><a href="#总结和展望" class="headerlink" title="总结和展望"></a>总结和展望</h2><p>大学里拿过一些4.0，也险些挂了某些课程；当过班长、学生会主席，现在还在继续做着辅导员这份学生工作；感情方面谈过异地恋、异国恋，当过舔狗，被劈过腿。生活体验可以说是非常丰富了（甚至有些离谱），从这些经历中得到了什么成长呢？得到了较强的心理承受能力吗哈哈，挺过挂科边缘的压力还是需要一定的承受力的；一边忙着各种课程作业，一边手忙脚乱地筹办学生节也是很难得的体验，更何况我们还产出了很多优秀的文艺节目；谈的几段感情都是异地，美好的回忆当然是有的，但是遗憾更多吧，这几段经历都无一例外地让我变得更加成熟了。</p><p>距离完全跃入人海还剩下不到两年的时间，通过这五年的时间我应该能够以更好的姿态来迎接未来两年的挑战，也希望剩下的两年里可以多做些自己想做的事情，不留遗憾。冲鸭~</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 胡思乱想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>青岛（二）</title>
      <link href="2021/06/13/JourneyToTsingTao-2/"/>
      <url>2021/06/13/JourneyToTsingTao-2/</url>
      
        <content type="html"><![CDATA[<p>从青岛回来之后马上就是学生节和一系列的课程、任务和作业，根本没时间和心情来写这篇博客，所以青岛（二）这一篇拖了很久…<br>但是过了一个多月的时间很难再拾起当时的心情了，从拍下来的照片里才能记起来去过哪里有哪些好玩的地方，可以说是看图说话。反正也没人看，我直接这样随便写写就当给自己一个交代好了，不喜欢做半途而废的事情。正义虽然会迟到，但永远不会缺席。</p><p>这一篇我们主要是去了崂山、信号山公园、天主教堂、五四广场转了转。</p><span id="more"></span><h2 id="崂山仰口"><a href="#崂山仰口" class="headerlink" title="崂山仰口"></a>崂山仰口</h2><h3 id="海边"><a href="#海边" class="headerlink" title="海边"></a>海边</h3><p>不知道我们怎么想的，不远千里的到青岛去爬山受累，可能这就是正经的游客吧？在前往青岛的高铁上我们才开始做攻略，在马蜂窝上找了几个青岛游的攻略，都说崂山是必须要去的地方，所以我们把崂山列在我们第二天的行程当中。好巧不巧我们选了仰口区，从市区里过去要做两个小时的地铁大巴，实在是太久了。在第一天的 2 万步之后我坐完这两小时的行程时已经有一点蔫了，到了景区下车的时候热浪扑面，虽然前一天很冷，但是这天中午阳光非常充足，把前一天的凉意一扫而空。仰口景区的结构是这样的，景点的起点是在山脚，离海非常近的位置，我们先在海边玩了玩。买了风筝想在海边放，但是奈何海风太猛且方向不确定，很难让风筝飞得高远且持久。朋友都弄的鞋里都是沙子了，但就是不能让风筝飞得让自己满意——只能怪风况不佳咯。</p><p>此时已经是12点多，我们还没有吃午饭，于是灰溜溜的到周边去找地方吃饭。景点里的餐厅又贵又难吃这是我们的共识，于是我们找了一家超市，各吃了一桶方便面（实惨）并买了一些饮料和物资背在包里开始上山了。</p><h3 id="山和海"><a href="#山和海" class="headerlink" title="山和海"></a>山和海</h3><p>天公不作美，我们刚检票入园就下起了雨，我们撑伞走了一段时间雨才完全停。不过这也算好，这也使得景区没有特别热。仰口景区有些道观和寺庙，这些我不是特别感兴趣就不提了。随着爬的高度越来越高，视野逐渐开阔时，我的心情还是很激动的，毕竟很少看到这样的山海景，波澜壮阔、云海翻涌的场景不由的在脑海里开始放映。我们爬到一定高度后在一个亭子里拍了下面第一张照片，山、海、天交相辉映…很难形容我当时的想法。</p><img src="/2021/06/13/JourneyToTsingTao-2/level1.jpg" class="" title="山麓的某亭中"><img src="/2021/06/13/JourneyToTsingTao-2/level2.jpg" class="" title="又上了一些高度"><img src="/2021/06/13/JourneyToTsingTao-2/level3.jpg" class="" title="又又上了一些高度"><img src="/2021/06/13/JourneyToTsingTao-2/level4.jpg" class="" title="山顶的样子"><p>上面的照片是随着高度的不断提升排列的，每上一定的高度都会有不同的景象，每个地方我都拍了一些，其中最后一张是在山顶拍的。</p><p>山顶风特别大。有一个景点叫做“天苑”，一块巨石被另外的石块三个点支撑着却稳稳地立了起来，很有意思。山顶的驻足点由山体本身和一些悬空的木质围栏、栈道组成，些微恐高的我站在木质栈道上有点胆战心惊的，生怕被风给吹垮了或者是被这么多人的重量给压垮。站在上面看着山麓茂密的树林和蔚蓝的海水及其上随风而动的云的阴影，体会到了在北京爬山体会不到的感觉。（毕竟在北京爬山都看不到海)</p><h3 id="觅天洞"><a href="#觅天洞" class="headerlink" title="觅天洞"></a>觅天洞</h3><p>明明可以走平坦的路，我们偏偏选了特别难走的一条。去往山顶可以走常规的楼梯和一个叫做觅天洞的地方，我们也没多想就选择走觅天洞这条路了。进“洞”之前我们看到了一些警示标语——“患心脏病或者心脑血管疾病人士请折返”，我们还纳闷这不就是一个景点至于这样警告游客吗？我们偏不信就进去了。</p><p>然而结果就是它真的和它的名字一样是一个洞，内部非常的潮湿、狭窄、黑暗。我们在其中全程蹲下来扶着墙走，遇到需要爬楼梯的地方我们也几乎是贴墙爬行，用“贴地爬行”一点也不夸张，非常狼狈。爬了二十多米的高度之后终于到了开阔一点的地方，能够看到阳光了。我至今能够想起当时大家一起“苟”的样子，除了我们几个小伙子外还有一些爷爷奶奶辈的人，我非常担心这些人群的安全。非常不推荐以后有人走这个地方：我觉得这个地方作为一个景点是不合格的，标语警示强度不足，谁能知道里面是这样一个样子呢？</p><p>没有图，就是一个约莫一人宽的洞。非要说它给我留下什么好的印象的话，那就是或许可以当作体验一下桃花源记渔人见到“山有小口，仿佛若有光，便舍船，从口入”的经历吧。</p><h3 id="下山"><a href="#下山" class="headerlink" title="下山"></a>下山</h3><p>下山感觉比上山还累，因为上山的时候腿脚已经很疲惫了，下山走楼梯又要不断地给膝盖压力，到山脚的时候感觉膝盖有点废了。又是两个小时的大巴地铁回到住处之后天已经黑了，随便吃了一点东西我们就休息了。</p><p>其实还按照网上的攻略指示去了一趟“劈柴院”，就是一条哪里都有的古风商业街。真的是 哪 里 都 有。一点意思都没有。</p><h2 id="天主教堂、五四广场"><a href="#天主教堂、五四广场" class="headerlink" title="天主教堂、五四广场"></a>天主教堂、五四广场</h2><p>其实没有什么新颖的和印象深刻的东西值得一提。就放几张照片吧，从上到下依次是天主教堂里的窗户、鱼山路某咖啡馆里的大猫、奥帆中心的帆船和海。</p><img src="/2021/06/13/JourneyToTsingTao-2/church.jpg" class="" title="天主教堂里的窗户"><img src="/2021/06/13/JourneyToTsingTao-2/cat.jpg" class="" title="鱼山路咖啡馆的猫"><img src="/2021/06/13/JourneyToTsingTao-2/sailingBoat.jpg" class="" title="奥帆中心"><h2 id="在六月的夏天里写五月的海"><a href="#在六月的夏天里写五月的海" class="headerlink" title="在六月的夏天里写五月的海"></a>在六月的夏天里写五月的海</h2><p>一篇游记拖了一个月才凭借着回忆来写属实有点不可思议，但是这一个月里有很多的课程任务、课题组和辅导员的工作需要处理。直到自己最近把课程的事情都处理完，才能闲下来写这篇博客。</p><p>我发现当我有其他非常要紧且糟心的事情需要解决的时候，我总是很难静下心来做写博客、拍照片、写闲代码这样的事情。可能我的“多线程”能力还有待提高吧，或许是我的抗压能力不太行？听过很多关于现代人时间管理方面的说法，时间是海绵里的水，挤一挤总是会有的，觉得现在看大家在朋友圈里玩得很欢乐，其实玩乐之后还是有很多事情是亟待完成的。</p><p>绝大多数的人无非都是带着脚镣跳舞，但是我带着脚镣的时候我想的不是如何跳舞，而是如何把脚镣解开。这或许是不太现实、不太成熟的想法。生活中谁能够完全把手铐脚镣解开呢？解开一个脚镣之后又会发现自己被新的、更大的脚镣锁住，如何戴着脚镣跳舞，如何把脚镣舞跳好可能是未来的我给自己的重要课题。</p><p>北京的六月特别热，让我又想起了青岛五月的海风了。</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 旅游 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>青岛（一）</title>
      <link href="2021/05/05/JourneyToTsingTao-1/"/>
      <url>2021/05/05/JourneyToTsingTao-1/</url>
      
        <content type="html"><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>最近两个月遇到了不少的烦心事，让我颓废了好一阵子：懒得写博客，懒得跟人说话。很久没有到过海边，都要忘了在海边吹风是什么感觉了，趁着这次五一假期，和两个朋友一起去青岛玩了玩。虽然总共只待了 3 天 4 晚，但是还是有两点收获：</p><ol><li>青岛是一个不错的城市；</li><li>不要在黄金周出游；</li></ol><p>首先，临海的青岛让我这个南方人感受到了久违的湿润，终于不用担心因为干燥导致的皮肤瘙痒和手指倒刺，让我能够把身体乳和护手霜安心地放在行李箱里。青岛风景很美，海鲜很丰富，从视觉和味觉上都给了我满足感。</p><span id="more"></span><p>可能也是因为它的好，让大家在黄金周里都想去看看。我们 4 月 29 号晚上到时还很冷清，街道上车马稀疏，但到了 5 月 1 号立马到处都人挤人起来——我们计划中的不少的去处都是被人海给劝退的，比如信号山公园和小麦岛等等。我很讨厌人扎堆的地方，不管再好的去处，一旦人群密集起来我就会变得很焦躁。今年五一期间大家因为疫情缓和而报复性出游，让我感受到了人们的热情。所以趁着还在学校读书，假期安排比较自由，以后还是尽可能在非公共节假日出游吧。</p><h2 id="栈桥、啤酒和皮皮虾"><a href="#栈桥、啤酒和皮皮虾" class="headerlink" title="栈桥、啤酒和皮皮虾"></a>栈桥、啤酒和皮皮虾</h2><h3 id="栈桥"><a href="#栈桥" class="headerlink" title="栈桥"></a>栈桥</h3><p>4 月 30 号我们开始了第一天的游玩，风特别大，尤其是在海边。虽然 14 度的气温不比北京低多少，但是直观感受起来体感温度可能只有七八度，大概率是 60%的湿度导致的吧。</p><img src="/2021/05/05/JourneyToTsingTao-1/skyOn28Floor.png" class="" title="28楼的窗外"><p>我们住在青岛火车站旁边的一栋高楼里，距离海边特别近，随便吃了点早餐就往海边走了。路上遇到了很多位推销旅游项目（游船、快艇、潜水等）的大叔大妈，“4 月 30 号人少半价，明天再来就不划算了”。我对这种主动推销的旅游项目不是特别感兴趣，我只想自己沿着海岸走走看看、踩踩沙滩，不想因为“今天便宜”就去坐船或者潜水。</p><p>但是旅游嘛，总是要花些冤枉钱的。他们俩很想坐游船和潜水捕捞，一起来的还是不要扫他们兴比较好，我就也买了游船的票。潜水是真的不敢去，大风低温的天气下水和冬泳没什么区别了。游览栈桥的计划就暂停了，我们坐上一辆面包车被一起送到了不远的潜水俱乐部。在他俩潜水的时间里，我就在八大峡广场周围走了走，吹吹海风，拍拍照片。下面是几张我比较喜欢的照片。</p><img src="/2021/05/05/JourneyToTsingTao-1/shore1.png" class="" title="晌午的阳光"><img src="/2021/05/05/JourneyToTsingTao-1/shore2.png" class="" title="远处的电视塔"><img src="/2021/05/05/JourneyToTsingTao-1/ship1.png" class="" title="大海和行船"><p>因为是刚接触摄影，对用光、构图和相机参数都没有特别深入的了解，基本都是用半自动模式靠感觉瞎拍的。但是把看到的东西好好的拍下来的仪式感也非常契合我对“记录”本身的喜爱。</p><p>他们俩从水里出来之后很长一段时间都在瑟瑟发抖，可以看出确实很冷，同时我也庆幸自己没跟着去。他们还从海底捞出来一些贝壳和海星，观感不太好就不在这里放照片了，而且到晚上它们都发臭了…收拾好后我们才开始往栈桥方向走。这时候是中午 12 点多，但是温度反而比上午 10 点更低了，沿着海边从俱乐部走到栈桥的过程中经历了急风骤雨和雨过天晴，现在想起来这也算是一种奇妙的体验了。</p><p>栈桥景区的结构挺漂亮的，拱桥长廊和末端的回澜阁一起组成了“海上如意”的形状。有很多人喂海鸥，有人把吃食放手掌上，海鸥都不过来；有人直接把吃食往空中抛，靠近的海鸥们会竞相争食。还挺有意思的。</p><img src="/2021/05/05/JourneyToTsingTao-1/seagull.png" class="" title="拍不清的海鸥"><img src="/2021/05/05/JourneyToTsingTao-1/ship2.png" class="" title="回澜阁背后的海"><h3 id="啤酒博物馆"><a href="#啤酒博物馆" class="headerlink" title="啤酒博物馆"></a>啤酒博物馆</h3><p>每去到一个地方我就想去当地的博物馆。提起青岛肯定就会想起青岛啤酒，在网上看了攻略的我们在这样寒冷的天气里还是决定离开栈桥前往啤酒博物馆。我们叫了辆滴滴，但是司机偏偏不走系统推荐的稍微远一点但是不堵的路线，而是选择了走大学路。虽然行程时间比预计的多了一倍，我们却能够在车上仔细品味网红街的美，嗯我就是在吐槽这个出租车司机。</p><p>我觉得青岛啤酒博物馆建设和运营得非常好。它分成了 A/B 馆，A 馆是不收费的，视角宏大地讲述了青岛啤酒的历史和成就，B 馆里则细致地介绍了啤酒的酿造工艺，赠饮啤酒原浆，出售文创纪念品，甚至还展示了青岛啤酒的生产车间。中途和终途酒馆都可以领取啤酒，对于喜欢喝啤酒的人来说这里是个不错的去处。</p><img src="/2021/05/05/JourneyToTsingTao-1/produce.jpg" class="" title="忘了叫什么的设备"><img src="/2021/05/05/JourneyToTsingTao-1/beer.jpg" class="" title="满墙的啤酒"><img src="/2021/05/05/JourneyToTsingTao-1/cheer.jpg" class="" title="为我们的友谊干杯"><h3 id="晚餐"><a href="#晚餐" class="headerlink" title="晚餐"></a>晚餐</h3><p>从啤酒博物馆出来我们就到了台东步行街，这里整条街都是海鲜大排档。我们几个人在“晚饭吃什么”这个问题上出现了分歧，有人想回去吃，有人想就近吃，有人想在回去路上边走边看，一度有些不愉快。这时也有店家从路对面走过来招徕，拉踩其他家店，看到这个状况我们都不想在这边吃任何一家店了。</p><p>回去路上看到一家店叫做“沂水人家”，大众点评上查了一下发现评价还不错，我们就选定了这家店。不过，不知道是不小心还是有意为之，他家菜单里写的烤多宝鱼是 78 元/只，但是我们点了一只之后店家跟我们说是 78 元/斤，虽然味道还可以，但是感觉上还是比较奇怪的。除此之外，我们还点了酱猪蹄、清炒茼蒿、辣炒蛤蜊和椒盐皮皮虾，味道都还不错。尤其是椒盐皮皮虾，椒盐永远的神！火候控制得很好，香酥的、椒盐味的壳变得很有风味的同时，虾肉保持了鲜嫩的状态。在这顿饭里皮皮虾毫无疑问是 MVP。</p><img src="/2021/05/05/JourneyToTsingTao-1/fish.jpg" class="" title="烤多宝鱼"><img src="/2021/05/05/JourneyToTsingTao-1/pipixia.jpg" class="" title="椒盐皮皮虾!"><h2 id="崂山、天主教堂、五四广场和海"><a href="#崂山、天主教堂、五四广场和海" class="headerlink" title="崂山、天主教堂、五四广场和海"></a>崂山、天主教堂、五四广场和海</h2><p>我发现开始写之后就变得很啰嗦，总是想把看到的听到的都写下来，记录一天的行程就花了很长的时间。索性拆成两篇来写吧！</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 旅游 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESLint 入门</title>
      <link href="2021/03/28/EslintTaste/"/>
      <url>2021/03/28/EslintTaste/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近一两年写前端项目时一直都有接触 ESLint，很多文档和博客也一直都推荐使用开发者 ESLint，但是一直以来都没有好好地学习过它。最近因为使用 Nuxt 开发时 ESLint 缓存出问题导致浪费了半个小时，我越发觉得有必要深入地了解一下这个前端开发中最常使用的代码风格规范工具了。（不得不说，Nuxt 这个框架真的有点难用。）</p><h2 id="ESLint-的用途和初衷"><a href="#ESLint-的用途和初衷" class="headerlink" title="ESLint 的用途和初衷"></a>ESLint 的用途和初衷</h2><p>ESLint 是在 ECMAScript/JavaScript 代码中识别和报告模式匹配的工具，它的目标是保证代码的一致性和避免错误。维基百科上这样解释的：lint, or a linter, is a static code analysis tool used to flag programming errors, bugs, stylistic errors, and suspicious constructs. 就是说 ESLint 是写 javascript 时用来分析静态代码是否存在语法错误、代码风格错误和可疑结构的工具。</p><span id="more"></span><h2 id="ESLint-的配置文件"><a href="#ESLint-的配置文件" class="headerlink" title="ESLint 的配置文件"></a>ESLint 的配置文件</h2><h3 id="配置文件基础"><a href="#配置文件基础" class="headerlink" title="配置文件基础"></a>配置文件基础</h3><p>配置文件可以使用 .js, .yaml/.yml, .json 格式的文件和 package.json 中的 <code>eslintConfig</code> 属性来定义。读取的优先级如下：</p><ol><li>.eslintrc.js</li><li>.eslintrc.cjs</li><li>.eslintrc.yaml</li><li>.eslintrc.yml</li><li>.eslintrc.json</li><li>package.json</li></ol><p><strong>注：eslint 只会读取优先级最高的一个配置文件。</strong></p><h3 id="最重要的-rules"><a href="#最重要的-rules" class="headerlink" title="最重要的 rules"></a>最重要的 rules</h3><p>ESLint 的配置文件通过配置检查规则来给代码做静态检查，<code>rules</code> 对象中的键值对都代表一个规则，规则的值是一个数组，数组的第一个值是规则的检查力度，从 0 到 2 代表检查的力度越来越严格，0 代表不提示，1 代表给出 warning，2 代表给出 error。也可以直接用力度单词表示，如”off”, “warning” 和 “error”。数组第二个及以后的值表示的是传给该规则的参数。</p><p>下面给的配置文件片段规定在项目中 1. 如果使用了分号则报错；2. 引号只能用双引号，使用了单引号就会报错。</p><figure class="highlight javascript"><figcaption><span>.eslintrc.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="attr">semi</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;always&#x27;</span>],</span><br><span class="line">    <span class="attr">quotes</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;double&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="共享规则库"><a href="#共享规则库" class="headerlink" title="共享规则库"></a>共享规则库</h3><p>另外，ESLint 还可以使用其他共享规则进行扩展。在配置文件中使用 <code>extends</code> 即可，如下面的一行配置项表示引入了 eslint 官方推荐的规则。（官方非常推荐使用这个规则库）</p><figure class="highlight javascript"><figcaption><span>.eslintrc.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">extends</span>: <span class="string">&#x27;eslint:recommended&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然有 recommended 就有 all, 但官方不推荐在生产环境下使用 all 这个共享库，因为其中的核心规则会随着版本的变化而改变，会导致预料之外的情况。</p><p>引入第三方规则库会有三种效果：1. 打开相应的规则；2. 改变检查力度但是不修改其它选项；3. 直接覆盖原本的规则。</p><h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>eslint 的插件其实就是一个 npm 包，可以给 eslint 提供包括但不限于加入新规则和导出共享规则的功能。如下面的配置文件就引入了 react 的 eslint 插件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&#x27;react&#x27;</span>],</span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&#x27;eslint:recommended&#x27;</span>, <span class="string">&#x27;plugin:react/recommended&#x27;</span>],</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;react/no-set-state&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Glob-模式匹配"><a href="#Glob-模式匹配" class="headerlink" title="Glob 模式匹配"></a>Glob 模式匹配</h3><p>eslint 运行后会默认在指定的目录下对<strong>所有的 .js 文件</strong>进行扫描，如果在配置文件中使用了 overrides 参数，则可以对需要进行检测的文件进行指定。如下面的配置文件则指定扫描 <code>bin/*.js</code> 和 <code>lib/*.js</code> 并排除了所有的测试文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="attr">quotes</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;double&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">overrides</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">files</span>: [<span class="string">&#x27;bin/*.js&#x27;</span>, <span class="string">&#x27;lib/*.js&#x27;</span>],</span><br><span class="line">      <span class="attr">excludedFiles</span>: <span class="string">&#x27;*.test.js&#x27;</span>,</span><br><span class="line">      <span class="attr">rules</span>: &#123;</span><br><span class="line">        <span class="attr">quotes</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;single&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用配置注释"><a href="#使用配置注释" class="headerlink" title="使用配置注释"></a>使用配置注释</h3><p>在文件的开头使用 <code>eslint</code> 开头的注释语句可以控制 eslint 对该文件的检测行为。在配置文件中如果配置了 <code>noInlineConfig</code> 属性为 true 的话，就不能使用文件内注释的方式进行配置了。下面摘抄几个配置注释的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1. 整个文件不检查 ===， 使用分号会报错&#x27;</span>)</span><br><span class="line"><span class="comment">/* eslint eqeqeq: &quot;off&quot;, semi: [&quot;error&quot;, &quot;always&quot;] */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2. 在 -- 之后给出一些说明&#x27;</span>)</span><br><span class="line"><span class="comment">/* eslint eqeqeq: &quot;off&quot;, curly: &quot;error&quot; -- Here&#x27;s a description about why this configuration is necessary. */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;3. 在此文件中直接禁用/启用 eslint&#x27;</span>)</span><br><span class="line"><span class="comment">/* eslint-disable */</span></span><br><span class="line"><span class="comment">/* eslint-enable */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;4. 整个文件中禁用某些规则&#x27;</span>)</span><br><span class="line"><span class="comment">/* eslint-disable no-alert, no-console */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;5. 下一行禁用某项规则&#x27;</span>)</span><br><span class="line"><span class="comment">// eslint-disable-next-line</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;6. 这一行禁用规则&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// eslint-disable-line</span></span><br></pre></td></tr></table></figure><h3 id="常用配置项"><a href="#常用配置项" class="headerlink" title="常用配置项"></a>常用配置项</h3><p>摘自另外一篇<a href="https://blog.poetries.top/2018/01/27/eslint-config/">博客</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="string">&#x27;no-var&#x27;</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">  <span class="comment">// 要求或禁止 var 声明中的初始化</span></span><br><span class="line">  <span class="string">&#x27;init-declarations&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="comment">// 强制使用单引号</span></span><br><span class="line">  <span class="attr">quotes</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;single&#x27;</span>],</span><br><span class="line">  <span class="comment">// 要求或禁止使用分号而不是 ASI</span></span><br><span class="line">  <span class="attr">semi</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;never&#x27;</span>],</span><br><span class="line">  <span class="comment">// 禁止不必要的分号</span></span><br><span class="line">  <span class="string">&#x27;no-extra-semi&#x27;</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">  <span class="comment">// 强制使用一致的换行风格</span></span><br><span class="line">  <span class="string">&#x27;linebreak-style&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;unix&#x27;</span>],</span><br><span class="line">  <span class="comment">// 空格2个</span></span><br><span class="line">  <span class="attr">indent</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="number">2</span>, &#123; <span class="attr">SwitchCase</span>: <span class="number">1</span> &#125;],</span><br><span class="line">  <span class="comment">// 指定数组的元素之间要以空格隔开(,后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格</span></span><br><span class="line">  <span class="string">&#x27;array-bracket-spacing&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;never&#x27;</span>],</span><br><span class="line">  <span class="comment">// 在块级作用域外访问块内定义的变量是否报错提示</span></span><br><span class="line">  <span class="string">&#x27;block-scoped-var&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="comment">// if while function 后面的&#123;必须与if在同一行，java风格。</span></span><br><span class="line">  <span class="string">&#x27;brace-style&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;1tbs&#x27;</span>, &#123; <span class="attr">allowSingleLine</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">  <span class="comment">// 双峰驼命名格式</span></span><br><span class="line">  <span class="attr">camelcase</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="comment">// 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号，</span></span><br><span class="line">  <span class="string">&#x27;comma-dangle&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;never&#x27;</span>],</span><br><span class="line">  <span class="comment">// 控制逗号前后的空格</span></span><br><span class="line">  <span class="string">&#x27;comma-spacing&#x27;</span>: [<span class="number">2</span>, &#123; <span class="attr">before</span>: <span class="literal">false</span>, <span class="attr">after</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">  <span class="comment">// 控制逗号在行尾出现还是在行首出现</span></span><br><span class="line">  <span class="string">&#x27;comma-style&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;last&#x27;</span>],</span><br><span class="line">  <span class="comment">// 圈复杂度</span></span><br><span class="line">  <span class="attr">complexity</span>: [<span class="number">2</span>, <span class="number">9</span>],</span><br><span class="line">  <span class="comment">// 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always</span></span><br><span class="line">  <span class="string">&#x27;computed-property-spacing&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;never&#x27;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><p>使用 eslint 的同名命令行工具可以对代码进行分析并将分析报告输出，其主要的使用方式是 <code>eslint [options] [file|dir|glob]*</code>，即最终的分析对象可以是文件、目录和 glob。可以通过选项对工具的行为进行自定义，下面总结一些比较重要的命令行工具选项。</p><ul><li><code>--ext</code>: 指定检测的文件拓展名，eslint 将在给定目录中对指定类型的文件进行扫描检测。如果不给出该选项，默认是 <code>*.js</code>；</li><li><code>--fix</code>: 修复检测出来的问题，但是有时候给了这个选项也修复不了相应的问题，这时候就得手动修改相应位置的代码了；</li><li><code>--fix-dry-run</code>: 修改检测出来的问题但是不进行保存；</li><li><code>--cache</code>: 传递该参数运行命令行工具的话会将检测结果进行缓存，下一次再执行缓存模式时将只针对<strong>有变化的文件</strong>进行扫描；</li><li><code>--init</code>: 初始化 eslint 的配置文件，传入这个参数会进入 eslint 的配置向导，从而生成符合用户期望的配置文件。配置向导如下所示：</li></ul><img src="/2021/03/28/EslintTaste/eslint-wizard.png" class="" title="eslint配置向导">]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从 Vue 到 React —— 第一印象</title>
      <link href="2021/03/27/Vue2React-1/"/>
      <url>2021/03/27/Vue2React-1/</url>
      
        <content type="html"><![CDATA[<h2 id="学习-React-的初衷"><a href="#学习-React-的初衷" class="headerlink" title="学习 React 的初衷"></a>学习 React 的初衷</h2><p>之前说过想要学习 React，秉持着边学边记录的想法，我随即开启了这篇帖子。</p><h3 id="从-Vue-说起"><a href="#从-Vue-说起" class="headerlink" title="从 Vue 说起"></a>从 Vue 说起</h3><p>我是一个 Vue 的忠实粉丝，虽然没有全部读过 Vue 的源码，但是对它的基本实现原理和大体的使用方法还是比较熟悉的。我自己思考过，我觉得我喜欢 Vue 大概率是因为我最早接触的前端开发框架就是 Vue。记得是 2018 年参加一项 SRT 的时候，为了开发一款简单的后台管理系统，我开始学习 javascript 以及 Vue。</p><p>当时我还是第一次接触脚本语言，对没错，我接触 javascript 比接触 python 更早一些。熟悉了 C/C++ 的继承机制之后，突然要接受 javascript 的原型链继承一时间有点缓不过来。但是后来还是被磨平了棱角，被迫接受了原型这一设计。为了开发 Web 应用通过一位学长的介绍接触到了 Vue 这个框架。我直接惊为天人，还能这样写？因为根据我更早之前的一些浅显的印象，Web 开发是分别要编写 HTML，javascript 和 CSS 三种文件的。现在用 Vue 一个文件就可以生成一个完好的页面，着实非常酷炫。也是在 Vue 这里，我了解到了组件、生命周期、全局状态管理、前端路由等等一些重要的概念，所以先入为主地对 Vue 有强烈好感也正常吧。</p><span id="more"></span><img src="/2021/03/27/Vue2React-1/prototypes.jpg" class="" title="javascript 中的原型"><p>Vue 的好处就不说了，这里主要想说以下我遇到的问题：</p><ol><li>在写 Nuxt 项目写到功能比较重的组件时，一个组件 Vue 文件代码可能会到 800 ~ 900 行，写完 template 后滑滚轮滑到 script 部分找到 methods 里对应的地方写函数，如果模板部分出问题了还得滑回去。文件行数一旦长了，这个上下滑动找代码块的过程真的有点难受，一旦思考过程中出现一小段的空挡，那么就有可能导致思绪完全断掉。</li><li>另外，Vue 的代码复用方案我觉得不是特别好：模板方面的<strong>槽</strong>和脚本方面的<strong>混入</strong>这两个我觉得不是特别优雅，尤其是混入。混入的文件一旦多了可能会造成组件难以维护的问题，例如不知道模板中使用的某个属性到底是 mixin 中来的还是从 data 或者 props 中来的，如果出现覆盖那么覆盖规则、覆盖后的值又是什么。</li><li>插件支持我觉得也没有做得特别好，虽然 Vetur 已经做到相当好了，但有一些情况仍旧是解决不了的，比如上面说的 mixin，其中的属性或者方法就没有办法在调用的页面当中提供补全提醒。</li><li>最后，因为总是遇到一些不可名状的 Bug，我打算以后项目的开发要用 typescript，但是 Vue 对 typescript 的支持不是特别好（听说 Vue 3.x 版本有所改善，但是看了一下 Vue3 的文档觉得 composition API 和 React 实在是太像了，不是特别感冒），所以有些打退堂鼓。</li></ol><p>总的来说，Vue 的问题不是特别大，我也没有在做很大型很复杂的项目，上面说的小瑕疵不是本质问题（有问题应该也是我自己能力还没到位）。但是总让我觉得有可以更好的地方。</p><h3 id="React-哪里吸引我"><a href="#React-哪里吸引我" class="headerlink" title="React 哪里吸引我"></a>React 哪里吸引我</h3><p>React 是 Facebook 推出的<strong>用于构建用户界面的 Javascript 库</strong>，应该是目前最热门的“前端框架”，加上引号是因为我觉得它其实不算是一个框架，只是一个“库”，扩展了 js/ts 的语法特性，使它们可以更方便地写 Web 应用。</p><p>它很火，看着也很酷，更原汁原味，更轻量化，更自由，有更多的可能性，这应该就是我想了解它的原因吧。</p><h2 id="对-React-的第一印象"><a href="#对-React-的第一印象" class="headerlink" title="对 React 的第一印象"></a>对 React 的第一印象</h2><p>读了一下官方的入门教程，React 给我印象最深的有下面几个方面：</p><ol><li>完全使用 js/ts 编写，没有增加新的文件类型，在 vscode 中编码体验良好（jsx/tsx 不太算新类型吧）；</li><li>state 与普通属性区别开来，如果需要更新需要显式的调用 setState 方法，虽然牺牲了一定的灵活性，但是也一定程度上促进了数据的安全访问；同时，这样近于“严苛”的 state 更改方法会鼓励开发者将组件拆分成更小的部分；</li><li>提供函数组件和类组件两种写法，函数组件的写法可以省很多空间；</li><li>React Hooks 看起来像是 Vue Composition API 的原型，函数组件用起来会比较“优雅”；</li><li>JSX 渲染函数的写法可以将实现某功能项的代码尽可能的收缩到同一个空间区域，拥有更好的空间“局部性”，免于在 template 和 script 之间来回切换打断思路的困扰；</li><li>阿里的 <a href="https://ant.design/index-cn">Ant Design</a> 为 React 前端开发提供了一个很好的组件库和设计规范，不得不说，阿里对优化用户体验真的有很深入的研究。</li></ol><h2 id="之后探索的方向"><a href="#之后探索的方向" class="headerlink" title="之后探索的方向"></a>之后探索的方向</h2><p>但是其实前端框架归根结底做的事情都是一样的，是让开发者能够较为轻松地开发出易于测试、易于维护、方便拓展、体验良好的跨平台的 Web 应用。不管是之前写 Vue 代码还是之后要写的 React 的代码，都是为了这样一个同样的目的。然而如果仅仅光想着实现功能而不去思考更多，很容易陷入为写代码而写代码的陷阱当中。</p><p>因为我在实验室课题组里负责了几个项目，几乎每个项目都是不超过3人的小团队。如果开发周期稍微变长一些，项目的功能就会变得异常复杂，而作为开发者，在测试的时候很容易就会局限在正常（或者说正确的）业务逻辑当中，不会发现一些匪夷所思的问题。（感觉真的很难让一个要写正确逻辑业务代码的开发者去做一些极不符合预期的事情。）测试很重要。只要不是自己小打小闹的学习性质地写着玩儿，测试就是极其重要的。测试保障的是软件的质量，在任何有甲方的项目当中，没有进行详尽测试都是不负责的。在写后端代码的时候，测试起来比较容易，因为提供的 API 是可预期的，传入什么样的参数，返回什么样的响应，都是清清楚楚的。至少对于开发者自己来说，后端代码都是白盒，将单元测试覆盖率提高就可以显著地提高代码的可靠程度。那么前端测试呢？</p><p>前端测试中主要有单元测试、<a href="https://zhuanlan.zhihu.com/p/100555246">组件测试</a>和<a href="https://www.jianshu.com/p/bbf4686c2cb6">端到端测试</a>。单元测试其实并不区分写的是前端还是后端的代码，都是追求更高的代码覆盖率。而组件测试和端到端测试可能对于前端应用来说更重要吧，因为前端应用给用户操作的组合是无限的，用户可以选择以任何路径，触发页面任何元素可能的动作，想要详尽地测试属实比较困难，但是组件测试和端到端测试应该都是比较成熟的测试方案，能够在一定程度上提高应用的可靠程度。</p><p>之后除了继续接触 React 之外，我还会去了解一些组件测试和端到端测试的最佳实践，扩充一下自己的前端知识储备。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序框架：WePY、uni-app 和 Taro</title>
      <link href="2021/03/14/MiniprogramFrameworks/"/>
      <url>2021/03/14/MiniprogramFrameworks/</url>
      
        <content type="html"><![CDATA[<p>在<a href="/2021/01/21/WechatMiniprogram/">上一篇博客《聊聊微信小程序及其框架》</a>里面立了个调研微信小程序开发框架的 flag ，这篇博客就来填这个坑——我迫不及待地想要掌握一个能够“舒适编写”小程序代码的框架。</p><p>我之前提到我最想先要了解的是 WePY 和 uni-app 这两个小程序框架，WePY 是微信官方出品的小程序框架，uni-app 是使用 Vue 开发小程序的最火的小程序框架，但是这两个框架都让我特别失望。</p><span id="more"></span><h2 id="令人失望的-WePY-和-uni-app"><a href="#令人失望的-WePY-和-uni-app" class="headerlink" title="令人失望的 WePY 和 uni-app"></a>令人失望的 WePY 和 uni-app</h2><h3 id="WePY"><a href="#WePY" class="headerlink" title="WePY"></a>WePY</h3><p>其实最期待的应该是微信的亲儿子 WePY 吧，毕竟是官方出品，质量应该会有所保障，但是看了文档并自己安装运行之后发现还是不对胃口。原因主要有以下几个方面：</p><ol><li>语法以 Vue 为基础但是又在 Vue 的基础上进行了一点魔改，让人产生一定程度的混乱。如果要使用类 Vue 的语法来写小程序，为什么不直接用 Vue 来写呢？</li><li>插件支持不到位，例如 vscode 中的插件 <code>Wepy</code> 就是完全用 <code>Vetur</code> 魔改出来的，在 .wpy 文件中的提示和各项支持并不到位，会提示有各种 warning 和 error；</li><li>使用 <code>@wepy/cli</code> 工具创建标准模板项目之后发现并不能正常编译。</li></ol><p>第一印象很重要，如果这个框架第一时间没有让我感觉到便利，甚至是让我觉得很麻烦，那我是绝对不会再继续在继续研究它的。到这里，WePY 的尝试就结束了。</p><h3 id="uni-app"><a href="#uni-app" class="headerlink" title="uni-app"></a>uni-app</h3><p>uni-app 是由 DCloud 开发的一个小程序框架，致力于让开发者用 Vue 写一套代码编译到 10 个平台都能运行。虽然一开始对于这种为系统引入过多复杂性的框架有些抵触，但是最简单的 WePY 凉了，所以也愿意相信 uni-app 说的:</p><blockquote><p>即使不跨端，uni-app 也是更好的小程序开发框架、更好的 App 跨平台框架、更方便的 H5 开发框架。不管领导安排什么样的项目，你都可以快速交付，不需要转换开发思维、不需要更改开发习惯。</p></blockquote><p>知乎上也有相关的帖子，说 uni-app 比较香，写起来很省心。抱着尝试的心态看了一下 uni-app 的官方文档、用 vue-cli 安装了 DCloud 官方的项目模板尝试编译运行、下载了 HBuilderX 尝试编译运行。运行是能运行，但是效果马马虎虎，体验有点糟糕，印象大打折扣。主要的问题有以下几点：</p><ol><li>官网文档有些混乱，非常非常非常着重的说明如何进行跨端的适配、条件编译有何注意事项等等，对于只想简单在单一平台编译运行小程序的开发者来说不够简洁；</li><li>命令行工具的表现和 HBuilderX 的不一致，大部分情况下命令行下都编译运行不了，或者是当我想引入一些如 Vant 的组件库的时候小程序就编译错误；</li><li>上一条提到的部分问题如果使用 DCloud 的官方 IDE HBuilderX 的话就可以用“导入插件”的方式解决一部分。但是体验非常非常差，简直就是道德绑架——要编译就要用我的 HBuilderX。什么？你没安装啊，那打扰了；</li><li>尝试使用官方推出的插件将使用原生微信小程序语法编写的代码转换成 vue 风格的 uni-app 代码，但是转换出来之后一团糟，根本没办法运行。</li></ol><p>uni-app 最大的问题在于它太复杂、太希望构建自己的生态、太希望牢牢抓住开发者了。复杂的东西往往都很脆弱，经不起折腾，稍微碰一下就错误百出。它几乎是强制开发者使用他们的 HBuilderX 来进行小程序开发，这一点我无法接受，你不让我自由选择开发工具，我就可以不用你。但是这些问题也情有可原，毕竟它是 DCloud 的主要业务之一，需要给公司带来一定比例的收益。</p><h2 id="Taro-宇宙最强的泰罗奥特曼"><a href="#Taro-宇宙最强的泰罗奥特曼" class="headerlink" title="Taro 宇宙最强的泰罗奥特曼"></a>Taro 宇宙最强的泰罗奥特曼</h2><h3 id="Taro-文档阅读"><a href="#Taro-文档阅读" class="headerlink" title="Taro 文档阅读"></a>Taro 文档阅读</h3><p>我一直觉得很多开发者都非常可爱，从起名上就可见一斑，比如 Taro 这个小程序跨端框架、分布式应用程序协调服务 ZooKeeper 和分布式系统基础框架 Hadoop 等。Taro 是京东的凹凸实验室推出的小程序跨端框架，和 uni-app 一样支持写一套代码编译到不同的地方。目前已经进入了 3.x 阶段，除了可以用 React/Nerv 进行开发，还支持了 Vue/Vue3。我马上看了看 Taro 的官方文档，比 uni-app 好太多了：快速开始、基础教程、进阶指南、迁移指南层层递进；官方组件库和 API 列表罗列清楚，对它们在 React 和 Vue 中的使用方法说明得很清楚；还提供了专门的“教程”模块，对于刚上手的开发者十分友好；更重要的是，它提供了一套原生的 UI 组件库 taro-ui ，甚至还照顾了 Vue 的版本推出了 taro-ui-vue。依靠这些了解，我就觉得以后就是它了，要是再有新的小程序项目，我应该会首选使用 Taro 进行开发。</p><h3 id="尝试初始项目"><a href="#尝试初始项目" class="headerlink" title="尝试初始项目"></a>尝试初始项目</h3><p>于是，我赶紧创建了 <code>taro-taste</code> 文件夹。</p><p>本来打算随便写一个 demo 小程序，又不想再单独写一套后端代码（再简单也懒得弄了），就用之前申请的一个小程序用来作为云开发的基础。用 taro 自带的 cli 工具初始化了一个微信小程序的云开发模板。用微信开发者工具打开之后，一切表现都很正常，没有什么复杂的事情，没有类似 uni-app 一样的满屏 error，云函数也能够正常调用。但是用 Vue 开发小程序有一些其他的点是需要重新适应的，例如：</p><ol><li>template 部分的基础元素只能用 view 而不能用 div；</li><li>事件名称或许不一样，如点击事件需要用 tap 而不用 click 等；</li><li>安装 taro 官方的 package 最好改用淘宝的源或者直接使用 cnpm ，不然就会出现安装失败的问题。</li></ol><p>不过整体而言已经很满意了，对 Vue 的支持也比较全面，之后应该会真正用它来进行开发吧。</p><h3 id="不如了解一下新东西"><a href="#不如了解一下新东西" class="headerlink" title="不如了解一下新东西"></a>不如了解一下新东西</h3><p>但是有一点比较奇怪的是，在 Vue 项目模板的首页文件中，根节点 view 元素有个 <code>className=&quot;index&quot;</code> 的属性，这是 React 类名的写法。想到 Taro 在 3.x 版本以前只支持 React/Nerv 的情况，出现 className 这个属性应该是 3.x 版本目前还没有把对 Vue 的支持做得很完善吧。</p><p>恰好我最近在做其他项目开发的时候感觉 Vue 在<strong>代码复用、数据更新和访问方面的一些体验不是特别友好，而且组件文件规模很难控制（这应该是我的编码水平问题…）</strong>，不如去学习尝试一下 React 吧。听说 Hooks 配合函数组件用起来很舒服，而且 React 完全是在写 javascript/typescript，开发起来应该会比一个文件里写 template/script/style 来回切会容易把控一点吧。</p><p>当然，它们归根到底只是开发框架而已，前端项目开发万变不离其宗，但是了解一个很酷的新东西本身就可以给我很大的动力，对吧？</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊微信小程序及其框架</title>
      <link href="2021/01/21/WechatMiniprogram/"/>
      <url>2021/01/21/WechatMiniprogram/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么是微信小程序"><a href="#为什么是微信小程序" class="headerlink" title="为什么是微信小程序"></a>为什么是微信小程序</h2><p>微信很早就有一套专用的<code>JS-SDK</code>在微信客户端上面使用，其开放了录音、二维码、地图、支付等几十个 API，能够支持微信服务号的运转，当时大部分支付、扫码等功能的对接方都是这样的服务号。但是在 2016 年 1 月 11 日微信之父张小龙表示服务号还不够优秀，微信正在研究一个新的服务形态，起名叫做“微信小程序”。在 2017 年 1 月 9 日，第一批微信小程序低调上线，而选择这一天也是为了向 iPhone 1 代的发布致敬。</p><img src="/2021/01/21/WechatMiniprogram/iPhoneRelease.jpg" class="" title="向 iPhone 致敬"><span id="more"></span><p>很快，微信小程序依靠微信的庞大用户量迅速的占领了市场，其他各个大厂见势相继效仿，但是从目前来看它们都很难和微信小程序再抗衡了——不管是用户数量还是开发者数量。这倒也不太奇怪，这种行业往往都是快鱼吃慢鱼不是大鱼吃小鱼，emmm…不过背靠腾讯的微信也不能说是小鱼吧。</p><img src="/2021/01/21/WechatMiniprogram/otherMiniprograms.jpg" class="" title="各厂小程序出现的时间轴"><h2 id="为什么要写微信小程序"><a href="#为什么要写微信小程序" class="headerlink" title="为什么要写微信小程序"></a>为什么要写微信小程序</h2><p>首先想说的是，微信小程序的生态是比较混乱的，开发起来有一点难受，有不少情绪比较激动的开发者直接说微信小程序就是“s**t”，我也能够理解其中的一大部分感情。</p><p>我从大二参加微信举办的第一届大学生微信小程序大赛到现在已经有 3 年了，这期间虽然不是一直在开发小程序，但是每年都会或多或少因为课程或者是项目的原因接触小程序开发，所以对微信小程序还是有一定的了解的。</p><p>小程序<strong>非常</strong>不好写。我觉得有以下几个方面的原因:</p><img src="/2021/01/21/WechatMiniprogram/structure.jpg" class="" title="微信小程序的基本架构"><ol><li>一个页面(Page)拆成四个文件这样分散的组织形式让我觉得有点难受，有的人可能会说这是关注点分离，但是我觉得 Vue 在单文件内拆成多个部分的形式可能更好一点，<a href="https://cn.vuejs.org/v2/guide/single-file-components.html">一个重要的事情值得注意，关注点分离不等于文件类型分离</a>。而且你说一个叫做<code>page</code>的页面，它下面的四个文件名是叫<code>page.wxml</code>好还是叫<code>index.html</code>好呢？</li><li>微信开发者工具非常不好用，首先它很占内存，内存小的机器上运行微信开发者工具一段时间后会出现奇奇怪怪的问题，因为遇到的次数有点多也没有特别记得，在这里也说不出来了。</li><li>因为在微信的生态里面，处处都要依照微信的规矩来进行开发或者运维（这倒也没办法），用某某接口需要是某某类目的小程序，需要有某某资质的主体等等……申请接口、申请上线等种种流程都十分繁琐。</li><li>官方文档有些混乱，而且最近两三年内没有进行过较大的更新改进。</li></ol><p>但是有的时候又不得不写它，因为它<strong>对用户更加友好</strong>。如果换作是我的话，我也不会为了去餐厅点餐或者是在奶茶店买奶茶专门下载一个 App，为了扫健康码就更不会。微信小程序就是为了替代微信服务号这样的“用完就关”的应用场景的，开发的时候把它当作微信服务号 2.0 来开发就好了，不要提高自己的心理预期以为自己是在开发一款 App。这样想的话，开发起来就会好接受多了。</p><h2 id="小程序框架浅析"><a href="#小程序框架浅析" class="headerlink" title="小程序框架浅析"></a>小程序框架浅析</h2><h3 id="逻辑层和渲染层"><a href="#逻辑层和渲染层" class="headerlink" title="逻辑层和渲染层"></a>逻辑层和渲染层</h3><img src="/2021/01/21/WechatMiniprogram/mpImplementation.jpg" class="" title="微信小程序的系统框架"><p>微信小程序通过微信客户端(Native)这一桥梁向外界服务器发送请求和接受响应、调用手机本地接口(拍照、上传文件等)。小程序分为了渲染层和逻辑层，小程序页面的 WXSS、WXS 和 WXML 运行在渲染层，而 JS 运行在逻辑层。WXS 是专门给小程序推出的一个脚本语言，是 JS 的子集，运行在渲染层执行一些简单的数据处理任务，据官方文档说使用 WXS 在 Android 上没有太多性能提升，但是在 iOS 上用其执行相关任务能加速 2~20 倍。</p><p>微信小程序的渲染层与逻辑层也通过 Native 进行通信，比如渲染层将触发的事件传输到逻辑层，逻辑层将更新的数据传输到渲染层等等。可以看到上面这张图里渲染层分了很多个 Webview，其中每个 Webview 都代表了一个小程序页面。</p><img src="/2021/01/21/WechatMiniprogram/viewLogic.jpg" class="" title="逻辑层与渲染层共同渲染"><p>WXML 文件其实是标识了页面的元素及其相互关系，在微信小程序的编译过程中，WXML 文件会被编译成为 JS 对象用来在渲染层维护一个虚拟的 DOM 树。通过与逻辑层的数据进行组合，形成一个数据和结构都完整的虚拟 DOM 树用以渲染。<strong>每次在逻辑层调用 setData 方法时，逻辑层都会将这个消息传输到渲染层</strong>，渲染层通过对比发来的数据与之前的数据，将有差异的数据应用到 DOM 树上，从而进行更新渲染。</p><p>目前市面上有许多的小程序开发框架，如 Taro、Uni-App、mpvue、WePY 等，有实验显示使用小程序框架进行开发会使得小程序性能提升，其中很大一部分原因就是开发框架会对 setData 的调用进行优化，减少逻辑层和渲染层的实际通讯次数，从而提升性能。</p><p>而采用渲染层和逻辑层的架构主要是为了阻断页面渲染和逻辑处理，从而加强监管、提升性能。</p><h3 id="小程序页面生命周期"><a href="#小程序页面生命周期" class="headerlink" title="小程序页面生命周期"></a>小程序页面生命周期</h3><img src="/2021/01/21/WechatMiniprogram/lifecycle.jpg" class="" title="小程序页面对象生命周期"><p>从微信小程序官方文档上面的生命周期图示(方便起见，我把纵向的长图拆成了左右两个部分)可以看得很清楚，逻辑层与渲染层分别进行初始化。</p><ol><li>逻辑层执行完 onLoad 和 onShow 两个生命周期函数之后，等待渲染层初始化完成的通知；</li><li>逻辑层收到通知之后，将初始数据传输给渲染层，渲染层拿到数据进行首次渲染之后再次通知逻辑层，让其执行 onReady 生命周期函数；</li><li>执行完 onReady 函数之后，小程序就处在 Active 状态了；</li><li>如果小程序在激活状态下被最小化到微信的后台或从后台被唤起，则会调用 onHide 和 onShow，如果在激活状态被关闭，则会调用 onUnload (一般不会用到)。</li></ol><p>小程序从后台被唤起时的启动叫做热启动，第一次打开或者距离上一次打开已经过去了足够长的时间时叫做冷启动。他们进入页面生命周期的位置不同，开发的时候需要格外注意一下。</p><h2 id="我自己的小程序开发方法"><a href="#我自己的小程序开发方法" class="headerlink" title="我自己的小程序开发方法"></a>我自己的小程序开发方法</h2><p>开发微信小程序有许许多多的方式，最原始质朴的方式就是直接使用微信开发者工具进行编码和调试，这是我在大二的时候使用的方法。我已经很久没有用过这种方法了，但是它至今仍然给我很不好的回忆，究其根本主要是因为 IDE 实在是太难用了。</p><p>后来使用 WebStorm 来进行微信小程序编码，但是发现我自己的笔记本电脑(18 年老电脑了)同时带 WebStorm 和微信开发者工具两个“重型” IDE 实在是有点吃不消，遂作罢。</p><p>后来接触到了 gulp 这个前端工程化工具，可以让编码过程更加自由，尤其是能够使用 sass 等 css 预处理器，让我觉得开发起来清爽了很多。目前我是用<code>VS Code</code>进行编码，同时使用了<code>minapp</code>, <code>Live Sass Compiler</code>这两个插件，能够原地使用 sass，也没有增加过多的复杂性，很符合我自己的“编码哲学”hhhh。</p><p>我在写代码的时候一直觉得奥卡姆剃刀原理是真理，可以不要的就一定不要。这样的想法使得我在之前的开发中从没有想过用小程序开发框架，“一次编码自动构建多个平台的小程序”，我需要开发的只有“微信小程序”这一个而已，不需要增加那么多的复杂性。</p><p>但是最近越来越受不了小程序复杂的设计了，尤其是写惯了 Vue 再来写小程序，简直就和降智了似的。</p><p>之后我应该会看一些小程序框架的文档，先从 Uni-App 和 WePY 这两个开始吧。Uni-App 是用 Vue 语法开发小程序的框架，支持一键生成多端小程序。而 WePY 则是微信官方推出的小程序开发框架，仅支持微信小程序。这也算是立了 flag 吧。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么我要写博客？</title>
      <link href="2021/01/16/WhyBlog/"/>
      <url>2021/01/16/WhyBlog/</url>
      
        <content type="html"><![CDATA[<h2 id="内外因素"><a href="#内外因素" class="headerlink" title="内外因素"></a>内外因素</h2><h3 id="我喜欢记录"><a href="#我喜欢记录" class="headerlink" title="我喜欢记录"></a>我喜欢记录</h3><p>我很喜欢记录，就像首页那句话说的“有着记录的想法，没有记录的时间”一样：我喜欢把生活里有趣的、激发自己思考的事物都记下来，倒不是为了写给谁看或者写给未来的自己看，光是写下来的过程会让我觉得很好，不知道怎么用语言形容的一种“满足感”；但是在学校的时候事情实在是太多了，学习、社工、项目还有各种琐碎的事情让我根本没有时间把所想所见记录下来，所以也就有了这个博客里年更的情况出现了。</p><p>2019年的12月31日，我在自己的非主流QQ空间发了一篇名为《别了，我的一零年代》的日志，回顾了一下自己的中学和大学本科时期的得与失，2020年年底实在是太忙了，没能够再写一篇“年终总结”。不过现在想起来也不是很遗憾，因为2020年不是很能激起我的记录欲。好！在！已经研一，兵荒马乱的研一上学期也已经度过了，至少未来一年半内不会有太多课程上的压力，这样可以让我有更多连续的时间能够用来记录。这是让我非常开心的，我猜我今后会多写一些东西在博客上吧，应该会。</p><span id="more"></span><h3 id="我应该记录"><a href="#我应该记录" class="headerlink" title="我应该记录"></a>我应该记录</h3><p>“学计算机的人应该有一个博客”是我从大学入学时就有的一个想法，这样朴素的情感大概是在我拜读了阮一峰和廖雪峰等大神博客之后就在心里扎根了的。确实，不管是大一入学、大二做课程大作业、大三在校外实习，通过查询和浏览博客是我解决特定问题的主要方式。所以我觉得自己应该也要成为这样的一个“博主”，虽然没有特别亮眼的技术实力，但是通过写博客督促自己不断的学习也是一件足够酷且有益的事情。</p><p>还有一件事情值得一提，在写<a href="/2020/05/09/HowToUseGithubActions">《Github Actions的基本使用》</a>时其实我是边学边写，一开始觉得有个地方是 GitHub Actions 的 Bug ，迫于无奈和夜深，发布博客之后就赶紧溜去睡觉了。第二天回看博客的时候一眼就发现了问题所在，这样的特点也从另一方面激励我继续写博客。</p><p>“记录”对我是有好处的。</p><h2 id="近期的一点牢骚"><a href="#近期的一点牢骚" class="headerlink" title="近期的一点牢骚"></a>近期的一点牢骚</h2><p>清华的竞争氛围太强了：每个人都是高中的佼佼者，到了大学有的人依旧游刃有余，有的人就力不从心了，不管排名保持高中的状态还是变好或变坏都是非常正常的事情。找准自己的定位和方向，保持努力就可以了，没有什么比热情更重要。在知乎上经常能看到“清华XX系大四了还一事无成怎么办”这样的问题，如果要我回答的话我确实无法组织出一段话来回答这样的问题，在提问者的上下文里我其实也是一事无成的。</p><p>跟人比较确实上头，确实会增加焦虑。可是我不会把自己推到这样的焦虑当中，我不喜欢跟别人比，我只希望自己可以充实和从容，不用妄自菲薄，也不要自以为是。自己只要保持这样的心态和步调就不太在意身边的压力了。</p><h2 id="之后写点什么"><a href="#之后写点什么" class="headerlink" title="之后写点什么"></a>之后写点什么</h2><p>之前有的两个标签是“学习”和“瞎写”，现在觉得“瞎写”有点莫名其妙，之后打算换成“随笔”。有考虑增加一两个标签（例如“游记”和“相册”等），也希望自己能够维持“学习”和其他标签博客的比例。</p><p>最后，希望2021年一切都好。</p><p>迟到的新年小作文</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 胡思乱想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当我写H5时，我到底在写什么？</title>
      <link href="2020/06/07/WhatIsH5/"/>
      <url>2020/06/07/WhatIsH5/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>“活动宣传写个H5就可以了”，”学生节不如做一个H5小游戏吧，比如之前那种学堂路躲避乌鸦“……在这几年的学习和生活中我听到过很多次H5，也真正看到过、使用过、制作过H5，但是我对H5这一个词的真正定义还是不太了解。它给我的直观印象就是在手机上运行的、包含许多动画甚至音乐的纯前端/弱后端页面，最常见于微信群、公众号和朋友圈，或许这也是大多数人对其的印象。对自己接触的东西一点也不了解是不能接受的，所以要简单调查调查。</p><h2 id="H5的由来"><a href="#H5的由来" class="headerlink" title="H5的由来"></a>H5的由来</h2><h3 id="几种定义"><a href="#几种定义" class="headerlink" title="几种定义"></a>几种定义</h3><ul><li>h5是HTML的第5级标题标签；</li><li>H5是<em>在手机上运行的、包含许多动画甚至音乐的纯前端/弱后端页面</em>；</li><li>h5是2014年10月由W3C制定的HTML新一代标准，其中包含了新标签、新属性、多媒体和本地存储等特性。</li></ul><span id="more"></span><h3 id="H5为什么火？"><a href="#H5为什么火？" class="headerlink" title="H5为什么火？"></a>H5为什么火？</h3><p>H5是HTML的第5代标准，它不是一个新的应用，不是一个编程语言，甚至不是一个实体(Web应用、微信小程序等)，他就是常规意义上的HTML新版本，和C++17、C++20差不多。HTML等Web应用相关语言和Golang、C++等语言还不一样，它们的标准还需要各大浏览器的运行时支持才算是“真正”拥有了新特性。但是如今大多数用户都能够很方便地通过电脑、手机接触到Web应用，其中不乏动画酷炫、插画精美、音乐好听、让人眼前一亮的应用，开始有人将这样的应用叫做H5，后来逐渐传开再也无法很好地定义了。</p><p>普通用户是不会去了解H5到底是什么的，隔行如隔山，弄明白这个对用户来说作用不大。据我观察，各大H5应用模板网站也不会强调这个H5到底是怎么做的，而是统一作为模板打包卖给用户就行。H5可能是纯前端的，也有可能有弱后端，但是“注重呈现”应该是H5的核心，有“动态海报”内味儿。接下俩的H5统一取第二个定义。</p><h2 id="H5的组成"><a href="#H5的组成" class="headerlink" title="H5的组成"></a>H5的组成</h2><img src="/2020/06/07/WhatIsH5/html5.jpg" class=""><p>H5也是Web应用，那么就离不开HTML、CSS和JavaScript，HTML负责文档结构、CSS负责视觉样式、JS负责业务逻辑，在写H5的时候其实是在写这三种语言。HTML5中的如<code>&lt;canvas&gt;</code>、<code>&lt;audio&gt;</code>、<code>&lt;video&gt;</code>和<code>&lt;svg&gt;</code>等新标签确实为前端的图形渲染提供了良好的载体，但是应用的代码组织与以前差别并不是很大。如今许多浏览器都支持HTML5标准，许多前端程序员也在使用HTML5标准提供的新标签，那么可以说现在只要是写前端都是在写H5。</p><h2 id="SPA-高级H5"><a href="#SPA-高级H5" class="headerlink" title="SPA - 高级H5"></a>SPA - 高级H5</h2><p>单页面应用(Single Page Application)的说法最近几年非常流行，前后端分离的开发风格、Web技术和云计算的发展使得浏览器中运行的Web应用无论是<strong>开发流程</strong>还是<strong>使用体验</strong>上都越来越接近原生应用(Native Application)。许多SPA的功能全体量大，不输给原生应用。HTML5中提供的本地存储(localStorage)特性相信许多开发者都用过，使用它可以构建相当强大的功能。那么把它叫做高级H5也不过分吧？（doge</p><p>另外，如Vuejs、Reactjs等在内的前端开发框架也简化了SPA的开发。</p><p>我以前接触过Vuejs和微信小程序，当时觉得微信小程序是大部分借鉴了Vuejs的精髓。前一阵子又看了看Reactjs的文档，发现微信小程序的架构里也能发现Reactjs的影子……虽然React有facebook官方的支持，但是有一说一它的中文文档是真的不行，过时的文档google出来结果竟然还在前列。相比之下Vue虽然没有大公司支持，但是越来越赢得开发者的青睐，其文档的完善也是一大因素吧。</p><h2 id="Vue-js-The-Documentary"><a href="#Vue-js-The-Documentary" class="headerlink" title="Vue.js: The Documentary"></a>Vue.js: The Documentary</h2><p>最后放上Vue.js的纪录片，赏心悦目。</p><div class="video-container"><iframe src="https://www.youtube.com/embed/OrxmtDw4pVI" frameborder="0" loading="lazy" allowfullscreen></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端开发 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读: Role-Based Access Control Models, 1996</title>
      <link href="2020/05/18/ReadRBAC/"/>
      <url>2020/05/18/ReadRBAC/</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>论文描述的方法简称RBAC，基于角色的访问控制，是目前非常主流的访问控制方法。用户（User）、角色（Role）和权限（Permission）是论文中最主要的三个概念。角色和用户组这个概念很像，但是用户组仅仅只是一个用户集合，而角色则联系着用户和权限。说到底都是为了让用户获取权限来执行相应的操作，不管是加入角色还是用户组，都只是一个中间态。</p><p>RBAC0是基础模型，是任何系统实现RBAC的最低要求。RBAC1和RBAC2都包含了RBAC0，但是分别加入了不同的特性。RBAC1加入了角色层级特性，即角色A可以通过继承角色B获取角色B拥有的权限。RBAC2加入了约束特性，控制用户对RBAC中不同资源、组件的权限。而RBAC3包括了角色层级和约束。示意图如下所示，其中基础模型RBAC0是实线部分。</p><span id="more"></span><img src="/2020/05/18/ReadRBAC/fig1.png" class=""><p>文章并没有给出模型具体的实现方案，这些模型主要用作产品开发的指导准则或设计原型。</p><h2 id="RBAC模型族"><a href="#RBAC模型族" class="headerlink" title="RBAC模型族"></a>RBAC模型族</h2><h3 id="RBAC0"><a href="#RBAC0" class="headerlink" title="RBAC0"></a>RBAC0</h3><p>基础模型主要由用户U，角色R和权限P三个实体集组成，图表中也表示出了会话S。用户代表使用系统的每一个“人”；角色代表负责一系列职责的人群，用职业或者岗位来理解；会话是将从用户到多个角色的映射。权限需要详细说明。</p><p>权限是访问一个或多个数据对象或其他资源的许可证，权限通常是正向的，即拥有权限后可以访问对应的对象。但是有的模型把权限设计成为负向的，即获得这个权限后将无法访问对象。RBAC模型中将负向权限建模成为“约束”，后文会提及。权限的含义完全取决于系统的类别和系统的实现细节。操作系统中区分了文件、目录、设备和端口等对象的读、写和执行操作；数据库对关系、元组、属性和视图等对象的查询、更新、删除和插入操作进行了区分。</p><p>图1还展示了用户分配UA和权限分配PA关系，它们都是多对多关系。RBAC的关键就蕴藏在这两个关系当中。RBAC0中各组成部分为：</p><ul><li>U, R, P, S，分别代表用户、角色、权限和会话</li><li>PA，权限分配，权限到角色的多对多关系</li><li>UA，用户分配，用户到角色的多对多关系</li><li><em>user</em>， 从一个会话映射到一个用户的函数</li><li><em>roles</em>，从一个会话映射到一个角色集的函数</li></ul><h3 id="RBAC1"><a href="#RBAC1" class="headerlink" title="RBAC1"></a>RBAC1</h3><p>RBAC1在0的基础上加入了角色层级，这个特性在现代组织管理当中显得很自然。层级高的角色继承层级低的角色的权限，如Team Leader可以访问所有项目的细节而Project Programmer只能访问所属项目。</p><p>从离散数学的角度来说，角色间的层级是偏序关系，即满足了自反性、传递性和反对称性的关系。</p><p>私有权限或私有角色通常用于控制角色继承时的权限作用域，如对进展中的为完成工作访问权限如果从低级角色直接继承到高级角色似乎不是特别合适。如Team Leader不应总是收到每一位Programmer的CI Build失败通知。</p><h3 id="RBAC2"><a href="#RBAC2" class="headerlink" title="RBAC2"></a>RBAC2</h3><p>RBAC2在0的基础上加入了约束特性，这个特性有时被称作RBAC的灵魂。<br>约束是是一个强力的机制，可以用来打造更高水准的组织管理架构。下面是文章介绍到的一些常见约束：</p><ul><li>互斥约束，互斥顾名思义就是用户只能获得其中一个角色身份，或者同样的权限只能赋予其中一个角色；</li><li>基数约束，一个角色最多只能拥有一定数量的成员；</li><li>先需角色约束，给用户分配角色A之前需要该用户拥有角色B的身份；</li><li>角色层级约束，没错就是RBAC1中的角色层级，它也可以被看作是一类约束。</li></ul><h3 id="RBAC3"><a href="#RBAC3" class="headerlink" title="RBAC3"></a>RBAC3</h3><p>RBAC3就是把1和2组合起来，既有角色层级又有约束条件。</p><h2 id="基于RBAC的管理模型"><a href="#基于RBAC的管理模型" class="headerlink" title="基于RBAC的管理模型"></a>基于RBAC的管理模型</h2><p>上面提到RBAC模型当中所有组成部分都是由一个安全管理员直接负责，这样的情况只有在极小的系统中才有可能存在。任何稍大一些的系统都有多个安全管理员。由于RBAC的主要好处就是实现了权限的管理，那么如何让RBAC来管理RBAC本身呢？论文提出的管理模型在图4中展示，其上半部分就是之前的图1(b)部分，其下半部分是上半部的镜像，其中包含了管理角色AR和管理权限AP。权限只能授予给角色，管理权限只能授予给管理角色。</p><img src="/2020/05/18/ReadRBAC/fig4.png" class="" title="图4"><p>RBAC模型中的管理权限可以视作修改用户分配UA，权限分配PA和用户层级RH关系的能力。这样就可以实现用RBAC模型管理自己了。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Sandhu R S, Coyne E J, Feinstein H L, et al. Role-based access control models[J]. Computer, 1996, 29(2): 38-47.</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github Actions的基本使用</title>
      <link href="2020/05/09/HowToUseGithubActions/"/>
      <url>2020/05/09/HowToUseGithubActions/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在毕业设计时捣鼓了一会应用的持续集成(Continuous Integration, CI)和持续部署(~ Deployment, CD)，发现确实可以为自己省下很多力气：</p><ul><li>不用每次把代码通过 scp 或者 sftp 传到服务器上再 build 运行</li><li>也不用在本地交叉编译之后再传到服务器上</li></ul><p>之前在公司实习时所有的分支合并都会涉及到 CI 和 CD，当时为了让代码编译通过费了很多心思。虽然自己push代码的时候比较费劲，但是确确实实可以给应用的部署和可用性提供保障。</p><p>最近在看阮一峰大神的技术博客时偶然看到了<a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">Github Actions的入门基本教程</a>，发现 github 把 CI 脚本商品化、组件化放到 Marketplace 里供用户挑选和使用是一个非常不错的思路，让 github 的开源文化更加吸引人了。<br>我把上面那篇博客看完之后发现其实和 Travis CI 差不多，或者说其实所有的 CI 系统都差不多。抱着接触新事物的热情，我还去看了 github actions 的<a href="https://help.github.com/en/actions">官方文档</a>，下面对我所了解到的一些信息进行一个汇总。</p><span id="more"></span><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>Github actions 中有下面几个重要的概念，直接上原文档：</p><ul><li>Workflow</li><li>Jobs</li><li>Steps</li><li>Actions</li><li>Runner</li></ul><p><strong>1. Workflow</strong></p><p>工作流，工作流是由在 git 项目目录中的 .github/workflows/*.yml 文件定义的自动执行程序，可用于项目的构建、测试、打包、发布和部署。工作流又由一个或多个任务组成。</p><p><strong>2. Jobs</strong></p><p>任务，由一组步骤组成的单位。在工作流文件中可以定义任务如何运行：是并行执行还是顺序执行，以及以什么条件、什么顺序执行。在 Github-hosted 宿主机中，每一个任务都是在一个全新的虚拟环境中运行的。</p><p><strong>3. Steps</strong></p><p>每一个步骤都是一个单独的任务，可以执行 shell 命令或者是执行 action。一个任务里的所有步骤都是在相同的虚拟环境中执行的，使得不同的步骤可以通过文件系统共享信息。</p><p><strong>4. Actions</strong></p><p>翻译成动作有点太难听了，还是就叫 Action 吧。Action 是工作流中最小的可移植构建模块，你可以创建自己的 action，也可以使用社区里的 action，还可以对公开的 action 进行DIY。如果在工作流中使用，必须将 action 包含在步骤当中。</p><p><strong>5. Runner</strong></p><p>我把它叫做宿主机，宿主机分为两种：<strong>Github组装</strong>的和<strong>用户自组装</strong>的，他们存在着一些不同。宿主机等待用户的各种任务，一旦宿主机接受了任务，它会执行任务里的 actions，并把运行进度、日志和结果传给 github，用户可以在 actions 页面中查看这些信息。日志最多保存 30 天。</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>我的博客用的是 hexo 在 github pages 上构建的，博客所在位置是一个 repo，hexo 源码所在位置又是另一个 repo，我希望可以合并这两个 repo。或者退而求其次，我希望可以一次 commit 实现两个 repo 的 work done。<br>这就要求我：</p><ol><li>在源码 repo 处启用 actions 进行自动构建</li><li>将构建好的 repo 源码推送到 gh-pages repo 当中</li></ol><h3 id="在-Marketplace-中寻觅"><a href="#在-Marketplace-中寻觅" class="headerlink" title="在 Marketplace 中寻觅"></a>在 Marketplace 中寻觅</h3><p>我找了四个公开的社区 action 想进行使用，发现他们存在着各式各样的问题，难怪最多的一个项目也只有 21 个 star。</p><img src="/2020/05/09/HowToUseGithubActions/actions-4.png" class=""><h3 id="自己写工作流文件"><a href="#自己写工作流文件" class="headerlink" title="自己写工作流文件"></a>自己写工作流文件</h3><figure class="highlight yml"><figcaption><span>deploy.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">macos-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo</span> <span class="string">-g</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo</span> <span class="string">--save</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">hexo</span> <span class="string">g</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span> <span class="string">git</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">&quot;$EMAIL&quot;</span> <span class="string">&amp;&amp;</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">&quot;@NAME&quot;</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">EMAIL:</span> <span class="string">***</span></span><br><span class="line">          <span class="attr">NAME:</span> <span class="string">***</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">bind</span> <span class="string">github</span> <span class="string">remote</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          cd ./public</span></span><br><span class="line"><span class="string">          git init</span></span><br><span class="line"><span class="string">          git remote add origin https://$PERSONAL_TOKEN@github.com/$USERNAME/$USERNAME.github.io.git</span></span><br><span class="line"><span class="string"></span>        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">USERNAME:</span> <span class="string">fool-wang</span></span><br><span class="line">          <span class="attr">PERSONAL_TOKEN:</span> <span class="string">$</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">push</span> <span class="string">public</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          cd ./public</span></span><br><span class="line"><span class="string">          git add .</span></span><br><span class="line"><span class="string">          git commit -m &quot;auto deploy&quot;</span></span><br><span class="line"><span class="string">          git push -f origin master</span></span><br></pre></td></tr></table></figure><p>该工作流每次在我向 master 分支 push 代码时会触发，其中任务只有一个 <code>build</code>，我给他设定的名字也是 <code>Build</code>。<br><code>runs-on</code> 指定宿主机，在这里因为我的电脑是 macos 系统，所以我希望宿主机可以和我的电脑操作系统相同，所以选择了 <code>macos-latest</code>。<br>下面到了最最关键的步骤，一条一条地解释我做了什么（其实我也知道我的 <code>push -f</code> 很不优雅）：</p><ol><li>用了官方的 actions/checkout 来获取 repo 文件内容</li><li>用了官方的 actions/setup-node 来获取 node.js 运行时环境，其实主要就是需要 npm </li><li>运行 <code>npm install</code> 命令，为项目安装依赖</li><li>运行 <code>npm isntall hexo -g</code> 命令，为虚拟环境全局安装 hexo</li><li>运行 <code>npm install hexo --save</code> 命令，<strong>这一步我非常不解</strong>，但是如果没有这一步之后的步骤会报错</li><li>运行 <code>hexo g</code> 命令，生成 public 静态页面文件</li><li>配置 git 信息，通过环境变量传入我的邮箱地址和姓名信息</li><li>通过我的 personal access token 将博客 repo 绑定到生成的 public 文件夹远端</li><li>将 public 内的文件强制 push 到博客 repo 中，希望实现文件替换，也就是实现了部署过程</li></ol><h3 id="问题，大问题"><a href="#问题，大问题" class="headerlink" title="问题，大问题"></a>问题，大问题</h3><p>我发现宿主机内执行 <code>hexo g</code> 命令生成的文件与在本地电脑上生成的文件不一致，下面放几张图片：</p><img src="/2020/05/09/HowToUseGithubActions/local-g.png" class="" title="本地执行命令的生成的文件"> <p>上图是本地执行命令的生成的文件，下图是宿主机执行命令生成的文件，差别那么大就很离谱。</p><img src="/2020/05/09/HowToUseGithubActions/runner-g.png" class="" title="宿主机执行命令生成的文件"> <p>更离谱的是，博客 repo 上新部署的 <code>index.html</code> 文件内容是空。</p><img src="/2020/05/09/HowToUseGithubActions/generated-index.png" class="" title="更新的index.html文件"><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Github actions 的基本使用倒是已经掌握了，但是没办法实现博客源码自动构建和自动部署是有点困扰我，其中最神奇的问题就是 <code>hexo g</code> 生成的文件不同。不知道这个是我的打开方式错误，还是 github actions 环境有问题，还是 hexo 有问题。（最后一般都是我有问题）</p><p>Github actions 使用体验不错：</p><ol><li>在私有 repo 中也能够免费使用，真心觉得微软爸爸好</li><li>任务执行流程、日志和结果呈现十分友好</li><li>marketplace 的思路新奇，有许许多多开发者贡献代码，社区活跃度高，今后一定会变得更易用</li><li>构建失败后会有邮件提醒</li></ol><p>之后有时间还会继续深入了解 actions，争取把今天遇到的<a href="#问题，大问题">问题</a>给解决掉了。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p><code>hexo g</code> 命令生成的文件与在本地不同是因为…我漏掉了 <code>git clone</code> 模板库的步骤。第二天早上在 <code>hexo g</code> 之前补上了下载模板库的命令之后就正常工作了。<br>熬夜害人熬夜害人。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">GitHub Actions 入门教程</a></li><li><a href="https://help.github.com/en/actions">GitHub Action 官方文档</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> CI/CD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暑期的生活啊</title>
      <link href="2019/07/27/SummerVocation/"/>
      <url>2019/07/27/SummerVocation/</url>
      
        <content type="html"><![CDATA[<p>已经实习四周了，学院安排的实习期已经只剩下一周，但是直到这两天公司 Buddy 才给我安排了一个比较重要且连续的工作，让我有点左右为难：下周之后我到底还去不去呢？<br>之前四周的工作都是延续暑假前所做，多是一些较零散、不系统的碎活儿，其实这样的安排确实容易让人觉得枯燥无味，缺乏意义和价值。<br>“摸鱼”让我觉得内心有愧，如果要做自己的事情，为什么不回学校呢？</p><p>一周五天上班的日子让我分外珍惜周末的两天，因为周中下班回到宿舍已经快晚上8点了。这一晚上一般就会在我是要刷题，还是要看一些资讯，还是看B站这样的纠结之中过去，第二天有点后悔，但是回来之后又重复前一天的过程。究其根本，我觉得是因为我暑假想做的事情太多了。</p><blockquote><ol><li>实习</li><li>刷题</li><li>社工</li><li>上线小程序</li><li>写诸如这篇博客的东西</li><li>学习一些奇妙有趣的东西</li><li>blabla<br>（我觉得这个引用框好好看 </li></ol></blockquote><p>暑假我也更加清晰地认识了我的本质，我对不了解的事物很难提起兴趣，但是一旦喜欢某件事物之后就会开始不断的去了解去接触，就是这样一个循环。所以，我的生活好小啊。</p><p>看到手机上给自己的警言：“想的多了，做的就少”，这是高中时期自己给自己打气用的，希望自己能够心无旁骛地做自己该做的事情。<br>但是来到大学之后发现，没有明确的事情是那么的该做了，只有想做的事情比较明确，然而想做的事情太多，在纠结之中又会不经意掉入“想太多”的境地。<br>给自己定一个小目标吧，8月里把心沉下来，否则这个暑假将和去年暑假一样浮躁。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 胡思乱想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对Python,Golang和C++三种语言GC机制的简单调查</title>
      <link href="2019/06/12/GarbageCollectionSurvey/"/>
      <url>2019/06/12/GarbageCollectionSurvey/</url>
      
        <content type="html"><![CDATA[<h2 id="调查背景"><a href="#调查背景" class="headerlink" title="调查背景"></a>调查背景</h2><p>在公司一项任务是需要调用Python的SDK爬取相关的数据信息，数据的量在<code>10亿</code>这个量级，故不能够一下子得到结果。<br>这个程序运行十来天的可能性比较大，但是问题来了，程序跑过一阵子（1小时）之后爬取效率明显降低。<br>重启之后效率恢复，这就让人有点不爽了，本来数据量就多，用初速度爬取也需要十来天，这样一减速得爬到什么时候呢？<br>通过使用<code>top</code>工具，观察到爬虫脚本在运行过程中占用的内存从<strong>800MB</strong>上升到了<strong>1.4GB</strong>，速度也随内存占用量的上升而减慢。（图片来自MacOS的top，与程序的运行环境中的top不太一样）<br><img src="/2019/06/12/GarbageCollectionSurvey/top.png" class=""><br>我猜可能是内存泄漏了，各种查资料之后用python的<code>gc</code>和<code>objgraph</code>进行程序内存使用情况分析。<br>虽然针对于爬虫程序的分析无果，但是对GC机制有了一点兴趣，于是稍微了解了一下。</p><p><em>下文的 GC 既指 Garbage Collection， 也指 Garbage Collector。</em></p><p>接触Python一年多，Golang九个月，C++是大一时OOP课上教授的语言。其实都只是了解了皮毛，仅仅停留在“会用”这个层面。</p><span id="more"></span><h2 id="三种语言的GC机制"><a href="#三种语言的GC机制" class="headerlink" title="三种语言的GC机制"></a>三种语言的GC机制</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p><strong>1. 引用计数</strong><br>引用计数是一个很简单的实现方式，顾名思义：</p><ul><li>当一个对象被引用时，该对象的引用次数+1；</li><li>当引用这个对象的另一个对象被GC回收时，该对象的引用次数-1；<br>当GC监测到某对象的引用次数为0时则将该对象回收。</li></ul><p>但是这个方案无法解决<a href="https://baike.baidu.com/item/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>。</p><p><strong>2. 分代回收</strong><br>根据对象的存活周期不同将内存划分为新生代和老年代，存活周期短的为新生代，存活时间长的为老年代。<br>这样就可以根据每块内存的特点采用适当的收集算法。<br>在新生代对象中进行高频回收，在这次回收中没有被清理的对象移动到老年代对象中，老年代对象执行低频回收。</p><hr><p>上面是分代回收的定义，但是python没有简单的把对象分为<strong>新</strong>和<strong>老</strong>两个代际，而是分为了三代。每一代的对象达到了一定的数量（Threshold）之后GC会执行相应代际的对象回收，这个阈值是可以通过<code>gc</code>包进行设置的（<code>gc.set_threshold</code>），我调用<code>gc.get_threshold()</code>得到的结果是<code>(700, 10, 10)</code>。<br>不像引用计数，分代回收是可以进行控制的，甚至是关闭。如果觉得GC太频繁造成了性能瓶颈，那么可以提高阈值，降低GC频率。</p><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><p><strong>1. STW</strong><br>Golang的早期版本被无数人所诟病的问题之一就是它的GC，它用的是<strong>标记清除</strong>方法，也叫<strong>Stop The World(STW)</strong>。<br>该方法从根变量开始迭代，遍历所有被引用的对象，能够访问到的都标记上“被引用”；之后对没有标记过的对象进行清理，即回收不可达的对象。但是每次执行该算法都会让正常执行的<strong>内存负荷型程序</strong>出现明显的卡顿，这也是为什么该方法又被叫做STW的原因。</p><p><strong>2. 三色标记法</strong><br>该方法是对标记清除算法的改进，原理如下：</p><ol><li>起初所有对象都是白色的；</li><li>从根对象出发扫描所有可达对象，标记为灰色，放入待处理队列；</li><li>从队列取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色；</li><li>重复步骤3，直到灰色对象的队列为空。这时仍为白色的对象被当作垃圾回收。</li></ol><p>下面是演示图：</p><img src="/2019/06/12/GarbageCollectionSurvey/three-colors.gif" class=""><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><blockquote><p>In early programming languages, developers were responsible for all memory management in their programs. This meant before creating a list or an object, you first needed to allocate the memory for your variable. After you were done with your variable, you then needed to deallocate it to “free” that memory for other users.[2]</p></blockquote><p>C++就是<strong>early programming language</strong>，它较Python和Golang而言更偏底层和接近系统，将内存管理的工作交给程序员来完成。简而言之，就是没有GC（当然后来的C++11、14的新特性在此不提及）我之前写的某程序就因为想要释放整个数组的空间但是只写了<code>delete xxx</code>而不是<code>delete[] xxx</code>，仅释放了数组首位元素的空间，导致了剩余所有元素内存资源的浪费。<br>为了减轻程序员手动管理内存的痛苦，C++11推出的<a href="https://www.zhihu.com/question/20368881">智能指针</a>算是一个宝贝。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://segmentfault.com/a/1190000018161588">GO GC 垃圾回收机制</a></li><li><a href="https://stackify.com/python-garbage-collection/">Python Garbage Collection: What It Is and How It Works</a></li><li><a href="https://www.zhihu.com/question/20368881">如何理解智能指针？ - 知乎</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
