<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>记黑神话悟空云通关☁️</title>
      <link href="/2024/09/12/BlackMythWukong/"/>
      <url>/2024/09/12/BlackMythWukong/</url>
      
        <content type="html"><![CDATA[<h1 id="第一印象"><a href="#第一印象" class="headerlink" title="第一印象"></a>第一印象</h1><p>游戏科学在 2020 年 8 月放出黑神话悟空第一个实机演示视频以吸引游戏人才，“被迫”开始了对外宣传，到今年 2024 年 8 月 20 日正式发售，经历了四年的时间。这四年里，每年的 8 月 20 日都会释放出新的实机演示视频，赚足了单机游戏玩家的期待，其中自然也包括了我。</p><p>我在小学时期玩过很多游戏，各种各样的游戏都爱玩，仙剑奇侠传、波斯王子、英雄无敌、魔兽争霸、鬼泣等，对单机游戏是有足够好感的。中学之后娱乐时间变少后玩游戏的时间就趋近于零了，这个习惯一直延续到了大学毕业。在研究生阶段中期，多多少少受到些黑神话悟空的影响，我又开始断断续续接触了几款动作 RPG 游戏，例如古剑奇谭三、塞尔达传说、只狼、黑魂三、刺客信条·奥德赛等。</p><p>从释出的实机演示视频来看，黑悟空与近期接触过的只狼比较相似，战斗系统、画面风格、故事背景（都具有东方特色）等，而只狼是我玩过类似游戏里最喜欢的。黑悟空刺激的战斗系统搭配上西游记的故事背景，进一步拔高了我对黑悟空的期待。</p><img src="/2024/09/12/BlackMythWukong/tianzhending.jpg" class="" title="通往天真顶的道路一隅"><h1 id="八十一难之第零难：启动游戏"><a href="#八十一难之第零难：启动游戏" class="headerlink" title="八十一难之第零难：启动游戏"></a>八十一难之第零难：启动游戏</h1><p>我手头的设备是 MacBook Pro 和 Switch，并且 Switch 长时间吃灰，彻底沦为了有氧拳击启动器。同时因为没有业余时间打游戏的习惯，没有再增配主机，近期只对黑悟空这一款游戏感兴趣，不打算单单为了它添置设备，所以我开始摸索如何在 Mac 上运行黑悟空。</p><span id="more"></span><h2 id="Parallel-Desktop-❌"><a href="#Parallel-Desktop-❌" class="headerlink" title="Parallel Desktop ❌"></a>Parallel Desktop ❌</h2><p>Parallel Desktop 是 macOS 上一款虚拟机软件，用来在 Mac 上运行 Windows 系统。我在 Parallel Desktop 17 上安装了 Windows 11，下载和安装 Steam 后再下载了黑神话悟空，抱着期待启动游戏后发现在头箍加载进度条界面会闪退，无法正常运行。用兼容模式启动亦是如此。尝试在网上搜索解决方案无果，遂放弃该路径。</p><h2 id="CrossOver-❌"><a href="#CrossOver-❌" class="headerlink" title="CrossOver ❌"></a>CrossOver ❌</h2><p>CrossOver 是一款 macOS 上的软件，可以在 Mac 上运行 Windows 程序。我在 CrossOver 21 上安装了 Steam，再下载了黑神话悟空，启动游戏后仍然出现闪退的情况，查看网上的攻略后发现在 CrossOver 上运行黑神话悟空需要用到苹果的游戏转译工具包 <a href="https://developer.apple.com/games/game-porting-toolkit/">GPTK</a> (Game Porting Tool Kit) 2.0，而安装 GPTK 2.0 则需要 macOS 升级到最新的 15 beta 版本。因为踩过苹果产品操作系统测试版本的坑，觉得太过折腾遂也放弃了该方案。</p><h2 id="云游戏-✅"><a href="#云游戏-✅" class="headerlink" title="云游戏 ✅"></a>云游戏 ✅</h2><p>我打电话咨询了附近的网咖询问他们店里是否支持游玩黑神话悟空，他们都表示暂不支持，而且就算支持了我也比较担心网咖里二手烟的状况，遂作罢。</p><p>之前玩原神时曾尝试过米哈游的云游戏，体验尚可。黑神话悟空推出之后很多游戏厂商和云计算厂商都宣传了自己云游戏的服务，出于对游戏的期待和对云游戏当前发展状况的“信赖”，我开始了云游戏的尝试。如果是在 WeGame 上购买的黑神话悟空，可以尝试腾讯的 Start 云游戏；因为我是在 Steam 上购买的游戏，所以选择了网易云游戏。</p><p>云游戏简单来说就是把用户电脑当做视频播放器和指令发送器，游戏实际上是运行在云游戏厂商所管理的主机上的。只要网络速度足够快，用户指令和远端画面能够进行低时延地双向传输，游玩的体验能够做到与本地运行别无二致。</p><img src="/2024/09/12/BlackMythWukong/gaas.png" class="" title="云游戏原理示意"><p>抱着试一试的心态打开了网易云游戏上专门为黑悟空开设的游戏项目。打开之后实际上是一台 Windows 云电脑，上面安装了 Steam 和相应的加速器，Steam 中也预装了黑悟空，只需要登录自己的 Steam 账号即可开始游玩。我对什么样的显卡能得到什么样的画面效果不太了解，但我觉得网易云游戏上的“高配”机器运行黑悟空的体验还不错，所有的画面效果都能达到全高，600M 带宽的情况下大部分时候画面传输延迟在 20-30ms，仅需要约 2.4 元&#x2F;小时的价格对我而言是极其划算的，毕竟我只打算短期内玩这一款游戏。</p><h1 id="游玩体验"><a href="#游玩体验" class="headerlink" title="游玩体验"></a>游玩体验</h1><h2 id="初上手"><a href="#初上手" class="headerlink" title="初上手"></a>初上手</h2><p>开局扮演大圣大战天兵天将，跟二郎神单挑作为新手教程还是很不错的，相当于游戏初期让玩家接触到了后期会拥有的技能，让玩家心里有底并且对未来的角色的发展抱有期待。主角每一个技能的获取都有一段小故事，每获取一个技能都会让玩家有种成就感，让玩家探索欲望更强。</p><p>但因为没有内置的地图，在黑风山幽魂地图里我迷路了许久，上来的第一个 Boss 就是幽魂，在这里应该卡了有 1 小时，作为第一个 Boss 我觉得稍微有些难度，难怪网上好多玩家反映说这个 Boss 有些劝退。后来找到路先打了广智获取了变身技后，再来打它就变得很容易了。后来看了网上的攻略发现幽魂原来是可以先跳过不打的，确实多花费了不少时间…以至于后来我基本都是一边看着小黑盒的章节地图，一边探索和找寻各章的物品和首领。</p><img src="/2024/09/12/BlackMythWukong/before-dasheng.jpg" class="" title="在夕阳中迎战大圣残躯"><p>中间两天出门旅游只带了笔记本电脑，闲暇时候打开了云游戏，意外发现仍然能够正常游玩，锁定敌人目标之后完全不需要鼠标或者手柄就可以打败大部分体积较小的 Boss 了，在此向白衣秀士、金池长老、黑风大王、黑熊精等 Boss 表示抱歉，你们都是我用触控板打的。</p><p>前四章的战斗和剧情都酣畅淋漓，每一章都各有特色，黑风山的绿水青山、黄风岭的飞沙走石、小西天的天寒地冻、盘丝岭的盘丝错节…章节通关动画短片也质量不俗，其中第二章末书生南柯一梦后残害白狐的情节和第三章的故事紧密相连给了我较强的代入感。让本来基本只做主线任务的我在小西天不得不去把“不空”教训了一顿，为白狐伸张正义。</p><p>到了第五、六章的游玩体验就没有前四章那么好了。首先是剧情不是那么连贯和吸引人，其次是地图设计变成了线性推进，另外 Boss 的来历也没有过多介绍，见面就是战斗，而且有很多体型奇怪（急如风、碧水金睛兽、王灵官等）、攻击欲望极强（赤金战车、碧水金睛兽）的怪物，让我屈死了很多次…</p><p>但所有磨难带来的苦楚最终都在我凑齐大圣套装，走上天真顶时烟消云散了，击败杨戬、石猿和大圣残躯后观看不戴金箍的通关结局动画时心中激起了万般感慨，希望找寻大圣六根的旅途能够持续进行下去，希望能够在未来的拓展内容中探索更多章节，挑战更多首领。这种心情如同回到了四年前刚看到宣传动画时，又充满了同样的期待。</p><img src="/2024/09/12/BlackMythWukong/gold-band.jpg" class="" title="掉落水底的金箍"><h2 id="几场最喜欢的战斗"><a href="#几场最喜欢的战斗" class="headerlink" title="几场最喜欢的战斗"></a>几场最喜欢的战斗</h2><h3 id="虎先锋"><a href="#虎先锋" class="headerlink" title="虎先锋"></a>虎先锋</h3><p>虎先锋是我的闪避和识破老师，虽然有着庞大的身型和暴躁的脾气，但他还是很讲武德的，不管是拳打脚踢还是舞刀弄剑都富有节奏，练就了我闪避和识破的基本功，让我对阵后续的首领时更加游刃有余。作为早期试玩阶段就释放出的首领，它本身就自带了很多梗。虽然首发日当天很多玩家都被卡在第一章幽魂处，但猴头外卖使命必达，该上的课一节也不会落下。我遭遇虎先锋时我并没有身外身法这个技能，所以一对一地打败它的，给了我很强的正向反馈。</p><p>同时，虎先锋的战斗场景血池的设计也非常精美，十分符合虎先锋残忍暴戾的性格特点。角色在血池里奔跑、翻滚和打斗都会激起池面的波纹，让我有了更多的代入感。虚幻 5 引擎的实力在这些细节上体现出来了，同样让我觉得精美的场景还有后面的沙漠和雪地，人物行走时腿部和棍棒接触地面都会画出痕迹，效果逼真令人赞叹。</p><h3 id="黄眉"><a href="#黄眉" class="headerlink" title="黄眉"></a>黄眉</h3><p>“既见未来，为何不拜。”如果说跟虎先锋的战斗是磨砺了基本功，那么和黄眉的战斗则是一同演绎了一场对角戏。严格来说与黄眉的战斗有三个阶段，每个阶段的难度都不是很高，但游玩时可以从黄眉的台词中得到很多背景信息，了解到他是如何妖言惑众，蛊惑人心的。“信什么如来，不如我自己来”这样倒反天罡的话从他嘴里说出来却不觉得违和，因为他就是这样一个自视甚高、不知天高地厚的角色。</p><p>在第二阶段的人种袋里，天命人被蛊惑着击杀了赤尻马猴，随后索性被化身成了赤尻马猴。在黄眉的言语蛊惑下将沿途的陶俑全都“杀死”，变成了嗜血成性的恶人。想必黄眉座下弟子都是被同样的妖言所迷惑，变成了十恶不赦的人，这在第三章的过场动画中也得到了印证。</p><h3 id="杨戬"><a href="#杨戬" class="headerlink" title="杨戬"></a>杨戬</h3><p>击败杨戬是触发不带金箍结局的必要条件，在游戏里他为了帮助大圣封存六根的秘密找弥勒帮忙藏身于浮屠塔下的壁画中，梅山里万径人踪灭，杨戬整日只有与哮天犬作伴，不知持续了多少年，他的孤独之甚不得而知，天命人进入梅山来到他面前时他才会如此欢喜。他是大圣出生入死的挚友，“继承了大圣的意志”，在梅山中非常难熬。打其他的 Boss 时或多或少都有些逃课打法，但是打杨戬却没有太多的技巧。虽然他只有一条血条，但是却拥有三个阶段和可再生的护盾机制，拥有大量的招式和技能，近距离和远距离攻击招式都有且伤害不俗，这让他成了很多人难以通过的难关。</p><p>杨戬是人形 Boss 特点的集大成者，与他战斗虽说会遭遇很多次失败，但是最终战胜他时给人带来的喜悦是爆棚的，更别说法天象地里暴打四大天王的奖励关卡了。也正是因为杨戬的战斗风格特点众多，所以打法也有很多。因为之前在网上看到过芭蕉扇配合戳棍搅阵的简易组合打法，我没有认真研究这个打法，尝试过几次之后我就放弃了这个简易打法，转而采取了禁字法识破流。卡了两三个小时之后最终是把他打败了，不得不说杨戬的快慢刀比较多，而且哮天犬和飞剑的存在让专注识破的我变得捉襟见肘，最终以微弱的优势战胜了他，得知了这这场战斗是原来是他在为大圣考验天命人。</p><img src="/2024/09/12/BlackMythWukong/after-erlang.jpg" class="" title="击败杨戬之后他道出实情"><h2 id="再入轮回，更多惊喜"><a href="#再入轮回，更多惊喜" class="headerlink" title="再入轮回，更多惊喜"></a>再入轮回，更多惊喜</h2><p>到现在一周目双结局我大约花了 50 小时的游戏时间，人物等级是 90，当我觉得一周目有些“无聊”后，我选择了“再入轮回”。在新的游玩中发现了许多一周目没有的意外之喜，例如：</p><ol><li>得到了第六个根器“意”，其中一项能力是让“身外身法”变换出的毛猴能够跟随天命人一同使出某些强力招式，例如三四段棍势的蓄力重击，轻棍的最后一击等。</li><li>得到了与“身外身法”平行的另外一个法术“救命毫毛”，装备上这个法术后可以让天命人战败后立即复生，有些只狼战死复活的影子。</li><li>每个根器在二周目击败对应章节的关底首领之后也能得到对应的升级，最终的效果应该是能够把每个根器的每项能力都激活。</li><li>击败寅虎可以佩戴更多的珍玩，上线似乎是五个槽位。</li></ol><p>二周目在我看来是纯粹的“爽玩”，因为天命人的装备和能力得到了很大的提升，但是妖怪们的数值提升却不大，玩家得以在二周目为一周目收到的欺负出出恶气。例如一周目中卡了我 1 小时的幽魂在二周目中被身外身法的毛猴们四段棍势蓄力重击一棍击败，让心神得到了极大的愉悦～据说天命人的等级上限是 342，在棍法、法术、变身技能众多的基础之上，我认为至少完成三个轮回才能够差不多把大部分机制都体验到位。就我自己而言，我一周目完全使用劈棍的棍法，没有怎么接触过立棍和戳棍，算是一大遗憾吧。</p><h1 id="我的期许"><a href="#我的期许" class="headerlink" title="我的期许"></a>我的期许</h1><p>既然已经在一周目把两个结局都完成了，在二周目前三章发泄了一周目的郁闷之后也暂停继续玩下去的念头，安心等待后续拓展内容的发售了。对于拓展内容我有两个方面的期待，第一我认为灵吉菩萨背后还藏着不为人知的秘密，在斯哈哩国的剧情当中黄风大圣形象是正直、勇敢的，而到了主线剧情中则变得贪婪、邪恶，这些应该都是灵吉菩萨所为，我希望在接下来的拓展内容中能够将这条故事线继续深入挖掘下去；第二是蜘蛛精四妹，在击败盘丝洞右手虫之后她忧心忡忡地谈到希望看到山岭外的世界，并最终在黄花观被鹤仙人抓走，她和大圣、和天命人之间有什么纠葛，她的下落和生死状况究竟如何，我也希望在接下来的 DLC 中能够有所涉及。</p><p>纵使游戏中确实存在不少问题，例如空气墙、无地图设计、隐藏支线指引欠缺以及后两章剧情不够立体等，但依旧瑕不掩瑜，它在我这里的评分仍然是 10&#x2F;10，是我的 2024 年度游戏。</p><img src="/2024/09/12/BlackMythWukong/fight-to-the-heaven.jpg" class="" title="打上天庭"><!-- more --><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://developer.apple.com/games/game-porting-toolkit/">Game Porting Tool Kit</a></li><li><a href="https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&ved=2ahUKEwjMp-TvwMmIAxWUQPUHHXzELtAQFnoECCwQAQ&url=https://www-file.huawei.com/-/media/corporate/pdf/ilab/2019/cloud_game_whitepaper.pdf&usg=AOvVaw1dW7xQ3uCaKH9lgxWk1hCc&opi=89978449">云游戏白皮书 - 华为</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
            <tag> 云游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一起来做类型体操吧！😊</title>
      <link href="/2024/07/27/TypeGymnastics/"/>
      <url>/2024/07/27/TypeGymnastics/</url>
      
        <content type="html"><![CDATA[<h1 id="类型重要吗？"><a href="#类型重要吗？" class="headerlink" title="类型重要吗？"></a>类型重要吗？</h1><p>长话短说，类型很重要。</p><h2 id="类型的重要性"><a href="#类型的重要性" class="headerlink" title="类型的重要性"></a>类型的重要性</h2><h3 id="静态检查"><a href="#静态检查" class="headerlink" title="静态检查"></a>静态检查</h3><p>在编程中，类型往往是我们的第一道防线，它可以帮助我们在编译阶段就发现一些潜在的问题，避免一些不必要的错误。在过去，由于 JavaScript 是弱类型、解释型语言，所以在编译阶段无法发现一些类型相关的问题，这就需要我们在运行时进行一些类型检查，这样就会增加一些不必要的开销。而 TypeScript 则是由微软推出的、基于 JavaScript 的强类型语言，它可以在编译阶段就发现一些类型相关的问题，这样就可以避免一些不必要的错误。</p><p>当然也不是说用 JavaScript 就一定会出问题，但这<strong>要求编程者有更高的责任心和编程能力</strong>，能够在编码阶段就提前规避问题，但对于大型项目来说，这是不现实的。不要完全相信任何人的代码，即使是自己的代码。因为人是会犯错的，需要加以约束。在 Web 应用开发过程中，JavaScript 代码如果访问了一个空对象的字段则会导致异常，如果程序有限定错误边界，那么这个错误可能会被忽略，但是如果没有限定错误边界，那么这个错误可能会导致程序崩溃，也就是页面白屏。而使用 TypeScript 配合 IDE 的类型检查、其他静态检查工具，可以在编码、编译和代码合并时就发现并修复这些问题。</p><h3 id="类型即文档"><a href="#类型即文档" class="headerlink" title="类型即文档"></a>类型即文档</h3><p>另外，用弱类型语言编写的项目一旦涉及到多人协作（甚至是对于现在的自己和过去的自己来说也是如此），就会变得难以维护和协作，因为弱类型语言无法提供足够的信息，所以在多人协作时，很容易出现一些问题。而强类型语言则可以提供足够的信息，帮助我们更好地理解代码，提高代码的可维护性。所以我也认为“类型即文档”。</p><p>现在很多语言都有相关工具可以通过类型信息来生成文档，例如 openapi-generator、TypeDoc、JSDoc 等等，通过代码自动生成文档可以帮助开发者省去很多写文档的时间，同时也可以极大程度地提高交流效率。</p><span id="more"></span><h2 id="脚本语言的类型"><a href="#脚本语言的类型" class="headerlink" title="脚本语言的类型"></a>脚本语言的类型</h2><p>脚本语言通常以小巧方便为优势，在最初设计时没有考虑到类型检查的问题，所以在设计时没有引入类型系统，这样可以减少一些不必要的开销。但越来越多人用脚本语言来开发大型项目，这时就需要引入类型系统来帮助我们更好地维护代码。例如纯粹的 JavaScript 有 JSDoc 和 Flow、Python 有 MyPy、Ruby 有 Sorbet、PHP 有 Hack、Lua 有 Typed Lua 等等。</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>在纯粹的 JavaScript 中，我们可以使用 JSDoc 来对函数的参数和返回值进行类型注解，这样可以起到类型标注的作用，这无法起到类型检查的作用，但是可以使得部分的 IDE 在编码时提供更好的提示。</p><figure class="highlight javascript"><figcaption><span>test-js-docs.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">a</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">b</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Facebook (现在的 Meta) 的 Flow 是一个 JavaScript 静态类型检查工具，它有着和 TypeScript 类似的功能（甚至是极其类似的语法，TypeScript 的语法设计应该很大程度上借鉴了 Flow 的设计），可以在编码阶段就发现一些类型相关的问题。</p><figure class="highlight javascript"><figcaption><span>test-flow.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: number, b: number</span>): number &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>Python 3.5 开始引入了类型提示，可以通过 <code>typing</code> 模块来对函数的参数和返回值进行类型注解，这样可以起到类型标注的作用，这无法起到类型检查的作用，但是可以使得部分的 IDE 在编码时提供更好的提示。</p><figure class="highlight python"><figcaption><span>python-typing.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">concat</span>(<span class="params">a: <span class="type">List</span>[<span class="built_in">int</span>], b: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure><p>Python 中的类型系统要比 TypeScript 弱一些，只能起到标注和提示的作用，无法进行类型检查，但是可以通过一些工具来进行类型检查，例如 <code>mypy</code>。我极为乐于看到的是，目前有些 Python Web 框架已经在利用类型提示来生成文档，例如 FastAPI。</p><h1 id="什么是类型体操？"><a href="#什么是类型体操？" class="headerlink" title="什么是类型体操？"></a>什么是类型体操？</h1><p>在 TypeScript 内置的类型中，有很多工具类型，比如 <code>Partial</code>、<code>Required</code>、<code>Readonly</code>、<code>Record</code>、<code>ReturnType</code>、<code>Parameters</code> 等等，这些工具类型可以帮助我们更好地操作类型。所谓类型体操，就是仅基于 TypeScript 的各种内置的类型和类型操作符如<code>infer</code>, <code>typeof</code>, <code>keyof</code>, <code>extends</code> 等来实现一些工具类型，使用 TypeScript 的类型推导能力来运行具体的逻辑、消除 IDE 的警告、提高代码的可读性等。Python 的类型体操也是类似的，只不过 Python 的系统类型较弱，不能够实现像 TypeScript 那样灵活的类型操作。</p><h2 id="类型挑战题库"><a href="#类型挑战题库" class="headerlink" title="类型挑战题库"></a>类型挑战题库</h2><p>说到这里不得不提一下 <a href="https://github.com/type-challenges/type-challenges">type-challenges</a> 这个 Github 仓库，其中有很多关于 TypeScript 的类型挑战，有需要时可以进行检索查阅，有空闲时间的话也可以到其中进行解题挑战，帮助自己更好的掌握 TypeScript 中的类型系统和编写类型的技巧。推荐在完整了解和使用过 TypeScript 中的基础工具类型和类型操作符之后再上手进行挑战，不然会有较高难度。当然最好不要过于钻牛角尖，毕竟类型体操有千千万万种题面，且为了设计成挑战题目，有些需求是不切实际的，所以不要过于纠结于题目的细节（有些题目为了难而难），而是要关注练习和学习的初衷。</p><h2 id="一些例子和个人理解"><a href="#一些例子和个人理解" class="headerlink" title="一些例子和个人理解"></a>一些例子和个人理解</h2><h3 id="DeepReadonly"><a href="#DeepReadonly" class="headerlink" title="DeepReadonly"></a><code>DeepReadonly</code></h3><p><a href="https://tsch.js.org/9">这道题目</a>的要求是实现一个 <code>DeepReadonly</code> 工具类型，使得所有的属性都变成只读的，包括嵌套的属性。其中有个测试用例是这样的：</p><figure class="highlight typescript"><figcaption><span>deep-readonly-case.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">X1</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="function">() =&gt;</span> <span class="number">22</span>;</span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">c</span>: &#123;</span><br><span class="line">    <span class="attr">d</span>: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="attr">e</span>: &#123;</span><br><span class="line">      <span class="attr">g</span>: &#123;</span><br><span class="line">        <span class="attr">h</span>: &#123;</span><br><span class="line">          <span class="attr">i</span>: <span class="literal">true</span>;</span><br><span class="line">          <span class="attr">j</span>: <span class="string">&quot;string&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="attr">k</span>: <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="attr">l</span>: [</span><br><span class="line">        <span class="string">&quot;hi&quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">m</span>: [<span class="string">&quot;hey&quot;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      ];</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Expected1</span> = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">a</span>: <span class="function">() =&gt;</span> <span class="number">22</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">c</span>: &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">d</span>: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">e</span>: &#123;</span><br><span class="line">      <span class="keyword">readonly</span> <span class="attr">g</span>: &#123;</span><br><span class="line">        <span class="keyword">readonly</span> <span class="attr">h</span>: &#123;</span><br><span class="line">          <span class="keyword">readonly</span> <span class="attr">i</span>: <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">readonly</span> <span class="attr">j</span>: <span class="string">&quot;string&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">readonly</span> <span class="attr">k</span>: <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">readonly</span> <span class="attr">l</span>: <span class="keyword">readonly</span> [</span><br><span class="line">        <span class="string">&quot;hi&quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">readonly</span> <span class="attr">m</span>: <span class="keyword">readonly</span> [<span class="string">&quot;hey&quot;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      ];</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cases = [<span class="title class_">Expect</span>&lt;<span class="title class_">Equal</span>&lt;<span class="title class_">DeepReadonly</span>&lt;<span class="variable constant_">X1</span>&gt;, <span class="title class_">Expected1</span>&gt;&gt;];</span><br></pre></td></tr></table></figure><p>如果仅仅是递归地将属性变成只读的话，那么这个题目就太简单了，但是这个题目的难点在于如何处理数组，因为数组是一个特殊的对象，它的属性是数字，而且数组是可变的，所以我们需要将数组的属性也变成只读的，同时也需要将数组的元素变成只读的。这个题目能通过测试用例的解法是这样的，首先判断一个类型是否拓展了 Function，如果是的话就直接返回原类型，否则就递归地将其中的属性变成只读的。</p><figure class="highlight typescript"><figcaption><span>deep-readonly.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 能通过测试用例的解法</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DeepReadonly</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">Function</span></span><br><span class="line">  ? T</span><br><span class="line">  : &#123; <span class="keyword">readonly</span> [k <span class="keyword">in</span> keyof T]: <span class="title class_">DeepReadonly</span>&lt;T[k]&gt; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我认为正确的写法</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DeepReadonly</span>&lt;T&gt; = &#123; <span class="keyword">readonly</span> [k <span class="keyword">in</span> keyof T]: <span class="title class_">DeepReadonly</span>&lt;T[k]&gt; &#125;;</span><br></pre></td></tr></table></figure><p>但我认为这个解法有问题，例如上面的用例片段中 <code>X1[&#39;b&#39;]</code> 是一个 string 类型的字段，我判断 <code>X1[&#39;b&#39;]</code> 是否是 Function 类型时会返回 false，但因为这个写法通过了测试用例，说明在执行判断时 <code>DeepReadonly&lt;X1[&#39;b&#39;]&gt;</code> &#x3D; <code>DeepReadonly&lt;string&gt;</code> &#x3D; <code>string</code>，这是不对的，因为 <code>string extends Function</code> 的结果为 false，就不应该会返回原来的类型。但如果去掉了这个终止条件的判断，仅通过递归的调用，如何达到终止条件呢？</p><p>原来 <code>never</code> 类型是 TypeScript 中的底类型，它是所有类型的子类型，所以 <code>never</code> 类型可以赋值给任何类型，任何类型都无法赋值给 never。所以我们可以通过 <code>never</code> 类型来终止递归的调用，这样就可以达到终止条件。</p><figure class="highlight typescript"><figcaption><span>recursive-exit-point.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cases = [</span><br><span class="line">  <span class="title class_">Expect</span>&lt;<span class="title class_">Equal</span>&lt;<span class="title class_">DeepReadonly</span>&lt;<span class="built_in">never</span>&gt;, <span class="built_in">never</span>&gt;&gt; </span><br><span class="line">  <span class="comment">// 该断言是通过的，任何涉及 never 的类型都会相等，这也是隐藏的递归终止条件</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="TupleToObject"><a href="#TupleToObject" class="headerlink" title="TupleToObject"></a><code>TupleToObject</code></h3><p><a href="https://tsch.js.org/11">这道题目</a>要求将元组转换为键值相等的对象，解法中利用了元组可以通过数字下标来访问属性的特点:</p><figure class="highlight typescript"><figcaption><span>tuple-to-object.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TupleToObject</span>&lt;T <span class="keyword">extends</span> <span class="keyword">readonly</span> (keyof <span class="built_in">any</span>)[]&gt; = &#123;</span><br><span class="line">  [k <span class="keyword">in</span> T[<span class="built_in">number</span>]]: k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tuple = <span class="keyword">readonly</span> (keyof <span class="built_in">any</span>)[]; <span class="comment">// readonly (keyof any)[] 可以表示任何类型的元组</span></span><br><span class="line"><span class="keyword">type</span> tuple = <span class="keyword">readonly</span> (<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">symbol</span>)[];</span><br></pre></td></tr></table></figure><h3 id="MyAwaited"><a href="#MyAwaited" class="headerlink" title="MyAwaited"></a><code>MyAwaited</code></h3><p><a href="https://tsch.js.org/189">这道题目</a>要求实现一个异步函数递归等待的工具类，这个题目的难点在于如何递归地等待 PromiseLike 类型的结果，通过 <code>infer</code> 关键字来获取 PromiseLike 的结果类型，然后判断这个结果类型是否 也是 PromiseLike 类型，如果是的话就继续递归地调用 <code>MyAwaited</code>，否则就返回结果类型。在 extends 类型判断语句中能够使用 <code>infer</code> 关键字来获取类型，这是 TypeScript 中的一个高级特性，能够玩出很多花样。</p><figure class="highlight typescript"><figcaption><span>my-awaited.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyAwaited</span>&lt;T <span class="keyword">extends</span> <span class="title class_">PromiseLike</span>&lt;<span class="built_in">any</span>&gt;&gt; = T <span class="keyword">extends</span> <span class="title class_">PromiseLike</span>&lt;infer U&gt;</span><br><span class="line">  ? U <span class="keyword">extends</span> <span class="title class_">PromiseLike</span>&lt;<span class="built_in">any</span>&gt;</span><br><span class="line">    ? <span class="title class_">MyAwaited</span>&lt;U&gt;</span><br><span class="line">    : U</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h3 id="Chainable"><a href="#Chainable" class="headerlink" title="Chainable"></a><code>Chainable</code></h3><p><a href="https://tsch.js.org/12">这道题目</a>要求实现一个链式调用设置对象参数的工具类，而且要求不能重复设置相同的键。题目的难点在于如何判断一个键是否已经被设置过，通过 <code>K extends keyof T ? never : K</code> 可以判断一个键是否已经被设置过，如果已经被设置过就返回 <code>never</code> 类型（并导致调用时报错），否则就返回原本的键类型。</p><figure class="highlight typescript"><figcaption><span>chainable.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Chainable</span>&lt;T = &#123;&#125;&gt; = &#123;</span><br><span class="line">  <span class="attr">option</span>: &lt;K <span class="keyword">extends</span> <span class="built_in">string</span>, V&gt;<span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    key: K <span class="keyword">extends</span> keyof T ? <span class="built_in">never</span> : K,</span></span></span><br><span class="line"><span class="params"><span class="function">    value: V</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> <span class="title class_">Chainable</span>&lt;<span class="title class_">Omit</span>&lt;T, K&gt; &amp; <span class="title class_">Record</span>&lt;K, V&gt;&gt;;</span><br><span class="line">  <span class="attr">get</span>: <span class="function">() =&gt;</span> T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="项目中的案例"><a href="#项目中的案例" class="headerlink" title="项目中的案例"></a>项目中的案例</h1><p>类型体操并不完全是为了脑筋急转弯，它在实际的项目中也是可以发挥作用的，适当地进行类型编程可以在适当的场合节省较多的工作量。</p><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>在我参与的项目几个月前引入 OpenAPI Generator <a href="https://openapi-generator.tech/docs/generators/typescript-axios/">typescript-axios</a> 后涉及了 API 请求响应类型的变化。具体来说生成的客户端代码中 Axios 请求方法返回的是 AxiosResponse，而原有代码中的请求方法返回的都是 Promise。这一转变要求在所有前端组件中都需要修改处理 API 返回结果的逻辑，这是一个非常繁琐的工作，因为项目中有很多组件，而且每个组件中都有很多请求方法，如果工作量过大会导致协作者不愿意引入新的工具 OpenAPI Generator。所以我想到了通过包装一个 TypeScript 转换器来解决这个问题。既要保证生成的 API 工厂类型能够在 IDE 中得到正确的代码提示，又要保证转换后的代码能够正确地将返回结果从 AxiosResponse 转换为 Promise 类型。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight typescript"><figcaption><span>wrapper.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ClusterApiFactory</span>, <span class="title class_">Configuration</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./generated/index&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = <span class="keyword">new</span> <span class="title class_">Configuration</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> factoryFunction&lt;T&gt; = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  configuration?: Configuration | <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  basePath?: <span class="built_in">string</span> | <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  axios?: AxiosInstance | <span class="literal">undefined</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapper = &lt;T&gt;(</span><br><span class="line">  <span class="attr">f</span>: factoryFunction&lt;T&gt;,</span><br><span class="line">  ...<span class="attr">args</span>: <span class="title class_">Parameters</span>&lt;factoryFunction&lt;T&gt;&gt;</span><br><span class="line">): <span class="title class_">PromiseWrapperType</span>&lt;T&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">f</span>(...args) <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PromiseWrapperType</span>&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: T[K] <span class="keyword">extends</span> (...<span class="attr">args</span>: infer P) =&gt; <span class="title class_">AxiosPromise</span>&lt;infer R&gt;</span><br><span class="line">    ? <span class="function">(<span class="params">...args: P</span>) =&gt;</span> <span class="title class_">Promise</span>&lt;R&gt;</span><br><span class="line">    : <span class="built_in">never</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> clusterApi = <span class="title function_">wrapper</span>(<span class="title class_">ClusterApiFactory</span>, config);</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.typescriptlang.org/docs/handbook/intro.html">TypeScript Handbook</a></li><li><a href="https://github.com/type-challenges/type-challenges">Type Challenges</a></li><li><a href="https://stackoverflow.com/questions/68693054/what-is-extends-never-used-for/68693367">What is “extends never” used for</a></li><li><a href="https://github.com/OpenAPITools/openapi-generator">OpenAPI Generator</a></li><li><a href="https://fastapi.tiangolo.com/">FastAPI</a></li></ul><!-- more -->]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> Python </tag>
            
            <tag> Docs </tag>
            
            <tag> Coding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rFTP - 用 Rust 实现简单的 FTP Server (2)</title>
      <link href="/2024/06/22/RFTP-2/"/>
      <url>/2024/06/22/RFTP-2/</url>
      
        <content type="html"><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>在<a href="/2023/01/20/RFTP-1">上一篇文章</a>中，我讲述了我为什么选择 Rust 作为学习计算机底层知识的工具，一些 Rust 的基础知识和我当时所遇到的困难。在这篇又是属于<strong>目标回收</strong>的文章中，我将介绍最近的进展、Rust 开发的体验和下一步的计划。总的来说，用 Rust 写项目体验尚可，通过与编译器博弈而最终通过“考试”后，自己对 Rust 的理解也有了些许提升。</p><h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><p>在 Rust 中，异步编程是通过 <code>Future</code> 特征和 <code>async/await</code> 语法糖来实现的。<code>Future</code> 是 Rust 中的异步编程的基础，它代表了一个异步计算的结果或者异步任务的“承诺”，可以通过 <code>poll</code> 方法来获取计算的结果。<code>async/await</code> 语法糖则是为了让异步编程更加友好，通过 <code>async</code> 关键字来定义异步函数，通过 <code>await</code> 关键字来等待异步计算的结果。</p><p>越来越多的语言采纳异步编程机制，比如 Python 的 <code>asyncio</code>、JavaScript 的 <code>Promise</code>（或者是同样的 <code>async/await</code>）、Golang 的 <code>goroutine</code> 等等。异步编程的优势在于可以提高程序的并发性能，因为异步编程可以让程序在等待 I&#x2F;O 操作的时候不阻塞，可以继续执行其他任务。Rust 的 Tokio 是一个基于 <code>Future</code> 的异步编程框架，它提供了很多异步编程的工具，比如 <code>tokio::spawn</code>、<code>tokio::net::TcpStream</code> 等等。</p><span id="more"></span><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>可以看到，<code>Future</code> 是一个特征，它有一个关联类型 <code>Output</code>，代表了异步计算的结果类型。<code>Future</code> 只有一个 <code>poll</code> 方法，这个方法接受一个 <code>Pin&lt;&amp;mut Self&gt;</code> 类型的参数，返回一个 <code>Poll&lt;Self::Output&gt;</code> 类型的结果。<code>Poll</code> 是一个枚举类型，它有两个成员 <code>Ready(T)</code> 和 <code>Pending</code>，分别代表了异步计算已经完成和异步计算还在进行中。</p><figure class="highlight rust"><figcaption><span>future_poll.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Future</span> &#123;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Poll</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_ invoke__">Ready</span>(T),</span><br><span class="line">  Pending,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>async</code> 关键字修饰函数后，正常的函数将转化为一个异步函数，调用后返回一个实现了 Future 特征的类型，这个类型可以通过 <code>await</code> 关键字来等待异步计算的结果，而 <code>await</code> 关键字则会调用 <code>poll</code> 方法来获取计算的结果。在 poll 方法中还可以通过 <code>cx.waker().wake_by_ref()</code> 来唤醒任务，这样可以让任务在等待 I&#x2F;O 操作时交出控制权而不阻塞主流程，在 I&#x2F;O 操作完成时唤醒主流程继续执行。这样等待和唤醒的机制能够精确地控制任务的执行。</p><h2 id="Rust-异步编程与其他语言的异同"><a href="#Rust-异步编程与其他语言的异同" class="headerlink" title="Rust 异步编程与其他语言的异同"></a>Rust 异步编程与其他语言的异同</h2><h3 id="惰性求值-Evaluation"><a href="#惰性求值-Evaluation" class="headerlink" title="惰性求值 (Evaluation)"></a>惰性求值 (Evaluation)</h3><p>Rust 的异步编程和 Python 的 <code>asyncio</code> 较为相似，调用 async 关键字修饰的函数后会返回一个“执行器”，直到调用 <code>.await</code> 后才开始执行异步函数和获取结果。Python 的 asyncio 也是这样的，调用 <code>async</code> 修饰的函数后会返回一个协程对象，需要调用 <code>await</code> 来执行协程。这种实现是惰性求值的风格，只有在需要的时候才执行任务，有助于不必要的资源消耗和任务调度，可以更灵活地控制异步任务的执行时机和顺序（例如通过 <code>waker</code> 控制何时唤醒）。</p><h3 id="立即求值"><a href="#立即求值" class="headerlink" title="立即求值"></a>立即求值</h3><p>JavaScript 和 Golang 的异步编程风格则属于立即求值，即调用异步函数后立即执行其中的语句，这种风格更加直观、符合直觉。而它们的具体方案也有所差异：</p><ul><li>JavaScript 中的异步函数执行完成后是返回一个 <code>Promise</code> 对象，通过对其调用 <code>.then()</code> 或者 <code>.catch()</code> 方法可以获取其执行状态和结果，JavaScript 的实现就相当于调用异步函数后返回一个标识符，用以检查异步任务完成情况；</li><li>Go 的异步函数 <code>go func()</code> 就显得更加简单粗暴了，没有返回任何标识符，开发者不需要知道协程本身的信息，“任务能跑就行”。当要从协程中返回信息或者是要控制协程的状态时则需要通过传递 <code>channel</code> 进行通信的方式来完成。这可能也是 Go 简单哲学的一处体现吧。</li></ul><blockquote><p>Do not communicate by sharing memory; instead, share memory by communicating.<br>– from <a href="https://go.dev/blog/codelab-share">Andrew Gerrand</a></p></blockquote><figure class="highlight javascript"><figcaption><span>proms.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> proms = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi, I&#x27;m out of setTimeout!&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi, I&#x27;m in setTimeout!&quot;</span>);</span><br><span class="line">      <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi, I&#x27;m on the root.&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> proms;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi, everything is done!&quot;</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run this script by node proms.js, you will get:</span></span><br><span class="line"><span class="comment">// Hi, I&#x27;m out of setTimeout!</span></span><br><span class="line"><span class="comment">// Hi, I&#x27;m on the root.</span></span><br><span class="line"><span class="comment">// Hi, I&#x27;m in setTimeout!</span></span><br><span class="line"><span class="comment">// Hi, everything is done!</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><figcaption><span>goroutines.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Simple task</span></span><br><span class="line">  &#125;()</span><br><span class="line">  complexTask := <span class="function"><span class="keyword">func</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, results <span class="keyword">chan</span> Result)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-done:</span><br><span class="line">      <span class="comment">// Clean and exit</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Do something</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// go func() has no return value.</span></span><br><span class="line">  <span class="keyword">go</span> complexTask(done, results)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>Rust 的错误处理机制是通过 <code>Result</code> 和 <code>Option</code> 类型来实现的，<code>Result</code> 代表了可能出现错误的结果，<code>Option</code> 代表了可能为空的结果。<code>Result</code> 和 <code>Option</code> 都是枚举类型，<code>Result</code> 有两个成员 <code>Ok(T)</code> 和 <code>Err(E)</code>，<code>Option</code> 有两个成员 <code>Some(T)</code> 和 <code>None</code>。虽然和 Go 一样是通过返回值而非 <code>try-catch</code> 来传递错误信息，但是 Rust 的错误处理更加严谨细致，配合模式匹配和 <code>?</code> 操作符可以更方便地处理错误。</p><figure class="highlight rust"><figcaption><span>result_option.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">  <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">  <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">  <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">helper_option</span>() <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">helper_result</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">process</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// Option.ok_or() will return the value if it is Some(T), otherwise return the error message.</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">value</span> = <span class="title function_ invoke__">helper_option</span>().<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;No value found&quot;</span>)?;</span><br><span class="line">  <span class="comment">// Result? will return the value if it is Ok(T), otherwise return the error message.</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">helper_result</span>()?;</span><br><span class="line">  <span class="title function_ invoke__">Ok</span>(value + result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Option 或者 Result 的值为 None 或者 Err 时，可以通过 <code>?</code> 操作符来提前返回错误，这样可以减少代码的嵌套和提高代码的可读性。而且不必像 C++、Java 一样在 catch 语句块中单独处理错误信息，打乱原本代码的逻辑结构。</p><p>实话说，因为之前写过一段时间的 TypeScript，对其中的 <code>?</code> 操作符比较有好感的，在 Rust 中使用这样的操作符也是一种愉悦的体验。这是 Rust 错误处理相对 Go 的一个重大优势。在 Go 里面，错误通过返回值来传递，而且没有类似 <code>?</code> 操作符这样的语法糖，所以在处理错误时需要显式地检查错误并返回，这样会导致代码的嵌套和可读性下降。而且嵌套盘空也是影响代码可读性的一个重要问题。</p><figure class="highlight go"><figcaption><span>nested_nil.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">  A *A</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> C <span class="keyword">struct</span> &#123;</span><br><span class="line">  B *B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *C)</span></span> DoSomething() <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> c.B == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;B is nil&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> c.B.A == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;A is nil&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Do something with c.B.A</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="FTP-服务器"><a href="#FTP-服务器" class="headerlink" title="FTP 服务器"></a>FTP 服务器</h1><p>在 Rust 中实现一个简单的 FTP 服务器是一个不错的练习，可以通过实现 FTP 协议来学习网络编程和异步编程。FTP 协议是一个比较古老的协议，它是基于文本的协议，通过控制连接和数据连接来实现文件的上传和下载。FTP 服务器的实现可以分为两个部分，一个是控制连接的处理，另一个是数据连接的处理。控制连接用于接收客户端的命令和发送响应，数据连接用于传输文件数据。</p><h2 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h2><p>前面也提到过，我使用了 Rust 中的异步编程框架 Tokio 来实现 FTP 服务器。通过 <code>Tokio::net::TcpListener</code> 绑定通过参数指定的主机和端口后，通过 <code>listener.accept()</code> 方法来接受客户端的连接请求，返回一个 <code>tokio::net::TcpStream</code> 类型的流。随后通过 <code>tokio::spawn</code> 方法来创建一个异步任务 <code>handle()</code> 来专门处理来自该客户端的连接请求，这样可以让主线程继续接受其他客户端的连接请求。</p><p>在 <code>handle()</code> 中，首先会将 <code>TcpStream</code> 通过 <code>into_split()</code> 方法分割为读取流和写入流，然后通过读取流来接收客户端的命令，通过写入流来发送响应。在处理命令的过程中，会根据命令的类型来分发调用不同的处理函数，比如 <code>USER</code> 命令会调用 <code>user()</code> 函数，<code>LIST</code> 命令会调用 <code>list()</code> 函数等等。在我最初的实现中，在处理完完成一条命令后，服务器才会通过 <code>writer.write_all()</code> 方法来发送响应，然后继续等待下一个命令。但这种实现方式会在传输数据时阻塞主线程，导致中断传输命令 <code>ABOR</code> 无法被及时处理。于是再后来的优化里，我将发送响应的操作也放到了异步任务中，这样可以让主线程继续接受其他客户端的连接请求，而不会被阻塞。</p><p>下面的代码片段就是这个 FTP 处理客户端请求的主要流程。</p><figure class="highlight rust"><figcaption><span>ftp_server.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">listen</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>((socket, addr)) = <span class="keyword">self</span>.listener.<span class="title function_ invoke__">lock</span>().<span class="keyword">await</span>.<span class="title function_ invoke__">accept</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">        <span class="comment">// 收到客户端连接请求后，创建一个异步任务来处理</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">shared_self</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">          shared_self.<span class="title function_ invoke__">handle</span>(socket, addr).<span class="keyword">await</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">handle</span>(&amp;<span class="keyword">self</span>, socket: TcpStream, addr: SocketAddr) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user_map</span> = <span class="keyword">self</span>.user_map.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="comment">// 将 TcpStream 分割为读取流和写入流</span></span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> reader, <span class="keyword">mut</span> writer) = socket.<span class="title function_ invoke__">into_split</span>();</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 检查用户是否已经登录，如果是新用户，则发送欢迎信息</span></span><br><span class="line">      <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user_map_locked</span> = user_map.<span class="title function_ invoke__">lock</span>().<span class="keyword">await</span>;</span><br><span class="line">      <span class="keyword">if</span> !user_map_locked.<span class="title function_ invoke__">contains_key</span>(&amp;addr) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = writer</span><br><span class="line">          .<span class="title function_ invoke__">write_all</span>(<span class="string">b&quot;220 xxx.xxx.xxx.xxx FTP server ready.\r\n&quot;</span>)</span><br><span class="line">          .<span class="keyword">await</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个 Arc&lt;Mutex&gt; 来保护写入流，避免多个异步任务同时写入</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">writer_guard</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(writer));</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = <span class="built_in">vec!</span>[<span class="number">0</span>; <span class="number">2048</span>];</span><br><span class="line">      <span class="comment">// 读取客户端发送的命令</span></span><br><span class="line">      <span class="keyword">let</span> <span class="variable">req</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">n</span> = <span class="keyword">match</span> reader.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buf).<span class="keyword">await</span> &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from_utf8_lossy</span>(&amp;buf[..n]).<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// 分发命令并进行错误处理</span></span><br><span class="line">      tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cloned</span> = cloned_writer.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        cloned_self.<span class="title function_ invoke__">dispatch</span>(cloned_writer.<span class="title function_ invoke__">clone</span>(), cmd, user).<span class="keyword">await</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要涉及的结构体"><a href="#主要涉及的结构体" class="headerlink" title="主要涉及的结构体"></a>主要涉及的结构体</h2><h3 id="服务器-Server"><a href="#服务器-Server" class="headerlink" title="服务器 Server"></a>服务器 Server</h3><p>服务器结构体 <code>Server</code> 很简单，只包含了服务器的地址、端口、根目录、监听器、用户映射等信息。其中监听器是一个 <code>Arc&lt;TcpListener&gt;</code> 类型的字段，给 TcpListener 加上了 Clone 特征以满足在 Future 间传递的要求。用户映射是一个 <code>Arc&lt;Mutex&lt;HashMap&lt;SocketAddr, Arc&lt;Mutex&lt;User&gt;&gt;&gt;&gt;&gt;</code> 类型的字段，用于保存用户的信息。实现了 <code>new()</code> <code>listen()</code> <code>handle()</code> <code>dispatch()</code> 等方法和 <code>FtpServer</code> 特征。</p><figure class="highlight rust"><figcaption><span>server.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">  <span class="keyword">pub</span> host: <span class="type">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> port: <span class="type">u16</span>,</span><br><span class="line">  <span class="keyword">pub</span> root: <span class="type">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> listener: Arc&lt;TcpListener&gt;,</span><br><span class="line">  <span class="keyword">pub</span> user_map: Arc&lt;Mutex&lt;HashMap&lt;SocketAddr, Arc&lt;Mutex&lt;User&gt;&gt;&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用户-User"><a href="#用户-User" class="headerlink" title="用户 User"></a>用户 User</h3><p>用户结构体 <code>User</code> 用于保存用户的信息，包括用户名、密码、当前目录、数据连接等信息。用户结构体还包括了一个 <code>PathGuard</code> 类型的字段，用于保护用户的当前目录，避免用户越权访问文件系统。用户结构体还包括了一个 <code>TransferSession</code> 类型的字段，用于保存数据连接的信息，包括数据连接的类型（主动或被动）、数据连接的地址等。</p><figure class="highlight rust"><figcaption><span>user.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">  <span class="keyword">pub</span> status: UserStatus,</span><br><span class="line">  <span class="keyword">pub</span> addr: SocketAddr,</span><br><span class="line">  <span class="keyword">pub</span> session: <span class="type">Option</span>&lt;Arc&lt;Mutex&lt;TransferSession&gt;&gt;&gt;,</span><br><span class="line">  <span class="keyword">pub</span> trans_type: TransferType, <span class="comment">// ASCII or Binary</span></span><br><span class="line"></span><br><span class="line">  path: PathGuard,              <span class="comment">// 保护 PWD 的工具类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传输会话-TransferSession"><a href="#传输会话-TransferSession" class="headerlink" title="传输会话 TransferSession"></a>传输会话 TransferSession</h3><p>传输会话结构体 <code>TransferSession</code> 用于保存数据连接的信息，包括数据连接的类型（主动或被动）、数据连接的地址、文件的总大小、已传输的大小、文件名等信息。传输会话结构体还包括了一个 <code>offset</code> 字段，用于指定文件的传输偏移量，以便在传输中断后继续传输（实现了 REST 命令）。</p><figure class="highlight rust"><figcaption><span>session.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TransferSession</span> &#123;</span><br><span class="line">  <span class="keyword">pub</span> mode: TransferMode,   <span class="comment">// PORT/PASV</span></span><br><span class="line">  <span class="keyword">pub</span> total_size: <span class="type">u64</span>,      <span class="comment">// 文件总大小</span></span><br><span class="line">  <span class="keyword">pub</span> finished_size: <span class="type">u64</span>,   <span class="comment">// 已传输大小</span></span><br><span class="line">  <span class="keyword">pub</span> file_name: <span class="type">String</span>,    <span class="comment">// 文件名</span></span><br><span class="line">  <span class="keyword">pub</span> finished: <span class="type">bool</span>,       <span class="comment">// 是否传输完成</span></span><br><span class="line">  <span class="keyword">pub</span> aborted: <span class="type">bool</span>,        <span class="comment">// 是否传输中断</span></span><br><span class="line">  <span class="keyword">pub</span> offset: <span class="type">u64</span>,          <span class="comment">// 传输偏移量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="开发经验"><a href="#开发经验" class="headerlink" title="开发经验"></a>开发经验</h1><h2 id="使用标准工具对拍"><a href="#使用标准工具对拍" class="headerlink" title="使用标准工具对拍"></a>使用标准工具对拍</h2><p>在开发过程中，我发现了一个很好的测试方法，那就是使用标准的 FTP 客户端来对拍自己的 FTP 服务器。通过使用 Python 的 <code>ftplib.FTP</code> 和 macOS 上的 Transmit 这个标准的 FTP 图形化客户端，我可以看到客户端和服务器之间的交互过程，可以更好地发现自己的错误。这种对拍的方法可以让开发工作更有目标，因为我知道自己的 FTP 是符合标准的。</p><h2 id="使用-来缩小作用域"><a href="#使用-来缩小作用域" class="headerlink" title="使用 {} 来缩小作用域"></a>使用 {} 来缩小作用域</h2><p>在 Rust 中，可以通过 <code>&#123;&#125;</code> 来缩小变量的作用域，这样可以避免变量的生命周期过长，提高代码的安全性。在开发过程中，因为通过 <code>Mutex.lock()</code> 方法拿到的是一个 <code>MutexGuard</code> 类型，它的生命周期和得到的锁的生命周期是一样的，所以可以通过 <code>&#123;&#125;</code> 来缩小锁的作用域，避免锁的生命周期过长而导致可能的死锁。</p><h2 id="多看编译器的提示"><a href="#多看编译器的提示" class="headerlink" title="多看编译器的提示"></a>多看编译器的提示</h2><p>Rust 是以编译时检查为主的语言，编译器会给出很多有用的提示，比如未使用的变量、未处理的错误、不安全的代码等等。在开发过程中，我发现多看编译器的提示可以帮助我更好地理解 Rust 的语法和规则，提高代码的质量。通过解决编译器提出的问题，有种准备考试时专项训练的感觉，完成这些测试就能拿到不错的成绩，这个过程是一种挣扎也是一种解谜，我的直观感受是节省了不少查阅文档的时间。</p><h1 id="当前进展和下一步计划"><a href="#当前进展和下一步计划" class="headerlink" title="当前进展和下一步计划"></a>当前进展和下一步计划</h1><h2 id="已实现功能"><a href="#已实现功能" class="headerlink" title="已实现功能"></a>已实现功能</h2><p>已经实现的功能包括了 FTP 服务器的基本功能，包括用户登录、文件传输、目录操作、文件操作等。下面是在开发过程中定义的命令枚举类型，包括了目前 FTP 服务器支持的所有命令。</p><figure class="highlight rust"><figcaption><span>commands.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">FtpCommand</span> &#123;</span><br><span class="line">  <span class="title function_ invoke__">USER</span>(<span class="type">String</span>),</span><br><span class="line">  <span class="title function_ invoke__">PASS</span>(<span class="type">String</span>),</span><br><span class="line">  <span class="title function_ invoke__">PORT</span>(SocketAddr),</span><br><span class="line">  PASV,</span><br><span class="line">  <span class="title function_ invoke__">RETR</span>(<span class="type">String</span>),</span><br><span class="line">  <span class="title function_ invoke__">STOR</span>(<span class="type">String</span>),</span><br><span class="line">  ABOR,</span><br><span class="line">  QUIT,</span><br><span class="line">  SYST,</span><br><span class="line">  <span class="title function_ invoke__">TYPE</span>(<span class="type">String</span>),</span><br><span class="line">  <span class="title function_ invoke__">RNFR</span>(<span class="type">String</span>),</span><br><span class="line">  <span class="title function_ invoke__">RNTO</span>(<span class="type">String</span>),</span><br><span class="line">  PWD,</span><br><span class="line">  <span class="title function_ invoke__">CWD</span>(<span class="type">String</span>),</span><br><span class="line">  <span class="title function_ invoke__">MKD</span>(<span class="type">String</span>),</span><br><span class="line">  <span class="title function_ invoke__">RMD</span>(<span class="type">String</span>),</span><br><span class="line">  <span class="title function_ invoke__">LIST</span>(<span class="type">Option</span>&lt;<span class="type">String</span>&gt;),</span><br><span class="line"></span><br><span class="line">  <span class="title function_ invoke__">REST</span>(<span class="type">u64</span>),          <span class="comment">// To be tested</span></span><br><span class="line">  <span class="title function_ invoke__">DELE</span>(<span class="type">String</span>),</span><br><span class="line">  <span class="title function_ invoke__">STAT</span>(<span class="type">Option</span>&lt;<span class="type">String</span>&gt;),</span><br><span class="line">  STOU,</span><br><span class="line">  <span class="title function_ invoke__">APPE</span>(<span class="type">String</span>),</span><br><span class="line">  <span class="title function_ invoke__">ALLO</span>(<span class="type">u64</span>),</span><br><span class="line">  NOOP,</span><br><span class="line">  <span class="title function_ invoke__">NLST</span>(<span class="type">Option</span>&lt;<span class="type">String</span>&gt;),</span><br><span class="line">  CDUP,</span><br><span class="line"></span><br><span class="line">  FEAT,</span><br><span class="line">  <span class="title function_ invoke__">MDTM</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下一步计划"><a href="#下一步计划" class="headerlink" title="下一步计划"></a>下一步计划</h2><p>从 2023 年写毕业论文思绪万千时想用 Rust 写 FTP 服务器来放松心情，到 2024 年的今天终于算是完成了这个玩具工具的开发。从 Git 提交记录来看其间搁置了接近 17 个月，6 月终于是有两三周的时间和动力来完成这个小项目。下一步的计划是继续完善该项目的功能，包括但不限于下面的几项。最终要是能让这个工具变得真正有用就再好不过了。</p><ul><li><input disabled="" type="checkbox"> FTP 客户端: 实现一个简单的 FTP 客户端，配套测试服务器的功能</li><li><input disabled="" type="checkbox"> 优化代码: 优化代码结构和性能，提高代码的可读性和可维护性</li><li><input disabled="" type="checkbox"> 补全测试: 增加更多的测试代码，提升代码质量；进行压力测试，检查性能效果</li><li><input disabled="" type="checkbox"> 制品发布: 使用 Docker 和 Github Action 构建和发布制品，便于部署和使用</li></ul><article class="message message-immersive is-primary"><div class="message-body"><p><i class="fa-solid fa-circle-info mr-2"></i>这篇文章里实现的 FTP 服务器 “rFTP” 的代码可以在我的 Github 仓库 <a href="https://github.com/powerfooI/rftp">powerfooi&#x2F;rftp</a> 中查看。</p></div></article><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.ietf.org/rfc/rfc959.txt">rfc959</a></li><li><a href="https://doc.rust-lang.org/book/title-page.html">The Rust Programming Language</a></li><li><a href="https://tokio.rs/">Tokio - An Asynchronous Rust Runtime</a></li><li><a href="https://docs.python.org/3/library/asyncio.html">asyncio — Asynchronous I&#x2F;O</a></li><li><a href="https://docs.python.org/3/library/ftplib.html">ftplib — FTP protocol client</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Kubernetes 中安全地运行应用</title>
      <link href="/2024/05/19/RunAppSafelyInK8s/"/>
      <url>/2024/05/19/RunAppSafelyInK8s/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在近期的工作当中我大量接触 Kubernetes 集群以及容器化应用，在完成 Operator 拓展的开发和发布后，有海外用户反映在 OpenShift 平台上运行我们的容器化应用会遇到安全性问题，具体而言是我们的容器化应用默认需要 root 用户运行，而 OpenShift 平台如果不进行专门的设置是不允许容器使用 root 用户的。为了解决该用户的问题我们花费了一些功夫，正好我也想以此为契机进一步了解如何在 Kubernetes 中安全地运行应用。本文将记录我在调研和学习过程中的一些心得体会。</p><h1 id="容器安全"><a href="#容器安全" class="headerlink" title="容器安全"></a>容器安全</h1><h2 id="Docker-Init-CLI"><a href="#Docker-Init-CLI" class="headerlink" title="Docker Init CLI"></a>Docker Init CLI</h2><p>Docker Init 命令是用来创建遵循最佳实践的 Docker 配置文件的命令行工具。在使用时通过选择需要运行的应用类型（例如 Go、Python、Node、Rust 等），Docker 会自动帮助用户创建出符合最佳实践的 Dockerfile 和 compose.yaml 文件。</p><article class="message message-immersive is-success"><div class="message-body"><p><i class="fa-solid fa-circle-info mr-2"></i>我的操作系统是 macOS, Docker 版本为 25.0.5，后续的版本中支持的应用类型可能会更多。</p></div></article><span id="more"></span><figure class="highlight text"><figcaption><span>docker init</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ docker init</span><br><span class="line"></span><br><span class="line">Welcome to the Docker Init CLI!</span><br><span class="line"></span><br><span class="line">This utility will walk you through creating the following files with sensible defaults for your project:</span><br><span class="line">  - .dockerignore</span><br><span class="line">  - Dockerfile</span><br><span class="line">  - compose.yaml</span><br><span class="line"></span><br><span class="line">Let&#x27;s get started!</span><br><span class="line"></span><br><span class="line">? What application platform does your project use?  [Use arrows to move, type to filter]</span><br><span class="line">  Go - suitable for a Go server application</span><br><span class="line">  Python - suitable for a Python server application</span><br><span class="line">  Node - suitable for a Node server application</span><br><span class="line">  Rust - suitable for a Rust server application</span><br><span class="line">&gt; Other - general purpose starting point for containerizing your application</span><br><span class="line">  Don&#x27;t see something you need? Let us know!</span><br><span class="line">  Quit</span><br></pre></td></tr></table></figure><h2 id="以-Go-语言应用为例"><a href="#以-Go-语言应用为例" class="headerlink" title="以 Go 语言应用为例"></a>以 Go 语言应用为例</h2><p>通过 Docker Init 创建出 Go 语言程序的 Dockerfile 示例如下，</p><figure class="highlight dockerfile"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1</span></span><br><span class="line"><span class="keyword">ARG</span> GO_VERSION=<span class="number">1.22</span></span><br><span class="line"><span class="keyword">FROM</span> golang:$&#123;GO_VERSION&#125; AS build</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /src</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=cache,target=/go/pkg/mod/ \</span></span><br><span class="line"><span class="language-bash">    --mount=<span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=go.sum,target=go.sum \</span></span><br><span class="line"><span class="language-bash">    --mount=<span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=go.mod,target=go.mod \</span></span><br><span class="line"><span class="language-bash">    go mod download -x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=cache,target=/go/pkg/mod/ \</span></span><br><span class="line"><span class="language-bash">    --mount=<span class="built_in">type</span>=<span class="built_in">bind</span>,target=. \</span></span><br><span class="line"><span class="language-bash">    CGO_ENABLED=0 go build -o /bin/server ./k8s-safety</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest AS final</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=cache,target=/var/cache/apk \</span></span><br><span class="line"><span class="language-bash">    apk --update add \</span></span><br><span class="line"><span class="language-bash">        ca-certificates \</span></span><br><span class="line"><span class="language-bash">        tzdata \</span></span><br><span class="line"><span class="language-bash">        &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">        update-ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> UID=<span class="number">10001</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> adduser \</span></span><br><span class="line"><span class="language-bash">    --disabled-password \</span></span><br><span class="line"><span class="language-bash">    --gecos <span class="string">&quot;&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    --home <span class="string">&quot;/nonexistent&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    --shell <span class="string">&quot;/sbin/nologin&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    --no-create-home \</span></span><br><span class="line"><span class="language-bash">    --uid <span class="string">&quot;<span class="variable">$&#123;UID&#125;</span>&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    appuser</span></span><br><span class="line"><span class="keyword">USER</span> appuser</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build /bin/server /bin/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [ <span class="string">&quot;/bin/server&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>首先设置好 Go 的版本和工作目录后，通过 cache 和 bind 两种挂载将 <code>go mod download -x</code> 命令所依赖的文件缓存和 go.mod、go.sum 文件挂载到容器中，然后通过 <code>go build -o /bin/server ./k8s-safety</code> 命令编译出二进制文件。这里使用了 <code>--mount=type=cache</code> 和 <code>--mount=type=bind</code> 两种挂载方式，前者是将缓存文件挂载到容器中，后者是将本地文件挂载到容器中。这样做的好处是可以减少容器构建时间，提高构建效率。如果直接使用 <code>COPY</code> 或者 <code>ADD</code> 命令将本地文件拷贝到容器中，每次构建都会重新拷贝一次，效率较低，而且这两个命令可能会在镜像中残留一些不必要的信息，增加了潜在的安全风险。</p><p>该文件使用了两阶段构建，这是生产环境镜像常用的构建方法。如果直接采用 golang 的镜像作为运行镜像，其体积大不说（282 MB 左右），因为其中包含了编译环境，还会暴露一些不必要的信息，增加了潜在的安全风险。使用 alpine 镜像作为运行镜像，体积小（5.6 MB 左右），减小镜像体积的同时减小了攻击面。</p><p>在 alpine 镜像中通过 <code>apk --update add</code> 命令安装了一些必要的软件包，涉及了 TLS 证书和时区信息。再通过 <code>adduser</code> 命令创建了一个非 root 用户 appuser，并将其设置为容器运行时的用户。该用户没有设置密码、Home 目录和登录 shell，拥有最小的权限和资源，提高了容器的安全性。最后通过 COPY 命令从构建镜像中把编译好的二进制文件拷贝到运行镜像中，设置了容器监听的端口和启动命令。</p><p>通过 Docker Init 创建的这个 Dockerfile 遵循了一些最佳实践，例如使用多阶段构建、使用最小化的基础镜像、设置非 root 用户等，提高了容器的安全性。</p><h1 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h1><h2 id="ConfigMap-和-Secret"><a href="#ConfigMap-和-Secret" class="headerlink" title="ConfigMap 和 Secret"></a>ConfigMap 和 Secret</h2><p>在 Kubernetes 中，配置管理是一个非常重要的环节。在应用部署时，我们需要将应用的配置信息注入到容器中，以便应用能够正常运行。在配置管理中，我们需要合理的使用 ConfigMap 和 Secret 两种资源对象。其中 ConfigMap 用来存储应用的配置信息，Secret 用来存储应用的敏感信息，例如密码、证书等。它们都可以通过环境变量或者存储卷挂载的方式进行注入。</p><p>在我们的开发中常用 Write Ahead ConfigMap&#x2F;Secret 的形式来存储配置信息，在应用启动时从 ConfigMap 或者 Secret 中读取配置信息到内存中，运行时若有修改，先修改 ConfigMap 或者 Secret，再修改内存中的数据，这样可以在应用重启时也能保持原有的配置，相当于用 K8s 的 Etcd 来存储配置信息。但需要注意的是 ConfigMap 和 Secret 一般有内容大小限制（1MB 左右），如果配置信息过大，可能会导致存储失败。</p><p>另外，我们还可以通过 ConfigMap&#x2F;Secret 的更新机制来实现配置的热更新，避免了应用重启的问题。例如 local-path-provisioner 采用了轮询的方式来检测挂载的 ConfigMap 是否变化。</p><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>Kubernetes 中的命名空间是用来对集群中的资源进行逻辑隔离的资源。通过命名空间，我们可以将集群中的资源划分为不同的逻辑单元，提高了资源的管理和安全性。在实际的应用部署过程中，我们可以根据业务需求和安全要求，将不同的资源放置在不同的命名空间中，以便更好的管理、控制资源和隔离风险。最直观的是 ConfigMap、Secret、Service 等都是按照命名空间划分的资源，分别决定了应用的配置、密钥和服务访问等。</p><p>通过命名空间的划分，将开发、测试和生产的资源分开，将提供不同服务的应用分开，将不同业务线的应用分开，有条不紊地将集群中的资源组织起来是非常重要的。</p><h2 id="资源配额"><a href="#资源配额" class="headerlink" title="资源配额"></a>资源配额</h2><p>Pod 的模板中可以为每个容器设置资源请求（Request）和限制（Limit）。资源请求是容器启动时所需的资源，资源限制是容器能够使用的资源的上限。通过设置资源请求和限制，我们可以更好的控制容器的资源使用，避免资源的浪费和滥用。如果使用 VSCode 进行开发并且安装了 Kubernetes 插件，在识别到 Pod 模板没有填写 Request 和 Limit 时会有警告提示，这也一定程度上说明了最佳实践是如何。当然如果是部分设置，需要区分情况：</p><ul><li>没有设置 Limit，Pod 可以使用集群中的所有资源，可能会导致节点上其他 Pod 无法正常运行。</li><li>没有设置 Request，K8s 无法决定在哪个节点上调度 Pod，可能会导致该 Pod 无法正常运行。</li></ul><p>总之，Pod 中资源请求和限制的设置是非常重要的，是 Kubernetes 正确调度 Pod 的基础。</p><h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><p>Kubernetes 内置的 RBAC（Role-Based Access Control）是一种基于角色的访问控制机制，用来控制用户对集群资源的访问权限，是一种成熟的访问控制方案。通过 RBAC，我们可以为用户（ServiceAccount）分配不同的角色，不同的角色拥有不同的权限，从而实现对集群资源的精细化控制。其核心是通过 Role、RoleBinding、ClusterRole 和 ClusterRoleBinding 四种资源对象来实现。在 Role 中定义一组权限，包括对何种资源能够采取何种操作，然后通过 RoleBinding 将 Role 绑定到用户上，从而实现对用户的授权。ClusterRole 和 ClusterRoleBinding 与 Role 和 RoleBinding 类似，只是作用于集群级别。</p><p>RBAC 相关的资源在 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.25/#role-v1-rbac-authorization-k8s-io"><code>rbac.authorization.k8s.io</code></a> API 组中，通过 <code>kubectl api-resources</code> 命令可以查看到。下面这是一个简单的 RBAC 角色配置。</p><figure class="highlight yaml"><figcaption><span>rbac-role.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-deployment-manager</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>] <span class="comment"># 空字符串表示 core API 组</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pods</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">create</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">update</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">patch</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">delete</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;apps&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">deployments</span></span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;*&quot;</span>] <span class="comment"># * 表示所有操作</span></span><br></pre></td></tr></table></figure><p>上述配置定义了一个名为 <code>pod-deployment-manager</code> 的 Role，该 Role 具有对 Pod 和 Deployment 资源的 get、list、watch、create、update、patch 和 delete 操作权限。然后通过 RoleBinding 将该 Role 绑定到用户上。</p><figure class="highlight yaml"><figcaption><span>rbac-role-binding.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-deployment-manager-binding</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-deployment-manager</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pod-deployment-manager</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pod-deployment-manager-sa</span></span><br></pre></td></tr></table></figure><p>上述配置定义了一个名为 <code>pod-deployment-manager-binding</code> 的 RoleBinding，将 <code>pod-deployment-manager</code> Role 绑定到 <code>pod-deployment-manager</code> 用户和 <code>pod-deployment-manager-sa</code> ServiceAccount 上。这样，<code>pod-deployment-manager</code> 用户和 <code>pod-deployment-manager-sa</code> ServiceAccount 就具有了对 Pod 和 Deployment 资源的 get、list、watch、create、update、patch 和 delete 操作权限。将具有权限的 ServiceAccount 分配给 Pod，就可以实现对 Pod 的授权。</p><p>在生产环境的部署中，需要按照“最小权限”地原则给每个应用和用户单独分配权限，避免权限过大导致的安全风险。</p><h1 id="准入控制"><a href="#准入控制" class="headerlink" title="准入控制"></a>准入控制</h1><p>准入控制是 Kubernetes 中一种用来控制集群中资源的创建和修改的机制，可以通过准入控制器来实现。准入控制器对请求的资源进行验证和审批，只有通过了验证和审批的资源才能被创建或修改。准入控制器可以通过 Webhook 的方式实现，也可以通过 Admission Controller 的方式实现。在自定义 Kubernetes 拓展时往往涉及到引入自定义资源 CRD（Custom Resource Definition），同大多数 K8s 资源会对配置进行校验一样，我们也可以通过准入控制器对 CRD 的配置进行校验，保证配置的正确性和安全性。</p><p>准入控制器的工作原理是当 K8s APIServer 收到请求时，会将请求发送给准入控制器，准入控制器对请求进行验证和审批，然后返回给 APIServer，APIServer 根据准入控制器的结果决定是否允许请求。准入控制器可以对请求的资源进行各种验证，例如验证资源的名称、标签、注解、配置等，在资源不符合校验条件时拒绝请求；也可以对请求的资源进行变更，例如自动添加标签、注解、配置等。这两种准入控制逻辑在 K8s 中分别由 <code>validatingwebhookconfigurations</code> 和 <code>mutatingwebhookconfigurations</code> 实现。API Server 通过调用 Webhook 服务来实现准入控制逻辑，Webhook 服务可以是内部服务也可以是外部服务，如果使用 kubebuilder 等 Operator 构建框架来进行 Kubernetes 的拓展，Webhook 服务是自动集成到 Operator 中的。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文从容器安全、配置管理、访问控制和准入控制几方面介绍了在 Kubernetes 中安全地运行应用的一些方法和最佳实践。目前涉及到的实体交互尚停留在容器本身的运行和配置管理层面，后续将在另外的文章中继续对 Kubernetes 中的网络安全、存储安全、日志安全进行学习。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://docs.docker.com/reference/cli/docker/init/">Docker Init</a></li><li><a href="https://spacelift.io/blog/docker-init">What is Docker Init &amp; When to Use It – Best Practices</a></li><li><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.25">Kubernetes API v1.25</a></li><li><a href="https://www.atatus.com/blog/kubernetes-security-9-best-practices-for-keeping-it-safe/">Kubernetes Security: 9 Best Practices for Keeping It Safe</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AccessControl </tag>
            
            <tag> CloudNative </tag>
            
            <tag> Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode 插件 - YAI</title>
      <link href="/2024/02/27/YetAnotherImporter-VSCode/"/>
      <url>/2024/02/27/YetAnotherImporter-VSCode/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>这又是一次目标回收计划，早在 2021 年我还在广泛地写 TypeScript 代码时就想完成这样一个插件来满足我“不打断心流地引入模块”的需求，但“新建文件夹”之后我一直没有实际的迭代动作。直到最近高频写 Go 代码时，才真正意识到这个需求的重要性。于是我又重新打开了这个项目的代码仓库。</p><p>这是一个 VSCode 插件，叫做 YAI，全称 Yet Another Importer，英文项目命名的 Yet Another 数不胜数，我也随波逐流一次。这个插件是用来帮助开发者方便地引入模块的，它可以自动识别当前项目中的依赖，并且扫描项目本地的文件，统计当前项目中引入模块的规律和频次，在需要引入模块时给出相应提示，并且以编程语言“原生”的方式将模块引入到代码中。何为“原生”，也就是适应当前项目编程语言的引入方式，比如在 JavaScript 项目中，它会使用 <code>import</code> 或 <code>require</code> 语句引入模块，而在 Python 项目中，它会使用 <code>import</code> 语句引入模块，在 Go 项目中，它会使用别名来引入模块等。</p><p>目前这个插件还处于开发阶段，但是已经可以在 Go 语言中使用了。目前规划的编程语言还有 ECMAScript、Python、C&#x2F;C++ 这几种。该插件的代码仓库在 Github <a href="https://github.com/PowerfooI/yai-vscode">代码仓库</a>中，如果你也对这个插件感兴趣，欢迎使用或者参与开发。</p><p>插件已发布，可以在 <a href="https://marketplace.visualstudio.com/items?itemName=powerfooi.yai">yai - VSCode Marketplace</a> 查看安装。</p><p>这篇文章可以算作插件的设计文档，我会在这里记录一些关于这个插件的设计思路和实现细节。</p><span id="more"></span><h1 id="开发初衷"><a href="#开发初衷" class="headerlink" title="开发初衷"></a>开发初衷</h1><p>从代码仓库的提交日期可以看到，我三年前就想实现这样的小插件，当时主要编程语言是 TypeScript，主要写 React 项目，虽然 VSCode 对 TypeScript 的模块引入支持得还算不错，但有时它也会不及预期：</p><ol><li>在实现的具体代码逻辑中键入一个模块名，有时 VSCode 能够自动提示，有时则不能，例如引入 <code>React</code>；</li><li>在已经部分引入模块的情况下，再想引入模块中其他导出变量，有时 VSCode 能够自动提示，有时则不能（大多时候不能），例如已经从 <code>antd</code> 中引入了 <code>Button</code>, <code>Tooltip</code>, <code>message</code> 再想引入 <code>Select</code> 时，往往无法得到编辑器的提示；</li><li>在引入本地定义的模块时，VSCode 有时无法正确判断导出方式，<code>export default</code> 和 <code>export</code> 有时会混淆。</li></ol><p>为了解决上述 VSCode 模块引入的一些问题，我需要暂停手头的工作，把视窗划到文件的头部（通常情况下可以使用 <code>Cmd</code> + <code>Up Arrow</code> 组合键来完成），然后键入 <code>import</code> 或 <code>require</code> 等关键字，再键入模块名，最后再键入可选的分号。这样的操作虽然看似简单，但是在频繁引入模块的情况下，会打断我的心流，让我无法专注于当前的工作。</p><p>这个情况在写 Go 代码的时候也时常出现，虽然 Go 语言的模块引入方式相对简单，但是在引入第三方模块时，我还是需要打开浏览器，查找模块的文档，然后复制粘贴模块的引入语句。而且在 Go 代码中会广泛地使用别名来引入模块，若一个项目 Go 文件稍微多些，同一个模块会出现多个引入别名（例如 VSCode 有时将 <code>k8s.io/apimachinery/pkg/apis/meta/v1</code> 和 <code>k8s.io/api/core/v1</code> 都引入为 <code>v1</code>，有时又分别引入为 <code>metav1</code> 和 <code>corev1</code>），为了保持各个文件中该模块的语义和含义一致，我不仅需要跳转到文件头部，甚至需要打开其他文件将别名引入语句复制粘贴到当前文件中。这种操作无疑是对“流畅编写代码”目标的一次沉重打击。</p><h1 id="设计思路和实现细节"><a href="#设计思路和实现细节" class="headerlink" title="设计思路和实现细节"></a>设计思路和实现细节</h1><p>根据开发初衷，我给这个插件制定了如下几个目标，优先级从高到底：</p><ol><li>模块引入：需要提供不打断心流的引入模块方式，即在键入模块名时，插件应该能够自动提示当前项目中的可引入的模块；</li><li>模块索引：需要支持本地文件中引入模块的索引，即插件应该能够扫描当前项目中的文件，统计当前项目中引入模块的规律和频次；</li><li>多语言支持：需要支持多种编程语言，即插件应该能够根据当前项目的编程语言，使用该编程语言的原生引入方式引入模块；</li></ol><p>为了实现这三个目标，结合近期<strong>编写 Go 代码的经历</strong>，我给 YAI 插件制定了如下设计思路。</p><h2 id="模块引入"><a href="#模块引入" class="headerlink" title="模块引入"></a>模块引入</h2><p>模块引入是插件的核心功能，结合我的日常使用习惯，开发者通常会引入的模块有三种：</p><ol><li>标准库模块：Go 语言的标准库模块，例如 <code>fmt</code>, <code>os</code>, <code>io</code> 等；</li><li>第三方模块：Go 语言的第三方模块，例如 <code>github.com/gin-gonic/gin</code>, <code>github.com/spf13/viper</code> 等；</li><li>本地模块：项目中的本地模块，例如 <code>pkg/utils</code>, <code>internal/config</code> 等。</li></ol><p>为了识别这三个类型的模块，插件需要扫描当前项目中的 <code>go.mod</code> 文件，以识别第三方模块；扫描当前项目中的 <code>go</code> 文件，以识别本地模块；最后至于标准库模块，Go 语言的标准库模块是有限的，插件可以直接内置这些模块。例如执行 <code>go list std</code> 命令就可以把所有的标准库都列出来。</p><p>秉持着先能跑再优化的开发理念，该模块引入目标的迭代计划是：</p><ul><li>第一步：所有的模块引入都需要开发者提供完整的模块名，例如 <code>github.com/gin-gonic/gin</code>，<code>pkg/utils</code> 等，不提供补全提示；</li><li>第二步：在键入模块名时，插件应该能够自动提示当前项目中的可引入的模块，例如在 Go 项目中，键入 <code>gin</code> 时，插件应该能够提示 <code>github.com/gin-gonic/gin</code>；</li><li>第三步：在键入模块名时，插件应该能够自动提示当前项目中的可引入的模块，同时在键入 <code>.</code> 时，插件应该能够自动提示当前模块的导出变量。</li></ul><h2 id="模块索引"><a href="#模块索引" class="headerlink" title="模块索引"></a>模块索引</h2><p>模块索引需要扫描本地所有源文件，解析其中的模块引入语句，统计当前项目中引入模块的规律和频次。这个功能的目的是为了在模块引入时，给出更加智能的提示。例如在 Go 项目中对于第三方模块而言，有时开发者会引入模块的子模块，例如 <code>github.com/gin-gonic/gin</code> 中的 <code>github.com/gin-gonic/gin/render</code>，有时开发者会引入模块的别名，例如 <code>github.com/gin-gonic/gin</code> 有时会引入为 <code>gin</code>，有时会引入为 <code>g</code>，有时会引入为 <code>g1</code> 等。这些引入方式都是合法的，但是在一个项目中应该保持一致，这样可以提高代码的可读性和可维护性。</p><p>模块索引是为了能在模块引入时提供更多的信息，以更好地满足模块引入的需求。在 YAI Go 的第一个版本中，模块索引所实现的功能就是把本地文件中所有的引入路径都扫描出来，然后在模块引入时给出提示，这很好地补充了仅扫描 <code>go.mod</code> 文件获取第三方模块根路径的不足。同时，Go 项目的模块索引可以能获取到模块的别名，在模块引入时能让开发者直观地看到这个模块的所有别名以及各个别名的引入频次。</p><h2 id="多语言支持"><a href="#多语言支持" class="headerlink" title="多语言支持"></a>多语言支持</h2><p>最初的开发动力来自于 TypeScript 编写的 React 项目，但是在写 Go 项目的时候，我发现不打断心流地模块引入是一个更加普遍的需求。因此，我决定在 YAI 插件中支持多种编程语言，因为当前接触得比较多的是 Go 语言和 ECMAScript 语言，所以我决定先支持这两种语言。</p><p>我定义了一个名为 <code>InnerProcessor</code> 的接口，其中提供了两个方法 <code>index()</code> 和 <code>import()</code>，由各个语言的处理器分别实现该接口，例如 Go 语言的 <code>GolangProcessor</code>。外层定义 <code>LanguageProcessor</code> 接口拓展了 <code>InnerProcessor</code> 额外提供获取当前项目编程语言的方法 <code>getLanguageId()</code>，再定义类 <code>YAIProcessor</code> 实现这个接口，用于根据当前项目的编程语言选择合适的处理器。</p><p>每当激活插件后打开某个项目，若插件检测到当前项目的编程语言是已经支持的，则会触发一次 <code>index()</code> 方法的调用(<code>YAI: Index Modules</code>)。而模块引入功能则需要用户主动触发，即通过快捷键或者命令面板调用执行，命令名称为 <code>YAI: Import Module</code>。执行模块引入命令后会通过一系列输入选择的交互引入用户所指定的模块。</p><h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p>下面是 YAI 插件在 Go 项目中实现功能的一些实现效果。</p><p>首先通过 <code>YAI: Index Modules</code> 命令来索引当前项目中的模块，索引建立成功之后会有提示：</p><img src="/2024/02/27/YetAnotherImporter-VSCode/index.png" class="" title="建立索引"><p>打开命令面板(<code>F1</code> 或 <code>Ctrl/Cmd + Shift + P</code>) 通过 <code>YAI: Import Module</code> 命令来开启引入模块功能。</p><img src="/2024/02/27/YetAnotherImporter-VSCode/step1.png" class="" title="打开命令面板"><p>进入命令后会展示当前可以引入的模块，这里可以通过键盘上下键选择模块，也可以通过输入文本进行筛选，然后回车确认选择：</p><img src="/2024/02/27/YetAnotherImporter-VSCode/step2.png" class="" title="选择模块"><img src="/2024/02/27/YetAnotherImporter-VSCode/step2-1.png" class="" title="输入文本筛选模块"><p>选择模块后插件会提示用户是否需要引入该模块的子模块，此处如果不输入（直接按回车或 <code>ESC</code> 键）则表示不引入子模块：</p><img src="/2024/02/27/YetAnotherImporter-VSCode/step2-1.png" class="" title="输入需要引入的子模块"><p>下一步插件会提示本项目中该模块使用的所有的别名，用户可以选择其中一个别名，也可以手动再输入一个别名，然后回车确认选择：</p><img src="/2024/02/27/YetAnotherImporter-VSCode/step3.png" class="" title="选择别名进行引入"><p>最后插件会在当前文件中插入引入语句，模块引入成功：</p><h1 id="总结和不足"><a href="#总结和不足" class="headerlink" title="总结和不足"></a>总结和不足</h1><p>YAI 的开发占据了我近期工作日的业余时间和周末一整天，不过这个插件的开发过程还是很有意思的。在开发过程中，我学到很多关于 VSCode 插件开发的知识，也大致明白了 VSCode Extension API 能够实现的功能。不得不说 VSCode 对插件开发的支持还是很好的，它提供了丰富的 API，让开发者可以很方便地实现自己的想法。</p><p>就 YAI 目前的功能而言，它已经能够满足我在 Go 项目中引入模块的需求，让我不打断心流地引入我指定的模块。但它是还有很多可以迭代的方向：</p><ol><li>交互流程有些冗长，需要用户多次输入和选择，未来可以考虑通过配置项的方式优化交互流程，例如省略输入子模块的步骤等；</li><li>目前只支持 Go 语言，未来可以考虑支持更多的编程语言，例如 ECMAScript、Python、C&#x2F;C++ 等；</li><li>可以针对每个语言推出特定的功能，例如统一 Go 项目中的模块别名等。</li></ol><article class="message message-immersive is-success"><div class="message-body"><p><i class="fa-solid fa-circle-info mr-2"></i>插件已经发布，可以在 <a href="https://marketplace.visualstudio.com/items?itemName=powerfooi.yai">yai - VSCode Marketplace</a> 查看安装。</p></div></article>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Tools </tag>
            
            <tag> VSCode </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Controller-runtime 源码阅读</title>
      <link href="/2024/02/03/ReadSourceOfControllerRuntime/"/>
      <url>/2024/02/03/ReadSourceOfControllerRuntime/</url>
      
        <content type="html"><![CDATA[<p>Operator 是 Kubernetes 用来拓展其 API 的一种开发范式（Pattern），其核心是定义若干的自定义资源及其对应的资源控制器，当这些资源发生变化时其对应的控制器对变化进行调解（Reconcile），最终使得实际状态与预期状态达成一致。K8s-sigs 推出的 <a href="https://book.kubebuilder.io/">kubebuilder</a> 是一个用于构建 Operator 应用的框架，和 <a href="https://github.com/operator-framework/operator-sdk">Operator-SDK</a> 一样都依赖了 <a href="https://github.com/kubernetes-sigs/controller-runtime">controller-runtime</a>，提供了高级 API 和抽象，让开发者更直观地编写操作逻辑，并提供用于快速启动新项目的脚手架和代码生成工具。</p><p>截至目前我已经参与了两个 Operator 项目的搭建和维护，均采用了 kubebuilder 做基础脚手架。我目前对 CRD 的设计生成、Webhook 的校验机制和、Controller 的控制循环机制有了一定认识，接触时间稍长后在日常开发 Operator 项目时难免出现缺乏新意的情况，Operator 模式看久了和 CURD 之于后端有些许相似。但我乐观地估计通过观察下层实现可以收获一些启发。既然 kubebuilder 和 Operator-SDK 都依赖了 controller-runtime，那么就先从它出发吧。</p><span id="more"></span><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><h2 id="MindMap"><a href="#MindMap" class="headerlink" title="MindMap"></a>MindMap</h2><p>controller-runtime 这个包的内容不少，为了在一篇文章里能覆盖到，本文仅选取在构建 Operator 过程中起关键作用的包进行介绍，<code>envtest</code>、<code>scheme</code>、<code>certwatcher</code> 等同样重要的包就不在此提及。下面是我读代码时画的意识流思维导图，有的子项目是组成结构，有的子项目是工作角色，比较自由灵活。我选取了 <code>Cache</code>,<code>Source</code>, <code>Handler</code>, <code>Client</code>, <code>Controller</code> 和 <code>Manager</code> 这六个包。</p><img src="/2024/02/03/ReadSourceOfControllerRuntime/Controller-runtime.png" class="" title="意识流的思维导图"><h2 id="WorkFlow"><a href="#WorkFlow" class="headerlink" title="WorkFlow"></a>WorkFlow</h2><p>对于控制器而言，资源发生变动的信息均来自于 API Server，从资源发生变动到控制器完成调解需要经过多个模块的处理，大体来说可以用下面的图来表示。</p><img src="/2024/02/03/ReadSourceOfControllerRuntime/Controller-workflow.png" class="" title="控制器工作流程"><h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h1><p>Cache 包通过 Informers 接口封装了 client-go 中的缓存机制 SharedInformer，为每个资源类型都创建对应的 Informer，通过它们的缓存避免所有请求都直接访问 API Server 导致其可能的不堪重负。SharedInformer 机制在 client-go 中定义，它采用增量同步的方式从 API Server 处“订阅”某类资源的事件，并且将事件的增量更新保存在本地存储（Store）当中，其中典型的存储是 DeltaFIFO。SharedInformer 是 k8s client-go 中的核心机制，几乎所有的客户端应用都绕不开它，之后有空再阅读查看其中细节，这里我们不再展开。</p><p>控制流路径大致为 cache.New -&gt; newCache -&gt; internal.NewInformers -&gt; sharedInformers，其中：</p><ul><li>cluster 初始化时通过 <code>cache.New</code> 创建集群资源缓存，默认的创建缓存方法可以通过传入自定义的缓存初始化函数进行 Mock，大多数情况下不需要传入自定义的函数；</li><li>在 Cache 的初始化函数当中可以为每个类型的资源定义细粒度的缓存策略，通过 <code>cache.Options</code> 中的 <code>ByObject</code> 字段进行配置。在 <code>manager.Options</code> 中的 <code>Cache</code> 就是负责控制缓存的行为的字段。</li><li><code>internal.Informers</code> 提供了 <code>Get</code>、<code>Peek</code> 和 <code>Remove</code> 方法。其中 Get 方法中调用 Peek，若没有获取到指定的 sharedInformer，会根据配置参数中的 <code>newInformer</code> 方法创建出来并且添加到 map 当中留作后用；Peek 方法若无法从 map 中获取到也不会自动启动新的 sharedInformer。</li><li>通过 <code>internal.Informers</code> 获取到 sharedInformer，后续的 Source 包能够将事件处理器与其绑定，将从 API Server 处同步到的对象变更事件转化为控制器循环当中的 <code>reconcile.Request</code> 对象。</li></ul><h1 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h1><p><code>Source</code> 顾名思义是来源，但准确来讲这个来源是请求的来源，也就是在 kubebuilder 中所有的控制器需要实现的 Reconcile 方法的 requests.Request 这一参数的生产者。在 Source 有三种类型，Channel，Informer 和 Func。</p><p>其中 <a href="https://github.com/kubernetes-sigs/controller-runtime/blob/7032a3cc91d2afc4c2d54e4a4891cf75da9f75f5/pkg/source/source.go#L67-L86">Channel</a> 类型主要用于外部事件的处理，例如 Github 的 Webhook，需要用户自行编写外部的 Source 来将通用事件写入到内部的 Channel 当中。</p><p>Informer 类型的 Source 在控制器当中最常用，它封装了 client-go 的 cache.Informer 接口，将事件处理器与 informer 进行绑定，用于产生源于集群内部的事件，例如 Pod 的创建等。</p><figure class="highlight go"><figcaption><span>pkg/source.go:184-206</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Informer is used to provide a source of events originating inside the cluster from Watches (e.g. Pod Create).</span></span><br><span class="line"><span class="keyword">type</span> Informer <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Informer is the controller-runtime Informer</span></span><br><span class="line">Informer cache.Informer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ Source = &amp;Informer&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start is internal and should be called only by the Controller to register an EventHandler with the Informer</span></span><br><span class="line"><span class="comment">// to enqueue reconcile.Requests.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(is *Informer)</span></span> Start(ctx context.Context, handler handler.EventHandler, queue workqueue.RateLimitingInterface,</span><br><span class="line">prct ...predicate.Predicate) <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// Informer should have been specified by the user.</span></span><br><span class="line"><span class="keyword">if</span> is.Informer == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;must specify Informer.Informer&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, err := is.Informer.AddEventHandler(internal.NewEventHandler(ctx, queue, handler, prct).HandlerFuncs())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 Source 接口只有一个 Start() 方法，所以 Func 类型只是为了方便将单个函数实现成为这个接口而封装出来的类型，在此不再作更多介绍。</p><p>在 Source 的内部实现 (<code>pkg/internal/source</code>) 中，它将从 Informer 中获取到的对象转换为 Create，Update，Delete 和 Generic 四类事件，四类事件分别由相应的事件处理器进行下一步的处理。其中，事件处理器在 Handler 包中定义，Informer 在 Cache 包中定义。</p><h1 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h1><figure class="highlight go"><figcaption><span>pkg/handler.go:44-57</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EventHandler <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Create is called in response to a create event - e.g. Pod Creation.</span></span><br><span class="line">Create(context.Context, event.CreateEvent, workqueue.RateLimitingInterface)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update is called in response to an update event -  e.g. Pod Updated.</span></span><br><span class="line">Update(context.Context, event.UpdateEvent, workqueue.RateLimitingInterface)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete is called in response to a delete event - e.g. Pod Deleted.</span></span><br><span class="line">Delete(context.Context, event.DeleteEvent, workqueue.RateLimitingInterface)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generic is called in response to an event of an unknown type or a synthetic event triggered as a cron or</span></span><br><span class="line"><span class="comment">// external trigger request - e.g. reconcile Autoscaling, or a Webhook.</span></span><br><span class="line">Generic(context.Context, event.GenericEvent, workqueue.RateLimitingInterface)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Source 将事件处理器 EventHandlers 和 Informers 进行绑定，Handlers 将某个某类型资源 A 的事件 Event 转化为某类型资源 B 的事件请求 Request 推入工作队列（<code>workqueue.RateLimitingInterface</code>，定义在 client-go 当中），其中 A 通常等于 B，但也存在 A 不等于 B 的情况。下面将两种情况区分介绍。</p><p><strong>1. A &#x3D;&#x3D; B</strong></p><p>A &#x3D;&#x3D; B 也就是说产生事件的资源和需要调解的资源类型是相同的，例如用户提交了一个 Pod，那 Pod 的控制器就会接收到这个 Pod 被创建的事件，并对该事件进行调解。这是最普遍的情况，在 <code>pkg/handler/enqueue.go</code> 中有该情况的实现。</p><p><strong>2. A !&#x3D; B</strong></p><p>A !&#x3D; B 说明在类型 A 产生的事件要发送给类型 B 的控制器进行调解，这在单一资源&#x2F;控制器的语境下没有太大的意义，但如果将资源的从属关系也纳入其中就很好解释了：父级资源在子资源发生变更时收到相应的事件，级联地调解自身的状态，进而加速多级资源结构整体的调解速度。例如 ReplicaSet 资源应该监听其拥有的 Pod 资源的事件，当 Pod 状态发生变化时，ReplicaSet 控制器也应该调解 ReplicaSet 资源的状态或配置，以求符合预期。</p><p>在 <code>pkg/handler/enqueue_owner.go</code> 和 <code>enqueue_mapped.go</code> 中有 A !&#x3D; B 时的 handler 方法实现。其中 <code>enqueue_owner.go</code> 中为我们实现了“子资源变更，父资源调解”的逻辑，在 kubebuilder 中在 builder 方法下使用 <code>Owns()</code> 方法可以声明从属关系，从而让我们的控制器能够调解拥有的其他资源的“此类资源”。</p><p>而 <code>enqueue_mapped.go</code> 则封装了更为通用的事件处理器方法，能够让用户自定义从 client.Object 到 reconcile.Request 的映射，实现更为灵活的事件入队逻辑。</p><h1 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h1><p>Controller 控制器是我们要补充编码并最终运行的若干实体，它们负责从 K8s 的控制循环中取回对应资源的事件，并且调用自身的调解函数（也就是我们在编写 Operator 时补充的 Reconcile 函数）完成资源状态对齐的任务。如开头的思维导图所示，我列出了 <code>Reconcile</code>，<code>Workqueue</code>，<code>Watches()</code> 和 <code>Metadata Projection</code> 这些子项目，下面分别就这些内容进行介绍。</p><figure class="highlight go"><figcaption><span>pkg/internal/controller/controller.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Controller <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Name is used to uniquely identify a Controller in tracing, logging and monitoring.  Name is required.</span></span><br><span class="line">Name <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MaxConcurrentReconciles is the maximum number of concurrent Reconciles which can be run. Defaults to 1.</span></span><br><span class="line">MaxConcurrentReconciles <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reconciler is a function that can be called at any time with the Name / Namespace of an object and</span></span><br><span class="line"><span class="comment">// ensures that the state of the system matches the state specified in the object.</span></span><br><span class="line"><span class="comment">// Defaults to the DefaultReconcileFunc.</span></span><br><span class="line">Do reconcile.Reconciler</span><br><span class="line"></span><br><span class="line"><span class="comment">// MakeQueue constructs the queue for this controller once the controller is ready to start.</span></span><br><span class="line"><span class="comment">// This exists because the standard Kubernetes workqueues start themselves immediately, which</span></span><br><span class="line"><span class="comment">// leads to goroutine leaks if something calls controller.New repeatedly.</span></span><br><span class="line">MakeQueue <span class="function"><span class="keyword">func</span><span class="params">()</span></span> workqueue.RateLimitingInterface</span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue is an listeningQueue that listens for events from Informers and adds object keys to</span></span><br><span class="line"><span class="comment">// the Queue for processing</span></span><br><span class="line">Queue workqueue.RateLimitingInterface</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reconcile"><a href="#Reconcile" class="headerlink" title="Reconcile"></a>Reconcile</h2><p>Reconcile 函数也就是<a href="https://github.com/kubernetes-sigs/controller-runtime/blob/7032a3cc91d2afc4c2d54e4a4891cf75da9f75f5/pkg/internal/controller/controller.go#L41">控制器结构体（pkg&#x2F;internal&#x2F;controller）</a>当中 <code>Do</code> 这个字段的具体实现，它接收 <code>reconcile.Request</code> 返回 <code>reconcile.Result</code>，这两个参数类型都极为简单，从中可以表现出 controller-runtime 的设计者们希望把最简单的接口留给开发者。reconcile.Request 其实就是 <code>NamespacedName</code>，reconcile.Result 则包含了两个字段 <code>Requeue</code> 和 <code>RequeueAfter</code>，分别表示是否重新入队和多久后重新入队。这与后续的工作队列模块相互配合，支持我们实现有计划、有规律的调解重试。</p><h2 id="Workqueue"><a href="#Workqueue" class="headerlink" title="Workqueue"></a>Workqueue</h2><p>Workqueue 顾名思义是工作队列，与 Controller 控制器和 Source 事件源相互配合，完成对资源变更事件的有序处理过程。workqueue 是 client-go 中的 <code>workqueue.RateLimitingInterface</code> 接口，也就是速率受限的工作队列，限定速率的工作由 <code>rateLimiter</code> 接口完成，一个对象需要先经过 rateLimiter 同意才能够顺利入队，速率限定器的逻辑可由用户自行定义，但大部分 K8s 客户端的场景当中，使用默认的速率限定逻辑即可。速率受限的工作队列也在 client-go 中完成定义，之后的文章中有机会再探讨。</p><h2 id="Watches"><a href="#Watches" class="headerlink" title="Watches"></a>Watches</h2><p>Watches 方法将某一类对象包装成为 Source，并将其通过事件处理器 Handler 与工作队列进行关联。在 Kubebuilder 当中我们直接使用的方法是 <code>ControllerManagedBy</code>，它采用构建者模式返回一个 <code>Builder</code> 类型的结构，支持我们链式调用配置方法，最终通过 <code>Complete</code> 方法完成控制器的构建。在 Builder 结构体下暴露了若干的方法，其中有 For，Owns 和 Watches 这三个方法用于绑定 Source 和 Handler。For 和 Owns 其实是 Watches 的语法糖，它们分别表示监听某类资源和监听拥有的某类资源（从属关系通过 OwnerReferences 构建），都可以通过 Watches 方法来实现。</p><p>Watches 方法接受 <code>client.Object</code>，<code>handler.EventHandler</code> 和 <code>WatchesOption</code> 作为参数，从集群的缓存中拿到某类资源的 Informer 封装为 Source，绑定上事件处理器。handler 包中提供的两个现有的方法分别构成了 For 和 Owns 两个方法对 Watches 封装的语法糖。</p><p>Watches 的行为还会收到 Predicates 的影响，Predicates 起过滤作用，用来决定什么事件应该进入工作队列，什么事件不应该进入工作队列。刚开始接触 Controller runtime 时许多开发者经常会遇到资源 Spec 变更后触发调解，控制器更新资源 Status 之后再次触发调解的莫名其妙的死循环，这个情况就是 Predicate 没有正确设置，当资源（包括 Status）发生更新后，资源的 ResourceVersion 会发生变更，但如果不希望 Status 更新后触发调解，可以在 <code>builder.WithEventFilter()</code> 中传入预先定义好的 <code>predicate.GenerationChangedPredicate&#123;&#125;</code>，这样会过滤掉 ResourceVersion 发生变更的事件。</p><h2 id="Metadata-Projection"><a href="#Metadata-Projection" class="headerlink" title="Metadata Projection"></a>Metadata Projection</h2><p>在 Controller Builder 包中有个类型是 <code>objectProjection</code> 表示对象的投影。在调用 For，Owns 和 Watches 三个方法时可以通过末尾的不定长选项参数传入有关投影的配置，builder.OnlyMetadata 就是这样的配置。OnlyMetadata 用来告诉控制器只需要缓存元信息，并且只通过 MetadataClient Watch 元信息格式的资源对象。这对于某类资源对象众多、资源占据空间极大或者只知道资源的 GVK 不知道资源的具体结构等情况是非常有用的。</p><h1 id="Controller-Manager"><a href="#Controller-Manager" class="headerlink" title="Controller Manager"></a>Controller Manager</h1><p>Controller Manager 控制器管理器管理了包括控制器在内的若干可运行接口（Runnable），只要实现了方法 <code>Start(context.Context) error</code> 就能够成为 Runnable，上述介绍的若干模块都实现了这个方法，例如 Cache, Source, Controller，还有未提及的 Webhook，HttpServer，LeaderElection 等。管理器自身也实现了 Start 方法，用于在我们的主程序中调用运行。上述所有模块的配置也都可以通过 Manager 的配置进行传入，换句话说，Manager 的配置整合了所有其他模块的配置信息。</p><p>Manager 还封装了 Cluster 这个接口，cluster 包含了 <code>rest.Config</code>, <code>runtime.Scheme</code>, <code>Cache</code>, <code>client.Reader</code> 和 <code>meta.RESTMapper</code> 等包含集群信息的重要字段，Cluster 接口所有的方法都是只读的，也确定了该结构就是单纯用于“信息查阅”的。</p><h1 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h1><p>Client 封装了常用的客户端功能，Get 和 List 操作优先从缓存中读取，Create，Update 和 Delete 等写入操作直接与 API Server 进行通信。当然可以在初始化客户端时通过 <code>client.Options.Cache.DisableFor</code> 字段配置禁用某些资源类型的缓存，直接从 API Server 读取。</p><h1 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h1><h2 id="对外的-API-保持简单"><a href="#对外的-API-保持简单" class="headerlink" title="对外的 API 保持简单"></a>对外的 API 保持简单</h2><p>如果不读源码，不仔细读文档，我们能够接触到的接口无非就是 Controller Builder 的使用和 Reconcile 方法，了解 K8s 的控制循环逻辑就可以开始编写 Operator 的代码。Controller-runtime 高内聚的特点将简单留给了开发者，复杂性由设计者和维护者承担。</p><p>同时也可以看到为了保持依赖的简洁，Controller-runtime 从其他地方(k8s.io&#x2F;kubernetes)复制了一些文件到本地，从而<a href="https://github.com/kubernetes-sigs/controller-runtime/blob/7032a3cc91d2afc4c2d54e4a4891cf75da9f75f5/pkg/internal/flock/doc.go#L17-L21">避免了直接依赖整个包</a>。虽然不优雅，但不得不说实用主义在这里再次赢得了胜利。</p><h2 id="多利用编译阶段的静态检查"><a href="#多利用编译阶段的静态检查" class="headerlink" title="多利用编译阶段的静态检查"></a>多利用编译阶段的静态检查</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Source <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// Some methods</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> kind <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// Some fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ Source = kind&#123;&#125;</span><br></pre></td></tr></table></figure><p>上述代码段定义了一个公开接口和一个内部结构，通过 <code>var _ Source = kind&#123;&#125;</code> 这个语句在编译阶段保障我们的结构实现了指定的接口，而因为变量名为空，在编译完成后该变量会被抛弃，对程序的运行状态没有影响。这个小技巧可以在之后的开发中多加使用，尽早避免可能出现的<code>未完全实现某接口</code>导致的运行时错误。</p><h2 id="Option-接口"><a href="#Option-接口" class="headerlink" title="Option 接口"></a>Option 接口</h2><p>在 Controller runtime 中广泛出现 Option 接口的实现，各种配置都通过传递 Option 接口来完成，下面是其中一处源码片段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ForOption <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// ApplyToFor applies this configuration to the given for input.</span></span><br><span class="line">ApplyToFor(*ForInput)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Predicates <span class="keyword">struct</span> &#123;</span><br><span class="line">predicates []predicate.Predicate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ApplyToFor applies this configuration to the given ForInput options.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Predicates)</span></span> ApplyToFor(opts *ForInput) &#123;</span><br><span class="line">opts.predicates = w.predicates</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(blder *Builder)</span></span> For(object client.Object, opts ...ForOption) *Builder &#123;</span><br><span class="line"><span class="keyword">if</span> blder.forInput.object != <span class="literal">nil</span> &#123;</span><br><span class="line">blder.forInput.err = fmt.Errorf(<span class="string">&quot;For(...) should only be called once, could not assign multiple objects for reconciliation&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> blder</span><br><span class="line">&#125;</span><br><span class="line">input := ForInput&#123;object: object&#125;</span><br><span class="line"><span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">opt.ApplyToFor(&amp;input)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">blder.forInput = input</span><br><span class="line"><span class="keyword">return</span> blder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们为多个类型实现了 Option 接口的方法，这样多个类型可以作为相同的类型传递给同一个函数，例如 For 当中的 Predicate 和 ObjectProjection 等。通过 Option 接口可以获得更高的配置灵活性。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reading </tag>
            
            <tag> CloudNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当我执行 kubectl create 时发生了什么[译]</title>
      <link href="/2024/01/13/WhatHappensWhenK8s/"/>
      <url>/2024/01/13/WhatHappensWhenK8s/</url>
      
        <content type="html"><![CDATA[<blockquote><p>翻译自 <a href="https://github.com/jamiehannaford/what-happens-when-k8s">What happens when … Kubernetes edition!</a>。我认为这篇文章写得生动有趣，且在关键位置都给出了有价值的链接，引导进一步的阅读学习，让我有了重读并翻译的冲动。</p></blockquote><p>如果我希望往 Kubernetes 集群当中部署 nginx，我大概率会在命令行输入下面这样的命令并敲下回车键：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment nginx --image=nginx --replicas=3</span><br></pre></td></tr></table></figure><p>几秒之后，我应该能看到三个 nginx 的 pod 散布在集群的工作节点上。这很神奇！但这个过程背后究竟发生了什么？</p><p>关于 Kubernetes 的惊人的特点是，它通过用户友好的 API 处理工作负载的部署。其中的复杂性被简单的抽象隐藏起来。但为了充分理解它所提供的价值，了解其内部工作原理也是很有用的。本指南将引导您了解从客户端 kubectl 到 kubelet 的请求的完整生命周期，并在必要时链接到源代码（或者相关文档和博客）来进一步说明正在发生的事情。</p><p>这是一份不断修订的文档。如果您发现可以改进或重写的地方，欢迎贡献！</p><span id="more"></span><h1 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a>kubectl</h1><h2 id="校验和生成器"><a href="#校验和生成器" class="headerlink" title="校验和生成器"></a>校验和生成器</h2><p>好的，我们开始吧。我们刚刚在终端里敲击了回车键，现在会发生什么？</p><p>首先 kubectl 会进行客户端校验，该过程保证了应当出错的请求尽早地出错，而不是在发送给 kube-apiserver 之后再返回错误，例如创建了一个不支持的资源或者一个<a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubectl/cmd/run/run.go#L264">异常的镜像名</a>。这个校验过程通过减少不必要的负载提升了系统的性能。</p><p>校验完成后，kubectl 开始组装将要发送到 kube-apiserver 的 HTTP 请求。任何希望访问或者改变 Kubernetes 系统状态的请求都会经过 API server 并最终与 etcd 进行交互。kubectl 也一样，为了构建这样的 HTTP 请求，kubectl 使用了名为<a href="https://github.com/kubernetes/kubernetes/blob/426ef9335865ebef43f682da90796bd8bf976637/docs/devel/kubectl-conventions.md#generators">生成器</a>的抽象来完成序列化过程。</p><p>可能不太明显的是，我们实际上可以使用 <code>kubectl run</code> 指定多个资源类型，而不仅仅是 Deployments。为了实现这一点，如果没有使用 <code>--generator</code> 标志显式指定生成器名称，kubectl 将<a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubectl/cmd/run/run.go#L319-L339">推断</a>出资源的类型。</p><p>例如，具有 <code>--restart-policy=Always</code> 标志的资源被视为 Deployments，而具有 <code>--restart-policy=Never</code> 的资源被视为 Pods。kubectl 还会确定是否需要触发其他操作，例如记录命令（用于滚动更新或审计），或者该命令只是通过 <code>--dry-run</code> 标志来指定的模拟运行。</p><p>在意识到我们想要创建一个 Deployment 之后，kubectl 将使用 <code>DeploymentAppsV1</code> 生成器根据我们提供的参数生成一个<a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubectl/generate/versioned/run.go#L237">运行时对象</a>。“运行时对象”是一个通用术语，用于表示资源。</p><h2 id="API-组别和版本的协商"><a href="#API-组别和版本的协商" class="headerlink" title="API 组别和版本的协商"></a>API 组别和版本的协商</h2><p>在继续之前需要指出的是，Kubernetes 使用 “API 组” 这样的版本化 API。API 组的目的是将相似的资源进行分类，以求更容易理解。它还提供了一个比单一的单体 API 更好的选择。Deployment 的 API 组名为 <code>apps</code>，最新的版本是 <code>v1</code>。这就是为什么在 Deployment 的清单的顶部需要使用 <code>type apiVersion: apps/v1</code>。</p><p>无论如何，在 kubectl 生成运行时对象之后，它开始<a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubectl/cmd/run/run.go#L674-L686">查找适当的 API 组和版本</a>，并<a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubectl/cmd/run/run.go#L705-L708">组装一个版本化的客户端</a>，该客户端知道资源的各种 REST 语义。这个发现阶段被称为版本协商，其中 kubectl 扫描远程 API 上的 <code>/apis</code> 路径，取回所有可能的 API 组。由于 kube-apiserver 在此路径上以 OpenAPI 格式公开其模式文档，所以客户端可以轻松完成 API 发现。</p><p>为了提高性能，kubectl 还将 OpenAPI 模式<a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/staging/src/k8s.io/cli-runtime/pkg/genericclioptions/config_flags.go#L234">缓存</a>到 <code>~/.kube/cache/discovery</code> 目录中。如果你想看到这个 API 发现的过程，可以尝试删除该目录，并运行一个带有最大值 <code>-v</code> 标志的命令，之后可以看到所有试图找到这些 API 版本的 HTTP 请求。有很多！</p><p>最后一步是实际<a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubectl/cmd/run/run.go#L709">发送</a> HTTP 请求。一旦发送请求并收到成功的响应，kubectl 将根据<a href="https://github.com/kubernetes/kubernetes/blob/v1.14.0/pkg/kubectl/cmd/run/run.go#L459">预期的输出格式</a>打印出成功消息。</p><h2 id="客户端认证"><a href="#客户端认证" class="headerlink" title="客户端认证"></a>客户端认证</h2><p>在之前的步骤中我们没有提到客户端认证，这是在发送 HTTP 请求之前处理的，所以现在让我们来看看这个过程。</p><p>为了成功发送请求，kubectl 需要进行身份验证。用户凭据基本上都存储在位于磁盘上的 kubeconfig 文件中，但该文件可以存储在不同的位置。为了定位它，kubectl 执行以下操作：</p><ul><li>如果提供了 <code>--kubeconfig</code> 标志，则使用该文件。</li><li>如果定义了 <code>$KUBECONFIG</code> 环境变量，则使用该变量。</li><li>否则，查找<a href="https://github.com/kubernetes/client-go/blob/release-1.21/tools/clientcmd/loader.go#L43">推荐的主目录</a>，如 <code>~/.kube</code>，并使用找到的第一个文件。</li></ul><p>解析文件后，kubectl 确定要使用的当前上下文、要指向的当前集群以及与当前用户关联的任何身份验证信息。如果用户提供了特定标志的值（例如 <code>--username</code>），则优先使用这些值，并将覆盖 kubeconfig 中指定的值。一旦获得这些信息，kubectl 将补全客户端的配置，以便适当地组装 HTTP 请求：</p><ul><li>x509 证书使用 <a href="https://github.com/kubernetes/client-go/blob/82aa063804cf055e16e8911250f888bc216e8b61/rest/transport.go#L80-L89">tls.TLSConfig</a> 发送，这也包括根 CA</li><li>Bearer token 放置在 “Authorization” HTTP 头中<a href="https://github.com/kubernetes/client-go/blob/c6f8cf2c47d21d55fa0df928291b2580544886c8/transport/round_trippers.go#L314">发送</a></li><li>用户名和密码通过 HTTP 基本身份验证<a href="https://github.com/kubernetes/client-go/blob/c6f8cf2c47d21d55fa0df928291b2580544886c8/transport/round_trippers.go#L223">发送</a></li><li>OpenID 身份验证过程由用户在之前手动处理，会生成一个像 Bearer token 一样发送的 token</li></ul><h1 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h1><h2 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h2><p>我们的请求已经发送出去了，太棒了！接下来呢？该轮到 kube-apiserver 出场了。正如我们之前提到的，kube-apiserver 是客户端和系统组件用来持久化和获取集群状态的主要接口。为了开展其工作，它需要能够验证请求者的身份。这个过程被称为身份验证。</p><p>kube-apiserver 如何对请求进行身份验证呢？当服务器首次启动时，它会查看用户提供的所有 <a href="https://kubernetes.io/docs/admin/kube-apiserver/">CLI 标志</a>，并组装一个合适的身份验证器列表。举个例子：如果传入了 <code>--client-ca-file</code> 参数，它会添加 x509 身份验证器；如果看到 <code>--token-auth-file</code> 参数，它会将 token 身份验证器添加到列表中。每次接收到请求时，它会<a href="https://github.com/kubernetes/apiserver/blob/51bebaffa01be9dc28195140da276c2f39a10cd4/pkg/authentication/request/union/union.go#L54">通过身份验证器链验证请求，直到有一个成功为止</a>：</p><ul><li><a href="https://github.com/kubernetes/apiserver/blob/51bebaffa01be9dc28195140da276c2f39a10cd4/pkg/authentication/request/x509/x509.go#L60">x509 验证处理程序</a>将验证 HTTP 请求是否使用由 CA 根证书签名的 TLS 密钥进行加密。</li><li><a href="https://github.com/kubernetes/apiserver/blob/51bebaffa01be9dc28195140da276c2f39a10cd4/pkg/authentication/request/bearertoken/bearertoken.go#L38">bearer token 验证处理程序</a>将验证 HTTP 请求中提供的令牌（在 HTTP Header 中 Authorization 字段中指定）是否存在于 <code>--token-auth-file</code> 参数指定的磁盘文件中。</li><li><a href="https://github.com/kubernetes/apiserver/blob/51bebaffa01be9dc28195140da276c2f39a10cd4/plugin/pkg/authenticator/request/basicauth/basicauth.go#L37">basic auth 验证处理程序</a>将类似地确保 HTTP 请求的基本身份验证凭据与其自身的本地状态匹配。</li></ul><p>如果每个身份验证器都失败，<a href="https://github.com/kubernetes/apiserver/blob/20bfbdf738a0643fe77ffd527b88034dcde1b8e3/pkg/authentication/request/union/union.go#L71">该请求将失败</a>，并返回一个聚合错误。如果身份验证成功，Header 中 <code>Authorization</code> 字段将被删除，并将<a href="https://github.com/kubernetes/apiserver/blob/e30df5e70ef9127ea69d607207c894251025e55b/pkg/endpoints/filters/authentication.go#L71-L75">用户信息添加</a>到其上下文中。这使得之后的步骤（例如鉴权和准入）能够访问先前确立的用户身份。</p><h2 id="请求鉴权"><a href="#请求鉴权" class="headerlink" title="请求鉴权"></a>请求鉴权</h2><p>好的，请求已经发送出去，kube-apiserver 已成功验证我们的身份。松了一口气！然而，我们还没有结束。我们可能是我们自己说的那个身份，但我们是否有权限执行此操作呢？毕竟，身份和权限是不同的。为了让请求继续执行，kube-apiserver 需要对请求进行鉴权。</p><p>kube-apiserver 处理鉴权的方式与身份验证非常相似：根据输入的标志，它将组装一个鉴权器链，针对每个传入的请求依次运行。如果所有鉴权器都拒绝请求，请求将导致 <code>Forbidden</code> 的响应，并且<a href="https://github.com/kubernetes/apiserver/blob/e30df5e70ef9127ea69d607207c894251025e55b/pkg/endpoints/filters/authorization.go#L60">不再继续处理改请求</a>。如果单个鉴权器批准请求，请求将继续进行。</p><p>Kubernetes v1.8 提供的一些鉴权器示例包括：</p><ul><li><a href="https://github.com/kubernetes/apiserver/blob/d299c880c4e33854f8c45bdd7ab599fb54cbe575/plugin/pkg/authorizer/webhook/webhook.go#L143">webhook</a>，与集群外的 HTTP(S) 服务进行交互；</li><li><a href="https://github.com/kubernetes/kubernetes/blob/77b83e446b4e655a71c315ad3f3890dc2a220ccf/pkg/auth/authorizer/abac/abac.go#L223">ABAC</a>，强制执行在静态文件中定义的策略；</li><li><a href="https://github.com/kubernetes/kubernetes/blob/8db5ca1fbb280035b126faf0cd7f0420cec5b2b6/plugin/pkg/auth/authorizer/rbac/rbac.go#L43">RBAC</a>，强制执行由管理员作为 k8s 资源添加的 RBAC 角色；</li><li><a href="https://github.com/kubernetes/kubernetes/blob/dd9981d038012c120525c9e6df98b3beb3ef19e1/plugin/pkg/auth/authorizer/node/node_authorizer.go#L67">Node</a>，确保节点客户端（即 kubelet）只能访问托管在自身上的资源。</li></ul><p>可以通过查看每个鉴权器的 <code>Authorize</code> 方法，了解它们的工作原理。</p><h2 id="准入控制"><a href="#准入控制" class="headerlink" title="准入控制"></a>准入控制</h2><p>好的，到目前为止，我们已经通过了 kube-apiserver 的身份验证和请求鉴权。那接下来呢？从 kube-apiserver 的角度来看，它相信我们是谁并允许请求继续执行，但在 Kubernetes 中，系统的其他部分对于什么应该和不应该发生有严格的要求。这时候<a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-are-they">准入控制器</a>就开始发挥作用了。</p><p>虽然鉴权的重点是判断用户是否有权限，但准入控制器拦截请求以确保其符合集群的更大范围的预期和规则。它们是对象持久化到 etcd 之前的最后一道控制屏障，因此它们封装了剩余的系统检查，以确保操作不会产生意外或负面的结果。</p><p>准入控制器的工作方式类似于验证器和鉴权器，但有一个区别：与验证器和授权器链不同，如果单个准入控制器校验失败，整个链条将中断，请求将失败。</p><p>准入控制器设计的真正精妙之处在于其专注于促进可扩展性。每个控制器都存储为 <a href="https://github.com/kubernetes/kubernetes/tree/master/plugin/pkg/admission"><code>plugin/pkg/admission</code> 目录</a>中的插件，并且被设计为满足一个小接口。然后，每个控制器都被编译到主要的 kubernetes 二进制文件中。</p><p>准入控制器通常按照功能分为资源管理、安全性、默认设置和引用一致性几类。以下是一些负责资源管理的准入控制器的示例：</p><p><code>InitialResources</code>：根据过去的使用情况为容器的资源设置默认限制。<br><code>LimitRanger</code>：为容器的请求和限制设置默认值，或对某些资源配置上限（例如内存不超过 2GB，默认为 512MB）。<br><code>ResourceQuota</code>：在命名空间内统计或拒绝分配一定数量的对象（pod、rc、service 负载均衡器）或总消耗的资源（CPU、内存、磁盘）。</p><h1 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h1><p>到目前为止，Kubernetes 已经完全检查了传入的请求，并且允许其继续执行。接下来，kube-apiserver 对 HTTP 请求进行反序列化，从中构建运行时对象（类似于 kubectl 的生成器的逆过程），并将它们持久化到数据存储中。让我们来详细解析一下这个过程。</p><p>kube-apiserver 怎么知道接受我们的请求时该做什么呢？在任何请求被处理之前都有一系列复杂的步骤。让我们从起点开始，也就是二进制文件首次运行时：</p><ol><li>当 <code>kube-apiserver</code> 二进制文件运行时，它创建一个<a href="https://github.com/kubernetes/kubernetes/blob/1795a98eebe58fcce3b9b0a8af35d10bf91cee5b/cmd/kube-apiserver/app/server.go#L174">服务器链</a>，用于支持 apiserver 的聚合。这只是支持多个 apiserver 的一种方式，我们不需要担心这个。</li><li>在这个过程中，会创建一个<a href="https://github.com/kubernetes/kubernetes/blob/1795a98eebe58fcce3b9b0a8af35d10bf91cee5b/cmd/kube-apiserver/app/server.go#L210">通用的 apiserver</a> 作为默认实现。</li><li>生成的 OpenAPI 模式补充了 <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/server/config.go#L149">apiserver 的配置</a>。</li><li>kube-apiserver 然后遍历模式中指定的所有 API 组，并为每个 API 组配置一个<a href="https://github.com/kubernetes/kubernetes/blob/c7a1a061c3dc5acabcc0c35b3b96a6935dccf546/pkg/master/master.go#L410">存储供应器</a>作为通用的存储抽象，kube-apiserver 在访问或修改资源状态时需要与其进行交互。</li><li>对于每个 API 组，它还会遍历每个组版本，并为每个 HTTP 路由<a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/groupversion.go#L92">安装 REST 映射</a>。这让 kube-apiserver 能够正常映射请求，并在找到匹配项后把请求代理给正确的逻辑处理。</li><li>对于我们的特定用例，会注册一个 <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/installer.go#L710">POST 处理程序</a>，该处理程序将进一步代理给一个<a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L37">创建资源的处理程序</a>。</li></ol><p>截至目前，kube-apiserver 已经完全了解了存在的路由和内部映射，在请求到来时能将其转发到正确的处理程序和存储供应器。现在设想我们的 HTTP 请求已经到达：</p><ol><li>如果处理程序链能够将请求与一组模式匹配（即我们注册的路由），它将把请求分发到为<a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/server/handler.go#L143">该路由注册的专用处理程序</a>。否则，它将回退到<a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/server/mux/pathrecorder.go#L248">基于路径的处理程序</a>（例如调用 <code>/apis</code> 时的情况）。如果没有为该路径注册处理程序，则会调用一个未找到的处理程序，导致返回 404 错误。</li><li>幸运的是，我们有一个名为 <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L37"><code>createHandler</code></a> 的注册路由！它的工作原理是什么呢？首先，它会解码 HTTP 请求并执行基本验证，例如确保提供的 JSON 与我们对版本化 API 资源的预期相符。</li><li><a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L93-L104">进行审计和最终的准入</a>。</li><li><a href="https://github.com/kubernetes/apiserver/blob/19667a1afc13cc13930c40a20f2c12bbdcaaa246/pkg/registry/generic/registry/store.go#L327">通过代理给存储供应器</a>将资源<a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L111">保存到 etcd 中</a>。通常，etcd 键的形式为 <code>&lt;namespace&gt;/&lt;name&gt;</code>，但这也是可配置的。</li><li>捕获任何创建时的错误，最后存储供应器执行 <code>get</code> 调用以确保对象实际上已创建。然后，如果需要进行其他的最终处理，它会调用任何创建后(Post-create)处理程序和装饰器。</li><li><a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L131-L142">构建</a>并返回 HTTP 响应。</li></ol><p>步骤很多！通过追溯这些步骤，我们能看到 apiserver 实际上做了多少工作。所以总结一下：我们的 Deployment 资源现在存在于 etcd 中。但是其中还有一些尚未完成的流程，所以目前我们还没办法看到它…</p><h1 id="初始化器"><a href="#初始化器" class="headerlink" title="初始化器"></a>初始化器</h1><p>在将对象持久化到数据存储中后，只有在一系列<a href="https://kubernetes.io/docs/admin/extensible-admission-controllers/#initializers">初始化器</a>运行完成之后，该对象才会对 apiserver 或调度程序完全可见。初始化器是与资源类型相关联的控制器，在资源对外界可见之前对资源执行相关逻辑操作。如果某个资源类型没有注册任何初始化器，则会跳过此初始化步骤，资源会立即对外可见。</p><p>正如<a href="https://ahmet.im/blog/initializers/">许多优质的博客文章</a>介绍的，这是一个强大的功能，因为它让我们能够执行通用的引导操作。例如：</p><ul><li>将代理边车容器注入到公开端口 80 的 Pod 中，或者具有特定注释的 Pod 中。</li><li>向特定命名空间中的所有 Pod 注入带有测试证书的卷。</li><li>如果一个 Secret 的长度小于 20 个字符（例如密码），阻止其创建。</li></ul><p><code>initializerConfiguration</code> 对象允许我们声明哪些初始化器应该针对特定的资源类型运行。想象一下，如果我们希望在每次创建 Pod 时运行自定义的初始化器，我们可以这样做：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">admissionregistration.k8s.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">InitializerConfiguration</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">custom-pod-initializer</span></span><br><span class="line"><span class="attr">initializers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">podimage.example.com</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="attr">apiVersions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">v1</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">pods</span></span><br></pre></td></tr></table></figure><p>创建完这个配置后，它会将 <code>custom-pod-initializer</code> 添加到每个 Pod 的 <code>metadata.initializers.pending</code> 字段中。初始化器控制器会定期扫描新的 Pods。当初始化器检测到一个 Pod 的 pending 字段中有自己的名称时，它会执行相应的逻辑。完成逻辑处理后，它会从 pending 列表中移除自己的名称。只有列表中第一个名称的初始化器才能对资源进行操作。当所有的初始化器完成逻辑处理并且 <code>pending</code> 字段为空时，该对象将被认为已经初始化。</p><p>细心的你可能已经发现了一个潜在的问题。如果资源在 kube-apiserver 中不可见，用户自定义的控制器如何处理这些资源呢？为了解决这个问题，kube-apiserver 提供了一个 <code>?includeUninitialized</code> 查询参数，它返回所有对象，包括未初始化的对象。</p><h1 id="控制循环"><a href="#控制循环" class="headerlink" title="控制循环"></a>控制循环</h1><h2 id="Deployments-控制器"><a href="#Deployments-控制器" class="headerlink" title="Deployments 控制器"></a>Deployments 控制器</h2><p>现在我们的 Deployment 记录已存储在 etcd 中，并且任何初始化逻辑都已完成。接下来的步骤涉及设置 Kubernetes 所依赖的资源拓扑结构。我们可以这样想，一个 Deployment 实际上只是一组 ReplicaSet，而一个 ReplicaSet 是一组 Pod。那么 Kubernetes 是如何通过一个 HTTP 请求来创建这样的多层级结构的呢？这其实是 Kubernetes 内置的控制器的作用。</p><p>Kubernetes 在整个系统中广泛地使用“控制器”。控制器是一个异步逻辑，用来将 Kubernetes 系统的当前状态与期望的状态进行协调(reconcile)。每个控制器都有自己的任务，并和 <code>kube-controller-manager</code> 组件一起并行运行。让我们先介绍接管工作的第一个控制器，即 Deployment 的控制器。</p><p>在 Deployment 的记录存储到 etcd 并初始化后，kube-apiserver 使其对外可见。当这个新的资源可用时，它会被 Deployment 控制器检测到，Deployment 控制器的工作是监听对 Deployment 记录的变动。在我们的例子里，控制器通过 informer 为资源新建的事件注册了一个<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/deployment/deployment_controller.go#L122">特定的回调函数</a>（有关此内容的更多信息，请参见下文）。</p><p>当我们的 Deployment 首次可用时，这个回调处理程序将被执行，并首先<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/deployment/deployment_controller.go#L170">将对象添加到内部工作队列</a>中。当控制器处理我们的对象时，它通过标签选择器查询 kube-apiserver <a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/deployment/deployment_controller.go#L572">检查</a>出我们的 Deployment 没有与之<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/deployment/deployment_controller.go#L633">关联的 ReplicaSet 或 Pod 记录</a>。有趣的是，这个同步过程是与状态无关的：新的记录和老的记录协调方式相同。</p><p>在发现没有对应的 ReplicaSet 或者 Pod 记录后，它会通过一个<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/deployment/sync.go#L385">弹性进程</a>创建一个 ReplicaSet 资源，为其分配一个标签选择器，并给它分配版本号为 1。ReplicaSet 的 PodSpec 是从 Deployment 的配置清单中复制过来的，当然也包括其他相关的元数据。在此之后，有时还需要更新 Deployment 记录（例如，如果设置了处理截止时间）。</p><p>之后会<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/deployment/sync.go#L70">更新 Deployment 的状态</a>，并重新进入相同的协调循环，直到 Deployment 达到期望的完成状态。由于 Deployment 控制器只关注创建 ReplicaSet，因此这个协调阶段需要由下一个控制器继续进行，也就是 ReplicaSet 控制器。</p><h2 id="ReplicaSets-控制器"><a href="#ReplicaSets-控制器" class="headerlink" title="ReplicaSets 控制器"></a>ReplicaSets 控制器</h2><p>在前面的步骤中，Deployment 控制器为我们的 Deployment 创建了第一个 ReplicaSet，但我们还没有看到 Pod。这之后 ReplicaSet 控制器将发挥作用！它的任务是监听 ReplicaSet 及其依赖资源（Pod）的生命周期。与大多数其他控制器一样，它通过在特定事件上触发处理程序来实现这个功能。</p><p>首先我们来看资源创建事件。当创建了一个 ReplicaSet（由部署控制器负责）时，ReplicaSet 控制器会<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/replicaset/replica_set.go#L583">检查新 ReplicaSet 的状态</a>，并发现当前状态与预期状态之间存在的差异。然后它尝试通过<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/replicaset/replica_set.go#L460">增加 ReplicaSet 的 Pod 数量</a>来调解这个状态。它非常谨慎地创建这些 Pod，确保 ReplicaSet 的突发计数（它从其父级部署继承的）始终保持匹配。</p><p>Pod 的也是<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/replicaset/replica_set.go#L487">批量创建</a>的，从 <code>SlowStartInitialBatchSize</code> 开始，每次成功创建后扩大一倍，以一种类似于“慢启动”的方式进行。这样做的目的是减轻同时出现大量 Pod 启动失败时（例如，由于资源配额不足）引发 kube-apiserver 负载过高，同时能够减少不必要的 HTTP 请求。如果组件会失败报错，我们最好以对其他系统组件的影响最小的方式来优雅地失败！</p><p>Kubernetes 通过 Owner References（这是子资源中的一个字段，用来引用其父级的 UID）来保证对象的层级结构。这不仅确保一旦由控制器管理的资源被删除，子资源就会被垃圾回收，还为父资源提供了一种有效的方式以避免它们争夺子资源（设想一下两个父级认为它们拥有同一个子资源的情况！）。</p><p>Owner Reference 设计的另一个微妙好处是它是有状态的：如果任何控制器重新启动，由于资源拓扑结构独立于控制器，它的宕机状态不会影响更多的组件。这种对隔离的关注也包含在控制器本身的设计中：它们不应该管理它们没有明确声明拥有的资源。控制器应该在所有权的声明中进行选择，并且不干扰、不共享。</p><p>无论如何，回到 Owner Reference！有时系统中会出现“孤立”(orphaned)的资源，该情况通常由以下原因导致：</p><ul><li>删除了父资源，但没有删除其子资源。</li><li>垃圾回收策略禁止删除子资源。</li></ul><p>发生这种情况时，控制器将确保孤立资源被一个新的父级资源接管。多个父级资源可以竞争接管子资源，但只有一个会成功（其余的父级资源将收到验证错误）。</p><h2 id="Informers"><a href="#Informers" class="headerlink" title="Informers"></a>Informers</h2><p>正如你可能已经注意到的那样，一些控制器（例如如 RBAC 鉴权器或 Deployment 控制器）需要查询集群状态以正常工作。以 RBAC 鉴权器为例，我们知道当请求到达时，验证器将保存用户状态的初始信息以备后用。然后，RBAC 鉴权器将使用改信息来查询用户在 etcd 中关联的所有角色以及角色绑定。控制器应该如何访问和修改这些资源？在 Kubernetes 中往往通过 informer 来解决。</p><p>informer 是一种允许控制器通过简单的订阅存储事件来获取它们关注的资源的设计范式。除了提供良好的抽象外，它还处理了许多细节，例如缓存（缓存很重要，因为它减少了与 kube-apiserver 的不必要的连接，并减少了服务器和控制器端重复序列化的开销）。通过该设计，控制器还可以用线程安全的方式进行交互，而不必担心干扰其他任何人。</p><p>有关 informer 在控制器中的工作方式的细节，可以参阅这篇<a href="http://borismattijssen.github.io/articles/kubernetes-informers-controllers-reflectors-stores">博客</a>。</p><h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><p>在上述所有控制器运行完成后，我们在 etcd 中存储了一个 Deployment、一个 ReplicaSet 和三个 Pod，并且可以通过 kube-apiserver 查询到它们。然而我们的 Pod 仍处在 <code>Pending</code> 状态，因为它们尚未被调度到节点上。解决这个问题的最后一个控制器是调度器(Scheduler)。</p><p>调度器作为控制平面的一个独立组件运行，并且以与其他控制器相同的方式工作：它监听事件并尝试调解状态。在这种情况下，调度器<a href="https://github.com/kubernetes/kubernetes/blob/master/plugin/pkg/scheduler/factory/factory.go#L190">筛选</a>出 PodSpec 中 <code>NodeName</code> 字段为空的 Pod，并尝试寻找一个适合该 Pod 的节点。</p><p>为了找到一个适合的节点，调度器使用特定的调度算法。默认调度算法的工作方式如下：</p><ol><li><p>当调度器启动时，会<a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/plugin/pkg/scheduler/algorithmprovider/defaults/defaults.go#L65-L81">注册一系列默认的谓词(Predicates)</a>。这些谓词实际上是函数，这些函数根据节点是否适合托管 Pod 来进行<a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/plugin/pkg/scheduler/core/generic_scheduler.go#L117">过滤</a>。例如，如果 PodSpec 明确要求一定的 CPU 或 RAM 资源，容量不足而无法满足这些要求的节点将被排除在 Pod 之外（资源容量计算为总容量减去当前运行容器的资源请求总和）。</p></li><li><p>一旦选择了合适的节点，会对过滤后的节点<a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/plugin/pkg/scheduler/core/generic_scheduler.go#L354-L360">运行一系列优先级函数</a>，以对它们的适合程度进行排序。例如，为了在系统中分散工作负载，调度器会倾向于资源富裕的节点（因为这表示较少的工作负载正在运行）。在运行这些函数时，它会为每个节点分配一个数值等级。然后选择排名最高的节点进行调度。</p></li></ol><p>调度算法找到节点后，调度器会<a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/plugin/pkg/scheduler/scheduler.go#L336-L342">创建一个绑定对象</a>，其 Name 和 UID 与 Pod 匹配，其 ObjectReference 字段包含所选节点的名称，然后通过 POST 请求将其<a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/plugin/pkg/scheduler/factory/factory.go#L1095">发送到 apiserver</a>。</p><p>当 kube-apiserver 接收到此绑定对象时，注册表会反序列化对象并更新 Pod 对象上的以下字段：将 NodeName <a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/pkg/registry/core/pod/storage/storage.go#L170">设置</a>为 ObjectReference 中的节点名称，<a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/pkg/registry/core/pod/storage/storage.go#L174-L176">添加相关的注解</a>，并将其 <code>PodScheduled</code> 状态条件<a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/pkg/registry/core/pod/storage/storage.go#L177-L180">设置</a>为 <code>True</code>。</p><p>一旦调度器将 Pod 调度到节点上，该节点上的 kubelet 就可以开始接管并进行部署。真是令人兴奋！</p><p>提示：自定义调度器时谓词和优先级函数都是可扩展的，并且可以使用 <code>--policy-config-file</code> 标志进行定义。这提供了一定程度的灵活性。管理员还可以在独立的 Deployment 中运行自定义调度器（具有自定义处理逻辑的控制器）。如果 PodSpec 包含 <code>schedulerName</code>，Kubernetes 将把该 Pod 的调度交给已注册在该名称下的调度器。</p><h1 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h1><h2 id="Pod-同步"><a href="#Pod-同步" class="headerlink" title="Pod 同步"></a>Pod 同步</h2><p>好的，主要的控制器循环已经完成，呼！总结一下：HTTP 请求通过了身份验证、鉴权和准入控制阶段；一个 Deployment、一个 ReplicaSet 和三个 Pod 资源被持久化到了 etcd 中；一系列初始化程序已经运行；最后，每个 Pod 被调度到了一个合适的节点上。然而到目前为止我们所有推演的状态完全存在于 etcd 中。接下来的步骤涉及将状态分发到工作节点上，这是 Kubernetes 这样的分布式系统的核心目标！接下来的过程是通过一个叫做 kubelet 的组件来实现的。我们开始吧！</p><p>kubelet 是在 Kubernetes 集群的每个节点上运行的代理程序，负责管理 Pod 的生命周期等任务。这意味着它处理了从 Pod（实际上只是 Kubernetes 的一个概念）到其构建块（容器）的所有转换逻辑。它还处理与挂载卷、容器日志、垃圾回收等相关逻辑以及许多其他重要事项。</p><p>一个便于理解的方法是：可以把 kubelet 看做一个控制器！它会每隔 20 秒（可配置）从 kube-apiserver 查询 Pod，过滤出 <code>NodeName</code> 与该 kubelet 所在<a href="https://github.com/kubernetes/kubernetes/blob/3b66adb8bc6929e1205bcb2bc32f380c39be8381/pkg/kubelet/config/apiserver.go#L34">节点名称匹配</a>的 Pod。一旦获得该 Pod 的列表，它会通过与自己的内部缓存进行比较来检测新增的 Pod，当比较存在差异时开始同步状态。我们来看看这个同步过程是什么样的：</p><ol><li>如果正在创建 Pod（我们的 Pod 正在创建中！），kubelet 会<a href="https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet.go#L1519">注册</a>一些用于在 Prometheus 中跟踪 Pod 延迟的启动指标。</li><li>然后，它<a href="https://github.com/kubernetes/kubernetes/blob/dd9981d038012c120525c9e6df98b3beb3ef19e1/pkg/kubelet/kubelet_pods.go#L1287">生成一个 PodStatus 对象</a>，表示 Pod 当前阶段的状态。Pod 的阶段是其生命周期中的高度总结。阶段包括 <code>Pending</code>、<code>Running</code>、<code>Succeeded</code>、<code>Failed</code> 和 <code>Unknown</code>。生成这个状态相当复杂，所以我们来详细了解一下具体发生了什么：</li></ol><ul><li>首先，按顺序执行一系列同步处理程序 <code>PodSyncHandlers</code>。每个处理程序都检查 Pod 是否仍应驻留在节点上。如果它们中的任何一个决定该 Pod 不再属于该节点，Pod 的阶段将<a href="https://github.com/kubernetes/kubernetes/blob/dd9981d038012c120525c9e6df98b3beb3ef19e1/pkg/kubelet/kubelet_pods.go#L1293-L1297">变为</a> <code>PodFailed</code>，并最终被从该节点中驱逐出去。例子包括在超过 <code>activeDeadlineSeconds</code> 后驱逐 Pod（在 Job 资源中常用）。</li><li>接下来，根据其初始化和实际容器的状态确定 Pod 的阶段。由于我们的容器尚未启动，容器被归为<a href="https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet_pods.go#L1244">等待状态</a>。Pod 在拥有等待容器时的阶段为 <a href="https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet_pods.go#L1258-L1261"><code>Pending</code></a>。</li><li>最后，根据容器的状态确定 Pod 的条件。由于我们的容器尚未由容器运行时创建，<a href="https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/status/generate.go#L70-L81">它将把 <code>PodReady</code> 条件设置为 False</a>。</li></ul><ol start="3"><li>生成 PodStatus 后，它将被发送给 Pod 的状态管理器，后者负责通过 apiserver 异步更新 etcd 记录。</li><li>接下来，一系列准入处理程序会确保 Pod 具有正确的安全权限。这包括校验 <a href="https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet.go#L883-L884">AppArmor 配置文件和 <code>NO_NEW_PRIVS</code></a> 等。在此阶段被拒绝的 Pod 将永远保持在 <code>Pending</code> 状态。</li><li>如果指定了 <code>cgroups-per-qos</code> 运行时标志，kubelet 将为 Pod 创建 cgroups 并应用资源参数。这是为了给 Pod 提供更好的服务质量(QoS)。</li><li>为 Pod <a href="https://github.com/kubernetes/kubernetes/blob/dd9981d038012c120525c9e6df98b3beb3ef19e1/pkg/kubelet/kubelet_pods.go#L772">创建数据目录</a>。这包括 Pod 的目录（通常为 <code>/var/run/kubelet/pods/&lt;podID&gt;</code>）、卷目录（<code>&lt;podDir&gt;/volumes</code>）和插件目录（<code>&lt;podDir&gt;/plugins</code>）。</li><li>卷管理器将<a href="https://github.com/kubernetes/kubernetes/blob/2723e06a251a4ec3ef241397217e73fa782b0b98/pkg/kubelet/volumemanager/volume_manager.go#L330">绑定并等待</a> Spec.Volumes 中定义的所有相关卷。根据要挂载的卷的类型的不同，某些 Pod 可能需要等待更长时间（例如云存储或 NFS 卷）。</li><li><a href="https://github.com/kubernetes/kubernetes/blob/dd9981d038012c120525c9e6df98b3beb3ef19e1/pkg/kubelet/kubelet_pods.go#L788">从 apiserver 中查询</a>在 <code>Spec.ImagePullSecrets</code> 中定义的所有密钥，以便后续注入到容器中。</li><li>最后由容器运行时(CRI)来运行容器（下面将详细描述）。</li></ol><h2 id="CRI-和暂停容器"><a href="#CRI-和暂停容器" class="headerlink" title="CRI 和暂停容器"></a>CRI 和暂停容器</h2><p>我们现在已经完成了大部分的配置工作，容器已经准备好启动了。负责启动容器的软件被称为容器运行时（例如 <code>Docker</code> 或 <code>rkt</code> ）。</p><p>为了更好的扩展性，自 Kubernetes v1.5.0 以来，kubelet 一直在使用称为 CRI（Container Runtime Interface）的概念与具体的容器运行时进行交互。简而言之，CRI 提供了 kubelet 与特定运行时实现之间的抽象接口。通信通过 <a href="https://github.com/google/protobuf">protocol buffers</a> 完成（类似于更快的 JSON），并使用 <a href="https://grpc.io/">gRPC API</a>（一种非常适合执行 Kubernetes 操作的 API 类型）。这是一个非常酷的想法，因为通过使用 kubelet 和容器运行时之间的定义合约，容器编排的具体实现细节变得相对不重要，唯一重要的是合约。这使得可以用最小的开销添加新的运行时，因为我们不需要更改核心 Kubernetes 代码！</p><p>话题岔开太远了，让我们回到部署容器的过程本身。当一个 Pod 首次启动时，<a href="https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/pkg/kubelet/kuberuntime/kuberuntime_sandbox.go#L51">kubelet 调用 RunPodSandbox</a> 远程过程调用（RPC）。沙盒 Sandbox 是 CRI 术语，用来描述一组容器，在 Kubernetes 术语中就是一个 Pod。这个术语被刻意地设计得比较模糊，以便对于其他可能实际上不使用容器的运行时（比如基于虚拟化的运行时，其中的沙盒可能是一个虚拟机）也适用。</p><p>在我们的例子中，我们使用的是 Docker。在这个运行时中，创建一个沙盒其实是创建一个暂停容器。暂停容器作为 Pod 中所有其他容器的父容器，承载了许多工作负载容器将要使用的 Pod 级资源。这些“资源”是 Linux 的命名空间（IPC、网络、PID）。如果你对 Linux 中容器的工作原理不熟悉，我们进行一个简短的复习。Linux 内核具有命名空间的概念，允许主机操作系统划分出一组专用资源（例如 CPU 或内存），并将其提供给一个进程，就好像它是世界上唯一使用这些资源的进程一样。在这里，Cgroups 也很重要，因为它们是 Linux 管理资源分配的方式（有点像监管资源使用的警察）。Docker 使用这两个内核特性来运行具有足够资源和强制隔离的进程。要了解更多信息，请查看 b0rk 的精彩文章<a href="https://jvns.ca/blog/2016/10/10/what-even-is-a-container/">《容器到底是什么》</a>。</p><p>暂停容器提供了一种托管所有这些命名空间并允许子容器共享它们的方式。处在同一个网络命名空间的好处是同一个 Pod 中的容器可以使用 localhost 相互引用。暂停容器的第二个角色与 PID 命名空间的工作原理有关。在这些类型的命名空间中，进程形成一个层次树，顶部的初始化进程负责“清理”已经退出的进程。要了解这是如何工作的更多信息，请查看这篇<a href="https://www.ianlewis.org/en/almighty-pause-container">精彩的博客</a>。在创建完暂停容器后，它会被存档到磁盘上，并启动运行。</p><h2 id="CNI-和-Pod-通信"><a href="#CNI-和-Pod-通信" class="headerlink" title="CNI 和 Pod 通信"></a>CNI 和 Pod 通信</h2><p>现在，我们的 Pod 已经有了个基本的骨架：一个承载所有命名空间以实现跨 Pod 通信的暂停容器。但是其中的网络是如何生效的，又该如何进行设置呢？</p><p>当 kubelet 为一个 Pod 设置网络时，它将任务委派给一个名为 CNI 的插件。CNI 代表容器网络插件 Container Network Interface，其工作方式类似于 Container Runtime Interface。简而言之，CNI 是一个抽象层，允许不同的网络供应程序使用不同的容器网络实现。kubelet 通过将 JSON 数据（配置文件位于 <code>/etc/cni/net.d</code>）经过 stdin 传送给相关的 CNI 二进制文件（位于 <code>/opt/cni/bin</code>）与注册好的插件进行交互。这是一个 JSON 配置的示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cniVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.3.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;bridge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cnio0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;isGateway&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ipMasq&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ipam&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;host-local&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ranges&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">[</span><span class="punctuation">&#123;</span> <span class="attr">&quot;subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;POD_CIDR&#125;&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;routes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span> <span class="attr">&quot;dst&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0/0&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>它还通过环境变量 <code>CNI_ARGS</code> 指定了 Pod 的附加元数据，例如它们的名称和命名空间。</p><p>接下来发生的步骤取决于具体的 CNI 插件，我们先来看看网桥(<code>bridge</code>) CNI 插件的工作流程：</p><ol><li>首先，网桥插件将在主机的根网络命名空间中设置一个本地 Linux 网桥（bridge），以服务于该主机上的所有容器。</li><li>然后，它将在暂停容器的网络命名空间中插入一个接口（一对 veth 的一端），并将另一端连接到网桥（bridge）上。最好将一对 veth 想象成一个大管道：一端连接到容器，另一端在根网络命名空间中，使得数据包在两者之间进行传递。</li><li>接下来，网桥插件应该为暂停容器的网卡分配一个 IP 地址并设置路由，这使得 Pod 拥有了自己的 IP 地址。IP 地址分配是委派给在 JSON 配置中指定的 IPAM 提供程序来完成的。</li></ol><ul><li>IPAM 插件与主要的网络插件类似：它们通过二进制文件调用，拥有标准化的接口。每个 IPAM 插件必须确定容器接口的 IP&#x2F;子网，以及网关和路由，并将这些信息返回给主插件。最常见的 IPAM 插件称为 <code>host-local</code>，它从预定义的地址范围中分配 IP 地址。它将状态存储在主机的文件系统上，以确保在单个主机上 IP 地址的唯一性。</li></ul><ol start="4"><li>至于 DNS，kubelet 将向 CNI 插件提供内部 DNS 服务器的 IP 地址，CNI 插件将确保容器的 <code>resolv.conf</code> 文件设置正确。</li></ol><p>上述步骤都完成后，CNI 插件会向 kubelet 返回 JSON 数据说明操作的结果。</p><h2 id="跨节点通信"><a href="#跨节点通信" class="headerlink" title="跨节点通信"></a>跨节点通信</h2><p>到目前为止，我们已经解释了容器如何连接到主机，但主机之间如何通信呢？当位于不同机器上的两个 Pod 想要通信时，就自然会涉及节点间的通信。</p><p>通常，节点间通信是通过一种称为覆盖网络（overlay networking）的概念实现的，它是一种在多个主机之间动态同步路由的方式。一个流行的覆盖网络供应者是 Flannel。安装完成后，它的核心任务是在集群中的多个节点之间提供第 3 层的 IPv4 网络。Flannel 不控制容器如何与主机进行网络连接（这是 CNI 的工作，请记住），而是控制主机之间的流量传输。为此，它为主机分配一个子网，并在 etcd 中注册这个子网。随后，它保持集群路由的本地表示，并将传出数据包封装在 UDP 数据报中，确保其到达正确的主机。要了解更多信息，请参阅 <a href="https://github.com/coreos/flannel">CoreOS 的文档</a>。</p><h2 id="容器启动"><a href="#容器启动" class="headerlink" title="容器启动"></a>容器启动</h2><p>所有关于网络的过程都已经介绍了。接下来还剩下什么呢？好吧，我们需要真正地启动工作负载容器。</p><p>一旦沙盒初始化完成并处于活动状态，kubelet 就可以开始为其创建容器。它首先启动在 PodSpec 中定义的<a href="https://github.com/kubernetes/kubernetes/blob/5adfb24f8f25a0d57eb9a7b158db46f9f46f0d80/pkg/kubelet/kuberuntime/kuberuntime_manager.go#L690">所有 init 容器</a>，然后再启动主要的容器本身。具体过程如下：</p><ol><li><a href="https://github.com/kubernetes/kubernetes/blob/5f9f4a1c5939436fa320e9bc5973a55d6446e59f/pkg/kubelet/kuberuntime/kuberuntime_container.go#L90">拉取容器的镜像</a>。PodSpec 中定义的加密信息（secrets）都将用于私有的镜像仓库；</li><li>通过 CRI <a href="https://github.com/kubernetes/kubernetes/blob/5f9f4a1c5939436fa320e9bc5973a55d6446e59f/pkg/kubelet/kuberuntime/kuberuntime_container.go#L115">创建容器</a>。沙盒会先从父 PodSpec 中生成一个 ContainerConfig 结构体（其中定义了命令、镜像、标签、挂载点、设备、环境变量等），然后通过 protobuf 将其发送给 CRI 插件。以 Docker 举例，它会反序列化有效的负载并生成自己的配置结构以发送到 Docker 的守护进程 API。在此过程中，它会向容器中注入一些元数据标签，例如容器类型、日志路径、沙盒 ID。</li><li>然后，它将使用 CPU 管理器（CPU manager）注册容器。CPU 管理器是 1.8 中的一个新的 alpha 功能，它使用 <code>UpdateContainerResources</code> CRI 方法将容器分配到本地节点上的一组 CPU。</li><li>接下来容器被<a href="https://github.com/kubernetes/kubernetes/blob/5f9f4a1c5939436fa320e9bc5973a55d6446e59f/pkg/kubelet/kuberuntime/kuberuntime_container.go#L135">启动</a>。</li><li>如果注册了任何后启动（post-start）的容器生命周期钩子，它们将被<a href="https://github.com/kubernetes/kubernetes/blob/5f9f4a1c5939436fa320e9bc5973a55d6446e59f/pkg/kubelet/kuberuntime/kuberuntime_container.go#L156-L170">执行</a>。钩子可以是 <code>Exec</code> 类型（在容器内执行特定命令）或 <code>HTTP</code> 类型（针对容器端点执行 HTTP 请求）。如果 PostStart 钩子运行时间过长、挂起或失败，容器将永远无法变成 <code>running</code> 状态。</li></ol><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>好的，终于完成了。</p><p>经过所有这些步骤，我们应该在一个或多个工作节点上运行着 3 个容器。所有的网络、卷和加密信息都已由 kubelet 配置完成，并通过 CRI 插件转换为容器。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reading </tag>
            
            <tag> CloudNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用两年读完《白鹿原》</title>
      <link href="/2023/12/31/WhiteDeerPlain/"/>
      <url>/2023/12/31/WhiteDeerPlain/</url>
      
        <content type="html"><![CDATA[<p>陈忠实先生花了六年时间著出《白鹿原》这部巨作，而我却前前后用了近两年时间才读完这部作品，实在惭愧。因为用的是“微信读书”读的电子书，阅读记录都有存储在其平台上，才能得知我原来在 2022 年看完《杀死一只知更鸟》之后就开启了《白鹿原》。然而，过去在学校因为事情众多难以聚焦到“读闲书”上，所以 2022 年的 2 月开启这部书的阅读，走入白鹿原的广袤天地之后就一度搁置。</p><p>直到 2023 年毕业工作后的某个瞬间，决定要重拾读书计划之后才想起在一年前的某个时间我曾读过这本书的三分之一。过去了这么长时间，我还能明确地记得我读到三分之一的节点是白灵和鹿兆海用掷铜钱的形式分别投身国共两党追求理想而愉快分别的场景，再次拾起此书时两人分别时欣喜的场景还历历在目，但后来的结局竟是如此，实在令人惋惜…</p><p>过去没有写读后感的习惯，最多在中学时因为看书中人物罹难后过于激动而在 QQ 空间发动态抒怀。但不得不说毕业后独居的生活给予了我更多的思考时间，让我能够在品读作品之余思索其中深意，感慨书中角色之悲壮或卑劣，也算是双面硬币里好的一面了。</p><p>向外输出是向内消化的高级姿态，我希望通过写出自己的感受加深自己对作品的理解。</p><span id="more"></span><h1 id="白鹿原之白鹿"><a href="#白鹿原之白鹿" class="headerlink" title="白鹿原之白鹿"></a>白鹿原之白鹿</h1><h2 id="白鹿精魂"><a href="#白鹿精魂" class="headerlink" title="白鹿精魂"></a>白鹿精魂</h2><p>《白鹿原》中最具神话色彩的便是多次出场的白鹿精魂，每次露面总能带来祥瑞之兆：是白嘉轩看中天字宝地时的灵光乍现，是久旱逢甘露的峰回路转，是瘟疫肆虐时的杀毒祛邪，更是白灵托梦时的凄惨和不舍。白鹿是白鹿原的神，“白毛白腿白蹄，那鹿角更是莹亮剔透的白”，如此洁白无瑕的形态本身就预示着其极其圣洁的存在。</p><p>因为白嘉轩是主角，所以白鹿总是围绕着他腾挪欢跃，事实上每个人都有自己的白鹿，都有属于自己的精灵。白鹿的存在是预示着灾厄、苦难和煎熬终将抵达终点，上天会眷顾勤劳勇敢的人们。白嘉轩一辈子行事光明磊落，从不堕入歪门邪道，坚毅刚强，从不落人把柄，成人后作为一族之长秉持着家族的尊严和荣耀，尽管有时其作为族长摆出的架子让人看起来封建古板、不尽人意，但其行为处事最后往往能够收获不坏的结果，足以深孚众望，让他在几十年的族长位子上坐得稳稳当当。<br>贯穿全书的是白嘉轩如同上帝一般的全局视角，无论经历什么灾祸或是幸事，总能够达到波澜不惊、宠辱偕忘的境地，只有在亲人遭遇苦难和不幸时才会流露出一丝失措和动容。<br>我无法想象他是用一种怎样强大的心态来面对周遭世事的，是半生的经历让他有了足够的见识阅历不至于慌张，还是心中一直装着何种信仰？我不认为我在知天命之年能有他那般姿态，或者永远不会。或许白嘉轩和白鹿一样，他们的存在是这整部作品里唯一不现实的意象吧。</p><h2 id="白和鹿"><a href="#白和鹿" class="headerlink" title="白和鹿"></a>白和鹿</h2><p>白嘉轩和鹿子霖的家族恩怨贯穿了整部作品，虽然众多事件仅发生在白鹿原上的小村落里，但其中的复杂程度远超我所看过的宫斗剧。族长白嘉轩取了七房妻子才最终留下后人，令人可笑又可叹；他为了得到天字号宝地，不惜跟鹿家以多换少，双方都以为自己稳赚不赔······</p><p>白嘉轩总是以德报怨，以德服人，不求功名，爱护族人，有底线有原则，虽然思想保守不求变革，但把众多家风传统很好地传承给了下一代，文武义三兄弟都沐浴在这种家风之中四平八稳地生活着，少走弯路。</p><p>而鹿子霖则是在相反的方向几乎走到了极端。因为族长位置始终被白家占据，鹿子霖为了“平衡”这种局势，始终极为贪恋权力，从乡约做到保长，坏事做尽。欺上瞒下，狐假虎威，没有底线，贪恋财色，色厉内荏，可以形容他的贬义词汇实在太多，但不得不认清的是：或许他的子集才是彼时此地较为常见且现实的封建家长形象。乐观来讲，我相信不是所有人都有他那么坏，但他的坏是众人之恶的集合，把他拆开揉碎了，就是白鹿原上的所有普通人。</p><p>鹿子霖始终期望能够在面子和里子上赢过白嘉轩，但结果总是过犹不及。直到最后鹿子霖被白孝文主持的枪毙大会吓疯后在路边捡拾吃食，用疯癫的语气询问路过的白嘉轩是否要尝尝他的珍馐美味，这场持续半个世纪的与白嘉轩的争斗才遗憾告负。此时的白嘉轩也叹息坦白道他这辈子光明磊落，唯独只背着鹿子霖做过一件对不起他的事，也不过是买下鹿家一块地用来做坟。鹿子霖父亲被土匪杀害时他没疯，鹿子霖二儿子鹿兆海战死时他没疯，鹿子霖锒铛入狱坐了两年大牢他没疯，偏偏在解放后白孝文作为县长主持的批斗会后发疯，不是因为他不够坚强或是胆小如鼠，而是他奋斗了一生的、希望赢过白家的目标，被白嘉轩的从容不迫、白孝文的位高权重和靠山田福贤的倒塌而变得不可实现。压在鹿子霖心中的大山没有移走反而更加厚重，常年如履薄冰的他终于堕入了冰冷的水中。</p><h2 id="人与原"><a href="#人与原" class="headerlink" title="人与原"></a>人与原</h2><p>“白嘉轩就是白鹿原”，这是陈忠实先生在《白鹿原》的后记中提到的。这一说法也自然地解答了我的疑惑，为什么我认为白嘉轩是如同神一样的存在，正因为他在任何时候都能足够稳定、冷静和从容地分析决断，体面地处理家里和族中的大小事务，令人心悦诚服，到头来发现其所做出的决断带来的结果总是不赖。此般沉着稳重和波澜不惊俨然如黄土高原积攒千万年巍然不动的黄土，深厚且沉静。虽然没有去过西北，没亲眼见过黄土高原，但凭借零星的影视作品和我单薄的想象力，也能够在脑海中描绘其壮观雄浑的景象。</p><h1 id="田小娥和他的四个男人"><a href="#田小娥和他的四个男人" class="headerlink" title="田小娥和他的四个男人"></a>田小娥和他的四个男人</h1><p>我讨厌田小娥。她是个不知廉耻、人人唾弃的“婊子”，是宁静乡村里和谐生活的毒药，是男人淫欲贪欲的放大器。他一生和很多男人有过纠葛，吸引和释放着男人的欲望，自由且作恶的一生被公公残酷终结，最终化作魂魄也被镇压在高塔之下，不得安生。田小娥是自由的，是进步的，是开放的，但在那个年代自由、进步、开放的就是“婊子”。而封建社会的女人家最好就是安安分分嫁出去，在婆家勤勤恳恳服侍丈夫和公婆。可恨之人亦有可怜之处，田小娥错就错在于那样的年代投胎成为了白鹿原上的女子。</p><h2 id="郭举人"><a href="#郭举人" class="headerlink" title="郭举人"></a>郭举人</h2><p>田小娥作为郭举人的小妾，并没有得到郭举人的一丝宠爱或“临幸”，而被当做了工具——“泡枣”的容器。读到这里我感到非常震撼，一是感叹旧社会底层的人不配做人，二是认为这样的食物不健康不卫生，让我作呕。我起初其实非常不理解家境不差的田秀才为什么会把自己的女儿委身到年近半百的郭举人家中去，读书人应当是知书达理的，是思想进步开放的，为什么会做出这样不可理喻的决定的？后来我明白了，田秀才读的书不能让他体恤他人、理解女儿，只是让他成为庸儒，成为唯上的学问家，宁可和其他读书人向上兼容地“联姻”，也不愿向下从庄稼汉里找亲家。这样迂腐的学问早就应当和这样迂腐的王朝一同被推到历史的垃圾桶里。</p><h2 id="黑娃"><a href="#黑娃" class="headerlink" title="黑娃"></a>黑娃</h2><p>前半生坏事做尽，后半生浪子回头。</p><p>黑娃，鹿兆谦，从小到大没干过一件体面、冷静的事情，但在百年前的农村环境下，其敢于和田小娥私奔回家甚至期望和田小娥拜堂成亲，已经表现出其独特的勇气和魄力。黑娃拥有一种未经驯化的、没有规则的、充满棱角的勇气和魄力，这样的特质也让他之后闹农协、搞暴动、入军队、当土匪等一些行为都变得顺理成章自然而然。他的勇敢是值得赞赏的，但其对田小娥始乱终弃的行为间接导致了田小娥的进一步堕落。黑娃闹农协出走之后几乎没有回过白鹿原，更不用说再回到那个冰冷又温暖的窑洞。他们的窑洞今后会有若干的、爱黑娃的、憎黑娃的男人会踏足，可黑娃在田小娥死之前却始终不曾回来过。</p><p>黑娃从山里被招安到保安团后发生的转变我愿称为奇迹，突然从直率莽撞、目无法纪的土匪变成了文质彬彬、一心想学的温柔君子。向贤者朱先生认真求学并得到了朱先生的高度赞扬，“我最好的弟子竟然是一个土匪”。而我以为黑娃会有个很好的结局，可是没想到和白灵一样，好人没有落到好的下场。属实让我觉得惋惜。</p><h2 id="鹿子霖"><a href="#鹿子霖" class="headerlink" title="鹿子霖"></a>鹿子霖</h2><p>鹿子霖与白鹿村及周边村子的几十名女子有染，据说如果其私生子、干儿子齐聚一堂的话需要坐好几桌。田小娥便是这些与鹿子霖有染的女子之一。但鹿子霖对田小娥完全没有情感，就是嫖客和妓女的关系，或者是工人和工具的关系，虽然在这样的关系当中他们也曾和谐和快乐过。鹿子霖周期性地来到田小娥的窑洞与其偷情，顺便施以小恩小惠，让田小娥糊涂地以为这段关系能长久持续。快乐并不长久，美人计得逞之后的鹿子霖得意忘形：田小娥在她眼里从来都不是能够平等交流的人。“兔死狗烹”的想法流露出来之后田小娥给了他一巴掌，这整本书唯一的一次女人扇向男人的耳光，竟然是田小娥挥向鹿子霖的。</p><h2 id="白孝文"><a href="#白孝文" class="headerlink" title="白孝文"></a>白孝文</h2><p>白孝文完全沦陷于荡妇田小娥没有底线没有原则的攻势，这是被包办婚姻的他没有品尝过的激情与爱意。白嘉轩给儿子们娶媳妇时看重的是这位女子能够给家庭带来什么，并不会考虑儿子们的喜恶，娶回来的媳妇自然就不一定得到儿子的疼爱。所有的包办婚姻都是如此。先结婚生子再谈感情，或者不用谈感情的情况比比皆是，两人举案齐眉、相敬如宾，客客气气地深受家长喜爱，但就是不讨白孝文喜欢。而田小娥的身体和话语则让白孝文魂牵梦绕挥散不去，以至于最后跟家里闹得妻离子散，分家后变卖家产也不给他的原配夫人一分一毫，甚至其饥荒饿死也不曾引来白孝文的一丝悔恨和一滴泪水。</p><p>白孝文是田小娥罪恶的巅峰，也是其性命走向终点的引线。忠厚善良的鹿三为了结这一切荒谬的闹剧，在一个夜里把田小娥给杀死了…</p><h1 id="鹏海之于白灵"><a href="#鹏海之于白灵" class="headerlink" title="鹏海之于白灵"></a>鹏海之于白灵</h1><p>白灵的死让我意难平但又难以评价，但写到这里其实已经没有太多表达欲了。不知道为什么在阅读白灵、鹿兆海和鹿兆鹏的故事情节时我总能联想到几年前玩过的《隐形守护者》，可能国共两党从合作到决裂，国民党反动派肆意屠杀异见者的情节总是让人想到谍战吧，但不同的是白灵是这部谍战片中的女主角。鹿兆海像个小孩，革命上和感情上跟白灵打了一辈子的赌；白灵却早就长大成人，在战乱的年代选择了革命爱情。白灵是崭新的、向上的、自由的、进步的、顽强的、不屈的、喷薄的、新中国的新一代的力量，她的选择必定成功。</p><p>最后，为什么鹿兆鹏与怀孕中的白灵告别后再也没有出现，没有救下因猜忌而惨死的白灵，是我读这部作品的不解和遗憾。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>《白鹿原》描绘了从清末到新中国近半个世纪的时间跨度下，白鹿原中白家和鹿家两代人的牵扯和纠葛，刻画了白嘉轩、白孝文、鹿子霖、田小娥、鹿兆鹏、鹿兆海、黑娃等栩栩如生的形象，展现了国共两党从北伐蜜月期到国民党临阵倒戈的暗流涌动和真刀真枪，揭示了旧社会旧中国把女人当工具，把穷人当牲口的丑恶面目，由点及面地从白鹿原小家族入手讲述了整个中国农村环境的变迁，是一部恢弘的史诗，也是一部写实的影集，值得思索和品味。</p><p>题外话，看完《平凡的世界》和《白鹿原》两部作品后，真心希望自己能够抽出时间游览大西北，领略大家笔下的黄土高原是何等的伟壮。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rFTP - 用 Rust 实现简单的 FTP Server (1)</title>
      <link href="/2023/01/20/RFTP-1/"/>
      <url>/2023/01/20/RFTP-1/</url>
      
        <content type="html"><![CDATA[<h1 id="开发动机"><a href="#开发动机" class="headerlink" title="开发动机"></a>开发动机</h1><p>核心动力是我有<strong>学会一门系统级编程语言的梦想</strong>。所以计划用 Rust 为开发语言（手段）完成本科三年级计算机网络专业课上的 FTP 大作业（目标），学习 Rust 的同时巩固计网的基础知识。</p><p>虽然大一刚入学就开始接触 <code>C/C++</code>，但是对于当时没有任计算机知识何积累的我来说用这样的方式开始我的编程入门实在是颇为残忍。或许我当时连内存大小和磁盘容量都分不清，不知堆栈为何物，也搞不懂什么编译链接，让我去理解指针实在是有点为难。现在回过头来看，当时的教学顺序对零基础的学生来说是不太友好的：老师在讲指针结构的内存优化时我甚至还写不出像样的符合语法的程序，课程内容就自然也就无法很好地消化了。</p><p>如果由我来制定教学计划，我一定将最开始的编程入门课定为使用 Python 教学而不是 C&#x2F;C++，在知道如何写出鲁棒、高效、优雅的代码前，先要做到能写代码，就好似学会跑步之前需要先学会走路；等学生们了解了计算机组成原理、操作系统等计算机基础知识之后（或同时），再教授 C&#x2F;C++ 等较低层的、系统的编程语言了。话扯太远了，就此打住。</p><span id="more"></span><p>因为当时的无知无能，我在大学前两年的专业课学习中并没有把基础打牢，现在希望可以通过恶补计算机知识来抢救一下，而与此同时我也希望选择一门系统级语言来作为接触计算机底层的抓手，我对 C&#x2F;C++ 有些 PTSD，Golang&#x2F;Java 又太面向应用构建了，所以选择了社区里比较火的 Rust 来入门，可能本质上这也是一种跟风吧。</p><h1 id="Rust-基础"><a href="#Rust-基础" class="headerlink" title="Rust 基础"></a>Rust 基础</h1><p>Rust 的<code>所有权</code>和<code>生命周期</code>机制是它很重要的亮点，同时也是难以上手的概念；Rust 拥有强大的枚举值机制，配合上全面的模式匹配，使得程序控制流和错误处理变得灵活优雅，Golang 没有枚举类型的情况有时显得捉襟见肘；另外和 C++ 不同，Rust 没有继承的概念，而是和 Golang 类似采取“组合大于继承”“组合而非继承”的方式来达到面向对象的目标，以<a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">取得更高的编码灵活度</a>。</p><h2 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h2><p>Rust 所有权三条基本规则：</p><ol><li>每个值都有一个所有者；</li><li>同一时间只允许存在一个所有者；</li><li>当所有者离开作用域，值会被抛弃(drop)。</li></ol><p>离开作用域之后，变量会被释放掉(<code>drop</code>)；直接赋值会导致右值的所有权被剥夺；如果只希望借用变量的值，可以使用 <code>&amp;</code> 符号进行借用，如 <code>&amp;var</code> 表示变量的只读借用，而 <code>&amp;mut var</code> 表示变量的可写借用，同一个作用域中只允许存在一个可写借用；可写借用创建出来且仍在存活时，后续再创建的只读借用就会失效（或者编译器编译失败）。</p><p>存放在栈上的基本类型可以通过 <code>Copy</code> 特征自动的进行复制，而不是转移所有权。Rust 不允许在实现了 <code>Drop</code> 特征的类型上标注 <code>Copy</code> 特征，编译器会提示编译错误。也就是说 <code>Copy</code> 特征只<strong>复制栈上的数据</strong>。</p><p>除了完全存放于栈上的基本数据类型以外，大部分类型都是主体数据存放于堆上，索引（或者叫指针）在栈上，此时通过 Copy 只会实现指针的复制，堆上的主体数据不会有变化。这时就要借助 <code>Clone</code> 特征来实现堆栈上数据的完全克隆。</p><p>利用切片机制可以引用一个连续元素集合当中的部分内容，需要注意的是<strong>切片是引用，并没有值的所有权</strong>。特别地，<code>String</code> 类型的切片类型写作 <code>&amp;str</code>。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Rust 生命周期基本三条准则：</p><ol><li>Rust 编译器会给函数所有的输入变量赋予一个生命周期</li><li>如果只有一个输入变量，Rust 编译器会给输出的值赋予这个输入变量的生命周期</li><li>如果函数的参数当中有 <code>&amp;self</code> 或者 <code>&amp;mut self</code>，说明这个函数是个方法，此时会给所有的输出值赋予 <code>&amp;self</code> 相同生命周期，以方便编写方法函数，因为这样可以少写很多生命周期符号</li></ol><h2 id="结构体与特征"><a href="#结构体与特征" class="headerlink" title="结构体与特征"></a>结构体与特征</h2><p>在 Rust 中没有 <code>class</code> 关键字，而是不约而同地和 Golang 一样选用了 <code>struct</code> 结构体作为数据整合与面向对象的主要载体。通过 <strong>struct typeName {}</strong> 代码块可以定义一个结构体，通过 <strong>impl typeName {}</strong> 代码块可以为该结构体定义和实现内部的方法(methods)。在方法中定义第一个参数为 <em>&amp;self</em> 表示只读引用实例，如果定义为 <em>&amp;mut self</em> 则表示可编辑地引用实例，如果没有传入 <em>self</em> 参数则表示为<strong>类方法</strong>，需要用 <code>typeName::methodName</code> 的形式调用。</p><p>为了将多个结构体之间可能存在的共有方法进行抽象，Rust 提供了特征(trait)机制。Rust 的 trait 与 Java&#x2F;Golang 当中的 interface 类似，结构体通过实现特征，在某些函数中能够当作该特征的实例变量使用，为结构体实现特征的代码片段为 **impl traitName for typeName {}**。值得注意的是，在定义 trait 时可以给方法提供默认实现，结构体需要把特征当中的不包含默认实现的方法全都实现才能算作实现了该特征，不能部分实现。</p><p>在入参和返回值类型中标记实现某个特征的语法如下，配合泛型一起食用口感更佳：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 impl 关键字说明特征</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用泛型约束</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item: &amp;T) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多个特征的约束</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;(<span class="keyword">impl</span> <span class="title class_">Summary</span> + Display)) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 where 关键字说明类型特征</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">    U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>,</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">// 泛型结构体针对特定特征的实现</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T, y: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// some implementations</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举类型及模式匹配"><a href="#枚举类型及模式匹配" class="headerlink" title="枚举类型及模式匹配"></a>枚举类型及模式匹配</h2><p>Rust 有很强的枚举类型机制，感觉是另一类的结构体，配合 <code>match</code>, <code>if let</code> 等关键字可以优雅地实现控制流和错误处理。定义枚举类型的方式和定义结构体几乎完全一致，使用枚举可以使得相同用途的类型在逻辑上和空间上两个维度上更加紧凑。从各种角度来看枚举和结构体都非常相似，我们甚至可以给枚举类型实现方法。</p><p>模式匹配主要依赖 <code>match</code> 和 <code>if let</code> 两个关键字。其中 <code>match</code> 和其他语言中的 <code>switch/case</code> 语法是类似的，只不过 Rust 要求 <code>match</code> 必须<strong>穷尽所有的枚举情况</strong>，即强制写出 <strong>default</strong> 分支。这也合理，以编译严格著称的 Rust 不允许潜在的不可达状态。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">    _ =&gt; <span class="title function_ invoke__">reroll</span>(), <span class="comment">// 抛弃默认值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">    other =&gt; <span class="title function_ invoke__">move_player</span>(other), <span class="comment">// 使用默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if let</code> 是单分支、更精准的 <code>match</code>，如果匹配的枚举值符合预期就会进入到相应的语句块里执行相应的语句，其代码块为 **if let Some(var) &#x3D; some_option {}**。</p><h1 id="rFTP-开发"><a href="#rFTP-开发" class="headerlink" title="rFTP 开发"></a>rFTP 开发</h1><h2 id="开发计划"><a href="#开发计划" class="headerlink" title="开发计划"></a>开发计划</h2><p>因为自己还有课题组的开发任务，业余时间也不多，所以 rFTP 的开发计划也比较宽松随性，突出一个“重在参与”。计划迭代两期，其中第一期包括基本的 FTP 指令如：</p><ul><li><code>USER/PASS</code>，指定用户名和密码登录</li><li><code>PORT/PASV</code>，主动和被动模式的数据端口指定</li><li><code>RETR/STOR</code>，存取文件</li><li><code>ABOR/QUIT</code>，断开连接</li><li><code>SYST/TYPE</code>，获取服务器信息</li><li><code>RNFR/RNTO</code>，文件重命名</li><li><code>PWD/CWD/MKD/RMD</code>，切换当前会话的所在目录</li><li><code>LIST</code>，列出当前目录文件列表</li></ul><p>迭代的第二期计划加入相对高级的指令：</p><ul><li><code>REST</code>，断点续传</li><li><code>DELE</code>，删除文件</li><li><code>STOU</code>，唯一存储</li><li><code>APPE</code>，追加写</li><li><code>ALLO</code>，预留存储空间</li></ul><h2 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I&#x2F;O 多路复用"></a>I&#x2F;O 多路复用</h2><p>本科期间用 <code>C</code> 写 FTP Server 时跟风使用 epoll 来达到 I&#x2F;O 多路复用的效果，当时对于 I&#x2F;O 多路复用处于完全不明白的状态。现在对其一知半解，也打算在 rFTP 中引入这样的机制。因为是在 macOS 上开发，尝试引入 epoll 后代码无法正常编译运行，查阅相关资料才发现 macOS 并不支持 epoll，而是单独开发维护一个文件系统事件库叫 kqueue 来实现类似的功能。</p><p>为了 rFTP 的可移植性，同时也为了省心，我自然地选择引入了 Rust 的异步运行时 <code>Tokio</code> 来达到 I&#x2F;O 多路复用、异步编程、多线程的实现目标。目前对 <code>Tokio</code> 的认识还停留在上手阶段，没有做深入了解和 Benchmark，不太敢说其性能如何如何，以下是 <code>Tokio</code> <a href="https://docs.rs/tokio/latest/tokio/">文档中的介绍</a>，看起来让人安心。</p><blockquote><p><strong>A runtime for writing reliable network applications without compromising speed.</strong><br>Tokio is an event-driven, non-blocking I&#x2F;O platform for writing asynchronous applications with the Rust programming language. At a high level, it provides a few major components:</p></blockquote><ul><li>Tools for working with asynchronous tasks, including synchronization primitives and channels and timeouts, sleeps, and intervals.</li><li>APIs for performing asynchronous I&#x2F;O, including TCP and UDP sockets, filesystem operations, and process and signal management.</li><li>A runtime for executing asynchronous code, including a task scheduler, an I&#x2F;O driver backed by the operating system’s event queue (epoll, kqueue, IOCP, etc…), and a high performance timer.</li></ul><h2 id="一个疑难问题"><a href="#一个疑难问题" class="headerlink" title="一个疑难问题"></a>一个疑难问题</h2><p>Rust 如何实现 TcpStream 在生产者、消费者不同的作用域之间的传输？</p><p>预期状态：服务器 listen 进入 <strong>accept loop</strong> 之后，每次接收到一个 socket，我希望可以通过 <code>mpsc::channel</code> 将这个 <code>socket</code> 和 <code>addr</code> 信息传输到另外一个事件循环中进行处理，但在把 <code>socket</code> 传到 <code>Task</code> 当中时，客户端出现断连的现象，暂时还没发解决。大致的代码如下：</p><figure class="highlight rust"><figcaption><span>main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>(N);</span><br><span class="line">  <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..N &#123;</span><br><span class="line">    tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">      <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">task</span> = rx.<span class="title function_ invoke__">recv</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">socket</span> = task.socket;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = <span class="built_in">vec!</span>[<span class="number">0u8</span>; <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> <span class="variable">n</span> = socket.<span class="title function_ invoke__">read</span>(&amp;buf);</span><br><span class="line">          <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// do something with buf and respond to peer socket</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> (socket, addr) = listener.<span class="title function_ invoke__">accept</span>();</span><br><span class="line">    tx.<span class="title function_ invoke__">send</span>(Task&#123;</span><br><span class="line">      socket,</span><br><span class="line">      <span class="comment">// socket closed here</span></span><br><span class="line">      <span class="comment">// Client meet error: Connection reset by peer</span></span><br><span class="line">      addr,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="疑难问题的权宜解决方法"><a href="#疑难问题的权宜解决方法" class="headerlink" title="疑难问题的权宜解决方法"></a>疑难问题的权宜解决方法</h2><p>经过一两天的思考，觉得跨作用域传递 <code>socket</code> 变量是不好的实践方式，于是将上述代码改为了下面的样子：直接在服务器监听方法当中对来到的 socket 进行读取和相应处理，不再跨作用域转移变量。</p><figure class="highlight rust"><figcaption><span>main.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> socket, addr) = listener.<span class="title function_ invoke__">accept</span>();</span><br><span class="line">    tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">      <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">// do something with socket and addr</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.ietf.org/rfc/rfc959.txt">rfc959</a></li><li><a href="https://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7) - Linux manual page</a></li><li><a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/kqueue.2.html">Mac OS X Manual Page for kqueue(2)</a></li><li><a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/kqueue.2.html">Kernel Queues: An Alternative to File System Events</a></li><li><a href="https://doc.rust-lang.org/book/title-page.html">The Rust Programming Language</a></li><li><a href="https://tokio.rs/">Tokio - An Asynchronous Rust Runtime</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再见了，兵荒马乱的 2022</title>
      <link href="/2022/12/30/Goodbye2022/"/>
      <url>/2022/12/30/Goodbye2022/</url>
      
        <content type="html"><![CDATA[<p>今天是2022年12月31日，2022年的最后一天，先给年初的自己说一声对不起：年初立的 Flag 基本没有一条是顺利达成的，我以为目标量化以后就可以逐项实现，但还是高估自己的执行力和时间充裕程度了。今年是我第二个本命年，本应过的虎虎生风，生龙活虎，但是现实没有我想象中那么精彩，但有一些事情还是值得记载。这一年我在专业上经历了迷茫，在情感上遇到波折，在工作上也遭遇了挑战，大环境上也在年底迎来了疫情政策的转折。我想对这一年做个小小的总结，也对明年做些展望和规划。</p><span id="more"></span><h1 id="面对未知要乐观"><a href="#面对未知要乐观" class="headerlink" title="面对未知要乐观"></a>面对未知要乐观</h1><p>现在回看今年写的几篇博客发现自己还是比较幼稚，喜欢用学生思维来思考问题：“我不想写前端代码了”“我为什么要用 GraphQL 来写前端代码”云云，当时除了觉得前端代码比较聚焦视觉和交互以外，还认为总是写前端代码对之后找基础研发相关的工作不是很有利。现在回过头来看，与其花时间纠结自己一直写前端代码对未来有什么不利的影响，不如把这部分时间投入到自己想学、想做的事情当中。</p><p><strong>畏畏缩缩地权衡着每一种选择的利弊，却从未迈出哪怕一步</strong>。这或许可以说是谨慎，但是过于谨慎只会让人止步不前。然而我不是自发主动地参悟到这一点，而是参加了今年的秋招后被迫察觉的。我当然没有参加过往年的秋招，但是今年整个社会都在传递就业方面的焦虑情绪，可以大体了解到今年秋招应该是比前两年困难些许的。</p><p>暑假本来可能有机会可以去字节跳动实习，但当时因为公司研发任务较重没办法抽出时间参与，错过了一段具有较高含金量的实习经历，我不以为然，觉得没有暑期实习没什么大不了。想着公司手头的事情忙完了再拿出一段时间好好准备秋招，但手头的事情永远忙不完，我就永远没有抽出时间进入准备秋招的“状态”。七月底投了字节的提前批，在 LeetCode 上刷了几十道题就开始面了，第一次面试过于紧张，基础知识回答得还算满意，写代码环节脑子一片空白。稀里糊涂到了三面主管面，这回更紧张了，表现一般最后给挂了。</p><p>通过字节提前批的经历我有了心理预期：没有完完整整的时间窗口可以用来专心致志地准备一件事情，不能再用准备高考的状态来准备秋招了。真如鲁迅先生所说，时间就像海绵里的水，只要愿意挤总会有的。那之后我白天去公司上班，晚上回学校刷题复习，八月底九月初密集投递简历，不断润色打磨自己的面试状态，经常一天面试2～3轮，着实是没有硝烟的战场。近三个月的秋招让我产生了线上面试 PTSD，戴上耳机打开会议软件就会自动联想到面对面试官做自我介绍的场景。当然这种 PTSD 不是害怕，是厌倦。</p><p>毛主席说过要在战略上藐视敌人，战术上重视敌人，我一直秉持这样的行事态度，力求对待一切事情都“抱最大希望，做最坏打算”，这也要求我对待事情做最好的准备，我喜欢准备 Plan B，在原定计划无法顺利开展时拥有备选方案是令人安心的。秋招对我来说很重要，所以准备需要更充分。（虽然最了最坏打算，但是本能地还是希望有好的结果）一直在准备，从来没行动，这是我对失败的不确定性的恐惧，是害怕失败的二阶导数。以前常听罗翔老师讲段子，他曾提到一句“对待已知的事情要谨慎，对待未知的事情要乐观”。自己熟悉或擅长的东西自己不上心往往容易出差错，我家这边有句谚语的意思大概就是“淹死的往往都是会游泳的”也讲得是这个意思，所以面对已知的事情要敬畏，要谨慎；面对未知的事情自己没有什么办法，只能尝试不同的方法来面对未知，消除未知带来的恐惧，在原地踌躇不前是无法解决问题的。</p><p>不过好在我开始行动的时间也不算晚，面试到九月下旬时渐入佳境，也陆陆续续收到了一些大小厂的 Offer（哈哈也包括字节的正式批），结果还算满意吧。</p><h1 id="重度“效率瘾”患者"><a href="#重度“效率瘾”患者" class="headerlink" title="重度“效率瘾”患者"></a>重度“效率瘾”患者</h1><p>“效率瘾”是我在调研笔记软件时看到一篇博客里提到的名词，我觉得很有趣。其大概含义是指如今不少人的最大爱好就是追求高效：今天在应用商店打开“效率”类目查看是否有新的效率提升软件可以帮助自己提升效率，明天在网上调研一番市面上哪款笔记软件比较适合构建知识库，后天开始思考应该如何分配笔记的段落结构使得内容详略得当，信息密度提升。他们执行效率最高的事情就是寻找提高效率的方法，自己却从未尝试或坚持将方法付诸实践，相当于提效的二阶导数。这些人可以说是“差生文具多”，可以说是学习上的“工具党”，甚至可以说是学习之前要做好万全的准备，争取一步到位。</p><p><strong>最惊悚的是看到这个名词之后我发现自己就是”效率瘾“患者</strong>，而且是重度。我潜意识里希望自己行动之前做好万全的准备，开始时就是最好的也是最终的状态，这很理想化，没有可行性。</p><p>工具是次要的，内容是重要的。调研了若干笔记软件，找到了当前最先进的又如何，其中存放着几篇笔记呢？看到这篇博客我被吓了一跳，赶紧关掉所有介绍和对比笔记软件的浏览器标签页。经过一些思考，我总结了两条克服“效率瘾”的办法：</p><ol><li><strong>重视内容轻视工具，集中精力投入生产</strong>，学习是知识在大脑里的 I&#x2F;O 过程，看到重要的内容记录下来，之后复习时再整理，整理的过程也是知识碎片重组的过程；</li><li><strong>用软件工程的思维看待事物</strong>，软件需要不断的迭代更新，成功不是一蹴而就的。生活、工作也一样，不完美和不如意是必然的，有迭代的勇气和能力就足够了。</li></ol><p>愿自己能够尽早戒除“效率瘾”，把时间精力用在做有用功上。</p><h1 id="对-2023-年的期待"><a href="#对-2023-年的期待" class="headerlink" title="对 2023 年的期待"></a>对 2023 年的期待</h1><p>今年五月开始打比赛，六月底恋爱分手，紧接着七月底开始了长达三个月的秋招历程，再伴随着疫情抬头我十二月初就早早回到家里远程办公，刚到家就得知疫情防控政策开始放宽，于是等待变阳。今年下半年没有太多“自己的时间”，什么是自己的时间我也说不准，只是一直这么觉得。我无比期待 2023 年能够恢复到 2019 年的生活，我现在已经想象不到出门不用戴口罩的感觉，回忆不起来自由出入学校、出入北京的体验了。疫情三年抹去了研究生阶段诗与远方中“远方”的部分，这诗也唱得呕哑嘲哳，疫情让我本科线上毕业，千万让我毕业时能和北京当面好好道个别。</p><p>至于计划，争取每个月发布至少一篇博客吧。</p><p>Bye～</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 胡思乱想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么前端开发要选择 GraphQL</title>
      <link href="/2022/06/03/WhyWeChooseGraphQL/"/>
      <url>/2022/06/03/WhyWeChooseGraphQL/</url>
      
        <content type="html"><![CDATA[<p>这篇博客其实是以一次公司内的技术分享为基础做的调研和总结归纳，包含了我自己很多不成熟的观点看法。这次分享主要是想向新同事介绍为什么我们选择在项目中大规模使用 GraphQL 而不是更传统更简单的 RESTful API。</p><h1 id="GraphQL-是什么"><a href="#GraphQL-是什么" class="headerlink" title="GraphQL 是什么"></a>GraphQL 是什么</h1><p>在上一篇有关 GraphQL 的<a href="/2021/07/23/UseGraphQLElegantly">博客</a>里，我简单地说明了 GraphQL 的定义及其大致用途，贴了官网链接就开始介绍我使用 GraphQL 的“更优雅的”方式，对 GraphQL 本身描述得并不多。这里又贴一下英文的定义：<strong>A query language for your API</strong></p><blockquote><p>GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.</p></blockquote><p>划重点，它是一种<strong>查询语言</strong>和<strong>使数据可查询的运行时</strong>。作为一种语言，它有自己的语法，能够定义<code>Type</code>, <code>Enum</code>, <code>Input</code>, <code>Fragment</code>, <code>Query</code>, <code>Mutation</code>等元素，熟悉 Typescript 的朋友会对此感到亲切。而在前端开发中需要重点关注的是以下几个部分：</p><span id="more"></span><ol><li><code>Schema</code>: 可以类比为整个 API 的全貌，通过类型系统定义了所有的类型和方法，描述了如何进行数据的查询和修改；</li><li><code>Query</code>: 是 Schema 中定义的方法，用于查询数据，无副作用，在后端并行执行；</li><li><code>Mutation</code>: 是 Schema 中定义的另一类方法，用于修改数据产生副作用，在后端串行执行；</li><li><code>Operation</code>: 是客户端定义的方法，命名和参数自定义，用于调用 GraphQL 的「查询」</li></ol><p>根据以上主要元素，使用 GraphQL 进行开发的大致范式如下图所示，当然在这里我简化了后端的工作。首先后端（至少）需要将 API Schema 定义并提供到指定端点上，前端开发者将 Schema 拉取到本地当作接口文档或者是编写 Operation 时代码补全的蓝本，需要调用接口时向指定端点传递 Operations 及其对应参数即可，整个过程十分丝滑。</p><img src="/2022/06/03/WhyWeChooseGraphQL/graphql-pipeline.png" class="" title="使用 GraphQL 的开发范式"><p>虽然但是，上述过程本质还是向某个 URL 地址以某种 HTTP 方法传递了某些参数且得到了某些返回数据，和传统的 RESTful API 有什么区别呢？</p><h1 id="RESTful-API-的劣势"><a href="#RESTful-API-的劣势" class="headerlink" title="RESTful API 的劣势"></a>RESTful API 的劣势</h1><h2 id="RESTful-API-是什么"><a href="#RESTful-API-是什么" class="headerlink" title="RESTful API 是什么"></a>RESTful API 是什么</h2><p>下面这是 REST 的<a href="https://restfulapi.net/">定义</a>，比较晦涩难懂。符合 REST 规范的 API 被称为 RESTful API，特点是使用 URI 和 HTTP Method 来区分接口方法。</p><blockquote><p>REST is an acronym for REpresentational State Transfer and an architectural style for distributed hypermedia systems.</p></blockquote><p><strong>规范</strong>的 RESTful API 将资源放在 URI 中，如 <code>/api/v1/articles</code> 表示「文章」资源；用 HTTP Method 方法来表示动作语义，如 GET 表示获取，POST 表示更新，PUT 表示新增，DELETE 表示删除等，<strong>但是</strong> RESTful 的规范很难实现或维持。我见过很多公开的 API 都直接将动作语义包含在 URI 里，而真正应该用来表达动作的 HTTP Method 则只用 <code>GET</code> 和 <code>POST</code>。最近刚好在接微信的接口，正好拎出来批评一下。</p><img src="/2022/06/03/WhyWeChooseGraphQL/wechat1.png" class="" title="微信某接口1"><img src="/2022/06/03/WhyWeChooseGraphQL/wechat2.png" class="" title="微信某接口2"><h2 id="不规范使用-RESTful-API-的问题"><a href="#不规范使用-RESTful-API-的问题" class="headerlink" title="不规范使用 RESTful API 的问题"></a>不规范使用 RESTful API 的问题</h2><p>因为 RESTful API 规范很难在开发过程中贯彻执行，所以下面我就归纳了目前常见 RESTful API 的缺陷：</p><ul><li>容易过度获取数据或获取数据不足</li><li>不支持一次网络请求调用多个接口</li><li>前端需要知道所有接口服务的地址，强依赖于接口文档</li><li>导致 HTTP Method 滥用，如查询表单字段稍多就写成了 POST 接口</li><li>前端开发强依赖于后端，后端接口变化前端反应剧烈</li><li>当增加新功能时后端需要整合多个微服务的数据提供给前端，即需要数据网关</li><li>接口返回值没有类型，无法利用 TS 的优秀特性</li><li>难以编写接口文档，虽然有 OpenAPI&#x2F;Swagger 等工具，但编写起来仍然很麻烦</li><li>API 升版本会直接改变端点 URL，对前端开发影响较大</li></ul><h2 id="GraphQL-的改进"><a href="#GraphQL-的改进" class="headerlink" title="GraphQL 的改进"></a>GraphQL 的改进</h2><p>GraphQL 的诞生可以说是刀法精准，每一处都正中 RESTful 的弱点：</p><ul><li>需要什么信息就定义什么字段，不多不少</li><li>支持一次请求调用多个接口</li><li>所有接口的 URL Endpoint 统一</li><li>进一步促进前后端解耦和 API 迭代优化，消除 API 版本</li><li>给接口赋予类型系统，代码即文档，无需 <a href="https://swagger.io/specification/">OpenAPI</a> 式的补丁式接口说明</li><li>支持在线调试和文档查询 IDE 如 <a href="https://graphiql-test.netlify.app/">GraphiQL</a> 和 <a href="https://www.graphqlbin.com/v2/6RQ6TM">GraphQL Playground</a></li></ul><p>目前越来越多公司都开始使用 GraphQL API，包括但不限于 Meta，Github，PayPal，Netflix，Airbnb 还有国内的快手等。</p><h1 id="GraphQL-给前端的新可能"><a href="#GraphQL-给前端的新可能" class="headerlink" title="GraphQL 给前端的新可能"></a>GraphQL 给前端的新可能</h1><h2 id="获得更大的自主性"><a href="#获得更大的自主性" class="headerlink" title="获得更大的自主性"></a>获得更大的自主性</h2><ul><li>数据存取上比起 RESTful API 完全隶属于后端，使用 GraphQL 给前端开发更多的自主性</li><li>需要用什么数据，用多少数据，怎么用数据以前端为主；后端只需要将 Schema 这个「全集」定义好、测试好</li><li>页面增加或减少信息呈现、数据字段改名等操作都可以在前端独立完成</li><li>GraphQL Schema 应当是前后端开发者共同制定出来的，强化前端开发在数据层面的重要性</li></ul><h2 id="充分利用类型系统的优势"><a href="#充分利用类型系统的优势" class="headerlink" title="充分利用类型系统的优势"></a>充分利用类型系统的优势</h2><ul><li>利用代码生成工具，前端开发时可以将 GraphQL 的 Schema 拉取下来，并且参照其类型系统生成对应的 TS 代码，此类工具集大成者是 <a href="https://www.graphql-code-generator.com/">GraphQL Code Generator</a></li><li>兼容性好：只生成 API 代码，不涉及页面模板，React、Vue 和微信小程序都可以支持，基本涵盖目前需要接触所有类型的前端开发</li><li>自由度高：code generator 支持多种插件，可根据开发习惯和偏好进行选择</li><li>可维护性强：使用 TS 调用接口后不会在代码逻辑中出现任何与接口名称、URL 地址、HTTP 方法相关的任何硬编码字符串；TS 指定接口参数返回值，避免许多 JS 中常见的运行时错误</li></ul><h2 id="声明式的语言提高确定性"><a href="#声明式的语言提高确定性" class="headerlink" title="声明式的语言提高确定性"></a>声明式的语言提高确定性</h2><p>GraphQL 的查询语言是 <code>type &#123; …fields &#125;</code> 这样声明式的，在 Operations 中定义了什么字段，一切正常的情况下就会返回相应结构的字段，所见即所得。而且，声明式的查询使得接口的确定性更高，消除歧义，前端开发不用猜接口返回的信息包含什么数据。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>因为从一开始接触 Web 应用开发以来我就开始使用 GraphQL，所以反而是 RESTful API 没有大规模的使用过（只用在自己的玩具应用），对它的认识没有特别深入。但是直观感受是 GraphQL 对前端开发来说只有好处没有坏处，倒是后端实现起来 GraphQL 成本比 RESTful 高一些，毕竟要定义 Schema 和各式各样的方法、类型和参数，比直接定义 <code>URI + Method + Params</code> 的方式要复杂一点。但是一旦 RESTful API 要规范化规模化的话，应该也需要投入大量时间编写接口文档，这个时候两种 API 实现方式的成本就相差无几了。而开发体验上 GraphQL 是完胜的，所以我希望越来越多企业转向 GraphQL API。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> GraphQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好久不见，前端再见</title>
      <link href="/2022/05/09/GoodbyeFrontEnd/"/>
      <url>/2022/05/09/GoodbyeFrontEnd/</url>
      
        <content type="html"><![CDATA[<p>断断续续写前端项目也有好几年了，从大二接触 Javascript 和 Vue 时的兴奋，到接触小程序和 React 时的“渐入佳境”，再到这段时间的感到无比疲惫，我希望我在前端开发上大规模投入的阶段先暂告一段落了。为什么有这样的疲惫感呢？原因总结起来有以下几点：</p><ol><li>前端开发面临的大多不是技术问题，是产品问题或美学问题，最终目标是让用户满意；</li><li>前端开发过于琐碎，需要处理的细枝末节极多，每个页面元素都有相应的状态需要管理；</li><li>前端难于抽象，对应到用户上则表现为具体业务需求是千变万化的。</li></ol><span id="more"></span><h1 id="写前端的疲惫感"><a href="#写前端的疲惫感" class="headerlink" title="写前端的疲惫感"></a>写前端的疲惫感</h1><p>从技术上来说绝大部分前端应用并不需要考虑代码的优化，而是需要“取悦”用户，这应该是最让我无法忍受的了。因为前端应用面向最终用户，看得见摸得着的应用就会让用户有点评的冲动，而除了基本的程序正确性问题外，诸如“我觉得这里不好看”这样主观且不确定的问题占绝大多数。相较于后端而言，前端应用面向的用户不知道也不关注技术问题，他们对应用提出的问题是不收敛的，且提出问题的同时往往伴随着需求变动。</p><p>而回归到技术上，与其说是我选择了前端框架，不如说是我选择的 UI 组件库替我焊死了框架的门，真正做到 <code>面向 UI 组件库的编程</code> 。目前我们普遍使用的 React + AntDesign 的组合已经成了标准配置，图快写出来的所有的应用外观上和代码上都几乎一样，让我有些视觉疲劳和精神疲劳。</p><p>疲劳状态下需要转移注意力，换换脑子接触新的东西，近期发现了重编译时的轻量前端框架 <a href="https://svelte.dev/"><code>Svelte</code></a> 的确让我耳目一新，简单清晰的 API 和朴素的文件布局和它的名字完全吻合，让人觉得 Web 开发又回到了似曾相识的从前的模样，熟悉又清新。但很快美梦就破碎了，当我准备用它重构自己用 React 写的网站时发现消息提示，模态对话框，表单验证等前端开发常见场景问题都没有太好的解决方案。回顾了 Bootstrap，有刀耕火种的味道。可能我属于“急于求成”“基础不扎实”的前端开发者吧，如果有时间和机会好好打磨 UI 组件，调整样式和布局应该能够达到非常好的效果。但 React + AntDesign 就跟吃快餐一样，风味欠佳但是效率很高。</p><p><strong>现在我觉得是实际业务选择了我，前端框架选择了我</strong>。</p><h1 id="当我谈写代码时我谈些什么"><a href="#当我谈写代码时我谈些什么" class="headerlink" title="当我谈写代码时我谈些什么"></a>当我谈写代码时我谈些什么</h1><p>当我提到写代码，脑海里想的是借助程序充分利用计算机的能力，达到我需要完成的计算任务。程序的状态应被准确地刻画，程序的输入输出应被良定义，程序的边界应当较为清晰，程序的正确性可以被验证…而这些与前端开发不能说是毫不相干，也可以说是相去甚远。</p><p>人是会犯错的，用动态语言写代码错误频出，而因为我能力有限，用动态语言写前端代码只会使得错误跟我玩捉迷藏，更何况还得面对各路用户提出的需求和美学问题。我希望我写代码时能够保持足够长的、不被打扰的专注时间，让我可以设计并实现程序，而不是时不时考虑表格 A 缺了字段，按钮 B 应当换成主色等琐碎的问题。下面这张图就是上个月某两周的代码提交次数统计情况，在前端应用的开发中需要处理的事情和写的代码都是极其琐碎且没有局部性的。我不认为这么多次的提交都具备平均的单位价值，但可以体现写的代码是东一榔头西一棒子的。</p><img src="/2022/05/09/GoodbyeFrontEnd/dashboard.png" class="" title="某两周的提交次数统计"><p>当然这些都是我的主观感受，无知者无畏，我只是窥到了前端的冰山一角便自觉全面接触后难以接受想着要逃。我很喜欢 Vue React Svelte 这些项目，也希望有朝一日可以自己可以搭建出这样的框架。用框架写前端应用和实现前端框架是完全不一样的概念，前者针对业务，后者面向系统。我计划在之后的时间里深入到软件系统的设计与实现当中，在可接触的项目范围内开始转向后端于我而言是理想的开端。编写相似的业务代码给我带来的技术提升和成就感与日俱减，尤其是我饶有兴致地用颇为巧妙的方法实现的前端应用被用户主观地认为“不好看”或者“不易用”时，很难避免这些对应用本身的批评转嫁到自己身上，实现得不好可能也有，但是这种因素占比是多少呢？</p><blockquote><p>希望一人独处的念头，始终不变地存于心中。所以一天跑一小时，来确保只属于自己的沉默的时间，对我的精神健康来说，成了具有重要意义的功课。至少在跑步时不需要和任何人交流，不必听任何人说话，只需眺望周围的风光，凝视自己即可。这是任何东西都无法替代的宝贵时刻。</p><p>—— 村上春树</p></blockquote><h1 id="写前端的收获"><a href="#写前端的收获" class="headerlink" title="写前端的收获"></a>写前端的收获</h1><p>抱怨了这么多，不是想表达我对前端开发的深恶痛绝，而是“爱之深责之切”(?)。我仍会关注前端领域的发展，甚至还会在自己的网站里尝试新的前端技术，但对于我而言它已经成为“庐山烟雨浙江潮”。它给我带来的收获有几方面，最主要的就是产品思维、审美提升和巩固 Web 基础。</p><p>首先产品思维就是站在用户的角度思考产品的问题，以用户为中心。而用户就是更注重产品的美观性、易用性而不注重实现方法和程序效率，软件产品本身不仅是代码和程序，美术素材、按钮图标、菜单样式等等都是其中重要的部分。因为前端应用直接面向最终用户，所以前端开发其实也是在做产品，当然如果纯粹机械地将原型图还原成前端应用则另当别论。</p><p>审美提升则是主观和隐性的。因为我所做的前端应用大多是 ToB 模式，不同于电商类应用，没有引流新用户的需要，所以几乎所有界面都是简约风格的，久而久之我对应用的设计风格就有了简约的偏好。最直接的影响是发现“丑”的应用数量增多，间接影响是当我听完一段应用的功能描述后可以在脑海里描摹出大致的页面设计方案，何处需要做一些留白，元素如何合理布局，如何让页面观感舒适等。审美的提升不仅体现在页面实现上，也体现在代码风格上，能写美观的地方我会尽量优化，目录结构、文件命名、甚至是注释的写法也要统一(<code>/** */</code>、<code>//</code>、<code>/* */</code>)。</p><p>巩固 Web 基础的巩固则直截了当，<code>DOM API</code>、<code>Typescript</code>、<code>浏览器兼容性</code> 甚至是 <code>jQuery</code> 等杂七杂八的东西都有接触，也开始封装发布自己的 UI 组件和实用工具 NPM 包，成为 NPM 包玩家。Svelte 的出现也把基于 Virtual DOM 前端框架的势头稍微拉回了经典的开发风格，让我体验了一把文艺复兴。</p><h1 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h1><p>前段时间业余时间学习了 Rust，希望能够借助 Rust 的学习路径复习操作系统、计算机组成原理和数据库原理等基础知识。阅读 Rust 的中英文文档及博客后深感深切感受到了大一从 C&#x2F;C++ 上没有感受到的魅力，Rust 编译器像严格的编程教练，用极为严格的语法要求我们写出合规合法的代码，这样一来通过编译器检查的代码就已经达到较高的标准；Rust 中 <code>所有权</code> 和 <code>生命周期</code> 的机制也十分巧妙，能够最大限度地避免内存泄漏和野指针的问题；作为 Mozilla 推出的现代编程语言，内建的类库和原生的 API 都比较趁手。</p><p>3月末 Golang 发布了 1.18 正式版，终于推出了泛型编程的特性，到现在还没有真正上手写呢，是时候体验一番了。</p><p>后续计划主要用 Golang 或 Rust 这两种编程语言，配合 GraphQL 搭建可拓展的后端服务；自己整体的工程方向朝着微服务、云原生的方向靠拢，尽量扎进计算机系统的核心和底层。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 胡思乱想 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打包发布 React 组件库</title>
      <link href="/2022/03/12/PublishNpmPackageOfReactComponents/"/>
      <url>/2022/03/12/PublishNpmPackageOfReactComponents/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>「代码写了不测等于白写」我总是跟身边的朋友这样调侃。然而我们写前端项目时很难在代码层面进行测试，大部分函数都是基于事件响应，接收用户输入的参数，并对页面组件或数据产生一定副作用，Mock 起来很麻烦。所以前端项目的测试往往都是端到端测试，即模拟用户在页面上进行操作，测试路径越离奇越好，因为无法提前预知用户会如何使用，所以最好在测试时可劲儿造。</p><p>曾经还会想着用 Cypress 等自动化工具进行端到端测试，例如用代码定义【打开某页面–&gt;拖拽滑动条至页面下方–&gt;点击输入框使之获取焦点–&gt;输入“Hello world”–&gt;按下回车–&gt;等待页面响应–&gt;观察响应是否符合预期】这个过程，但只要遇到元素稍多的页面，编写测试用例的过程就会变得机械呆板。</p><p><strong>如果组件足够小，内容够聚焦，那么测一下也不是不可以。</strong>因为想在不同的项目中复用同一套富文本编辑组件(体积比较大，且包含机器构建的 JS)，我把它单独提出来作为 NPM 包发布以便各个项目安装使用。这当中编码和测试都遇到了一些问题。</p><span id="more"></span><h1 id="打包经过"><a href="#打包经过" class="headerlink" title="打包经过"></a>打包经过</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>既然要在不同项目之间共用，那该组件肯定至少已经应用到一个项目中。所以最终目标就是把项目中原先引入的组件完全替换成为 NPM 包版本的组件后，所有富文本编辑预览功能都照常。</p><h2 id="原先组件结构"><a href="#原先组件结构" class="headerlink" title="原先组件结构"></a>原先组件结构</h2><figure class="highlight typescript"><figcaption><span>CKEditorFormFields.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./some-styles.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CKEditor</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@ckeditor/ckeditor5-react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">CustomBuildEditor</span> <span class="keyword">from</span> <span class="string">&quot;@ckeditor/ckeditor5-custom-build&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">CKEditorInput</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">ControllableFormFieldProps</span>&gt; = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * ...</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">CKEditorRenderer</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">ControllableFormFieldProps</span>&gt; = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * ...</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原先的组件定义基本上如上面片段所示，其中 <code>CustomBuildEditor</code> 利用了 <a href="https://ckeditor.com/ckeditor-5/">CKEditor5</a> 的<a href="https://ckeditor.com/ckeditor-5/online-builder/">自定义构建</a>，算是按项目需要选取必要功能构建出来的编辑器母版，它本身的使用方法很 HTML，不太适合直接用在 React 项目里，需要用 <code>@ckeditor/ckeditor5-react</code> 进行包装。</p><p>而这个 <code>CustomBuildEditor</code> 是自定义构建工具编译好之后打包好后（后续用 <code>ckeditor-dist</code> 称呼）下载到本地的，如果不用 NPM 包的话需要在几个项目间复制粘贴。或许因为我们项目用的是 TS，无法直接从本地目录下直接引入，所以我们用 package.json 依赖的文件链接定义了一个叫做 <code>@ckeditor/ckeditor5-custom-build</code> 的假包供代码引入使用，但这个方法<strong>时而奏效时而报错</strong>，或是<strong>在张三电脑上能用而李四电脑上用不了</strong>。可以确保解决问题的方法是将该 <code>ckeditor-dist</code> 目录复制到 <code>node_modules</code> 当中，但是这样过于原始。于是决定有时间研究一下 NPM 打包。</p><h2 id="Hello-richtext"><a href="#Hello-richtext" class="headerlink" title="Hello-richtext"></a>Hello-richtext</h2><p>目标富文本组件包名叫做 <code>Hello-richtext</code>，它需要依赖我们自定义构建的富文本编辑器母版，所以首先将 <code>ckeditor-dist</code> 单独作为一个 NPM 包发布到我们团队的私有制品库中，就起名为 <code>ckeditor-custom-build</code>。</p><p>把 <code>ckeditor-custom-build</code> 加入到依赖中，原先组件中包含的所有文件都复制到 <code>Hello-richtext</code> 的代码目录中。利用 <code>tsc</code> 以 <code>&quot;target&quot;: &quot;ESNest&quot;</code> 的配置将 <code>.tsx</code> 格式的文件编译为 <code>.js</code> 和 <code>.d.ts</code> 文件，或许这也是最终在前端项目中被应用时的引入形式。</p><p>随后利用 <a href="https://jestjs.io/">Jest</a> 和 <a href="https://testing-library.com/docs/react-testing-library/intro/">React Testing Library</a> 写下了如下的测试用例。</p><figure class="highlight javascript"><figcaption><span>render.test.jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">&quot;@testing-library/react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Form</span> &#125; <span class="keyword">from</span> <span class="string">&quot;antd&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CKEditorInput</span>, <span class="title class_">CKEditorRenderer</span> &#125; <span class="keyword">from</span> <span class="string">&quot;../dist/CKEditorFormFields&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@testing-library/jest-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">window</span>, <span class="string">&quot;matchMedia&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">value</span>: jest.<span class="title function_">fn</span>().<span class="title function_">mockImplementation</span>(<span class="function">(<span class="params">query</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">matches</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">media</span>: query,</span><br><span class="line">    <span class="attr">onchange</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">addListener</span>: jest.<span class="title function_">fn</span>(), <span class="comment">// Deprecated</span></span><br><span class="line">    <span class="attr">removeListener</span>: jest.<span class="title function_">fn</span>(), <span class="comment">// Deprecated</span></span><br><span class="line">    <span class="attr">addEventListener</span>: jest.<span class="title function_">fn</span>(),</span><br><span class="line">    <span class="attr">removeEventListener</span>: jest.<span class="title function_">fn</span>(),</span><br><span class="line">    <span class="attr">dispatchEvent</span>: jest.<span class="title function_">fn</span>(),</span><br><span class="line">  &#125;)),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">TestForm</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Form</span> <span class="attr">initialValues</span>=<span class="string">&#123;&#123;</span> <span class="attr">renderer:</span> &quot;&lt;<span class="attr">p</span>&gt;</span>Hello world!<span class="tag">&lt;/&gt;</span>&quot; &#125;&#125;&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Form.Item</span> <span class="attr">label</span>=<span class="string">&quot;Mock Input&quot;</span> <span class="attr">name</span>=<span class="string">&quot;input&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">CKEditorInput</span> <span class="attr">data-testid</span>=<span class="string">&quot;input-field&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Form.Item</span> <span class="attr">label</span>=<span class="string">&quot;Mock Renderer&quot;</span> <span class="attr">name</span>=<span class="string">&quot;renderer&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">CKEditorRenderer</span> <span class="attr">data-testid</span>=<span class="string">&quot;renderer-field&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&quot;test rendering&quot;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">TestForm</span> /&gt;</span></span>).<span class="title function_">debug</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="启动测试时遇到的问题"><a href="#启动测试时遇到的问题" class="headerlink" title="启动测试时遇到的问题"></a>启动测试时遇到的问题</h2><p>只要富文本编辑器能够正常渲染就成功了，所以首次运行测试我比较保守，只定义了简单的表单并把自定义的两个组件作为表单项置入其中，并尝试将渲染结果用 <code>render().debug()</code> 的方式打印出来看看是否正确渲染。</p><p>但是启动 Jest 之后遇到了一系列问题，下面列举了我遇到的问题以及相关的解决方案。</p><ol><li>无法解析 <code>.jsx</code> 格式文件，通过安装 <code>@babel/preset-react</code> 插件并创建 <code>babel.config.js</code> 应用该插件解决；</li><li>提示 ‘react’ 这个包没有导出 default，通过安装 <code>@types/react</code> 和 <code>@babel/preset-env</code> 解决，其中 babel 插件同样需要应用到配置文件中；</li><li>提示没有 <code>window.matchMedia</code> 方法，直接通过 <code>Object.defineProperty</code> 给 <code>window</code> 打上补丁（<a href="https://jestjs.io/docs/26.x/manual-mocks#mocking-methods-which-are-not-implemented-in-jsdom">官方建议</a>）；</li><li>无法解析 <code>CKEditorFormField</code> 中引入的 <code>.css</code> 文件，通过安装 <code>identity-obj-proxy</code> 依赖，并在 Jest 配置文件的 <code>moduleNameMapper</code> 属性中加入 <code>&quot;\\.(css|less)$&quot;: &quot;identity-obj-proxy&quot;</code> 解决；</li></ol><p>稍微麻烦些的就是上面 4 点，当然还有一些其他的必要的依赖也是需要安装的，这里给出局部 <code>package.json</code>，Jest 和 Babel 的配置分别如下：</p><figure class="highlight json"><figcaption><span>package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello-richtext&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jest&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tsc&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;richtext&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^17.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@ckeditor/ckeditor5-react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.0.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@ckeditor/ckeditor5-build-classic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^31.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ckeditor5-custom-build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;antd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.16.13&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@babel/core&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.17.5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@babel/preset-env&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.16.4&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@babel/preset-react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.16.7&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@testing-library/dom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^8.11.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@testing-library/jest-dom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.16.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@testing-library/react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^12.1.4&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@types/jest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^27.4.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@types/react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^17.0.39&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;babel-jest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^27.5.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;identity-obj-proxy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;jest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^27.5.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;react-dom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^17.0.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;react-test-renderer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^17.0.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ts-node&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^10.7.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;typescript&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.1.2&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><figcaption><span>jest.config.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">coverageProvider</span>: <span class="string">&quot;v8&quot;</span>,</span><br><span class="line">  <span class="attr">moduleNameMapper</span>: &#123;</span><br><span class="line">    <span class="string">&quot;\\.(css|less)$&quot;</span>: <span class="string">&quot;identity-obj-proxy&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">testEnvironment</span>: <span class="string">&quot;jsdom&quot;</span>,</span><br><span class="line">  <span class="comment">// 其他均为默认</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>babel.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [</span><br><span class="line">    [<span class="string">&quot;@babel/preset-env&quot;</span>, &#123; <span class="attr">targets</span>: &#123; <span class="attr">node</span>: <span class="string">&quot;current&quot;</span> &#125; &#125;],</span><br><span class="line">    [<span class="string">&quot;@babel/preset-react&quot;</span>, &#123; <span class="attr">targets</span>: &#123; <span class="attr">node</span>: <span class="string">&quot;current&quot;</span> &#125; &#125;],</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="测试补全"><a href="#测试补全" class="headerlink" title="测试补全"></a>测试补全</h2><p>解决<a href="#%E5%90%AF%E5%8A%A8%E6%B5%8B%E8%AF%95%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98">上一节</a>遇到的问题之后，测试脚本可以顺利运行了，需要稍微补全一下测试用例。因为 <code>CKEditorInput</code> 从 <code>ckeditor-custom-build</code> 中加载 <code>CKEditor</code> 时采用了异步加载，所以用 rlr 的 <code>render()</code> 第一时间拿到的页面源码内显示该方法仍在加载中。通过 <code>screen.logTestingPlaygroundURL()</code> 方法可以获取 <strong>Debug Playground</strong> 的访问链接，用浏览器打开可以看到下图的内容，清楚明了。利用它还能获取如何查询页面元素的提示。</p><img src="/2022/03/12/PublishNpmPackageOfReactComponents/debug-playground.png" class="" title="debug playground"><p>我期望两个组件都正常渲染，如果 <code>CKEditorInput</code> 组件需要异步加载，那么设置等待即可。测试用例补充为下面的样子：</p><figure class="highlight javascript"><figcaption><span>render.test.jsx (2)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防止加载时间稍长引发 jest timeout 的问题</span></span><br><span class="line">jest.<span class="built_in">setTimeout</span>(<span class="number">60000</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&quot;test rendering&quot;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">TestForm</span> /&gt;</span></span>).<span class="title function_">debug</span>();</span><br><span class="line">  screen.<span class="title function_">logTestingPlaygroundURL</span>();</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">waitFor</span>(<span class="function">() =&gt;</span> screen.<span class="title function_">getByText</span>(<span class="regexp">/hello world!/i</span>), &#123;</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">30000</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">waitFor</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 根据 debug() 的返回结果发现:</span></span><br><span class="line">      <span class="comment">// 可以通过获取 &quot;段落&quot; 这个工具栏提示字样来判断是否已经渲染出富文本编辑器</span></span><br><span class="line">      screen.<span class="title function_">debug</span>();</span><br><span class="line">      screen.<span class="title function_">getByText</span>(<span class="regexp">/段落/i</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">timeout</span>: <span class="number">30000</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="打包、发布完成"><a href="#打包、发布完成" class="headerlink" title="打包、发布完成"></a>打包、发布完成</h1><p>测试完成后，利用 <code>npm publish</code> 命令将 <code>Hello-richtext</code> 发布到团队的私有制品库中，完成打包流程。在两个实际项目中安装 <code>Hello-richtext@0.0.1</code> 后，组件切实可用。</p><p>这次打包发布 React “组件库”的经历给了我几点体会，</p><ol><li>首先是学习和实践了 React 组件的测试流程，加深了自己对于前端项目测试的理解；</li><li>其次让自己构建 NPM 包的流程更规范，之前发布的几个 NPM 包因为图方便求速度都没有写测试，<strong>没测等于没写</strong>；</li><li>在目前两个可能未来更多的项目开发中事实上地提升了代码复用度和开发体验，原先富文本编辑在各个项目间维护…挺麻烦的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> React </tag>
            
            <tag> NPM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年我希望...</title>
      <link href="/2022/01/15/SomethingFor2022/"/>
      <url>/2022/01/15/SomethingFor2022/</url>
      
        <content type="html"><![CDATA[<p>新年的元月已然过半，但直到现在我才能说我完成了上一年的工作。我一直在追求“忙的时候闲一点，闲的时候忙一点”的从容，这一年大部分时间是保持着这个状态的，让我非常欣慰。但是真正从学生身份蜕变成“开发者”“软件工程师”（或者“社畜”？其实即使是自嘲我也不太喜欢这个词），还是有着截然不同的感受和体会的。对于 2022 也有着无数的憧憬。</p><span id="more"></span><h1 id="2021-上半年：课程时代尾声"><a href="#2021-上半年：课程时代尾声" class="headerlink" title="2021 上半年：课程时代尾声"></a>2021 上半年：课程时代尾声</h1><p>2021 年上半年我研一，为了一年上完所有的课我这个学期仍然是课程满满的，与此同时课题组的项目也开始安排给我。在课程任务和项目进度的双重压力下，我会想着“尽快结束这样的生活节奏，争取早日回归生活的正轨”，但这个状态持续一小段时间之后我逐渐与之和解了，与其认定只用考虑学习的生活是正轨，不如接受多线程地生活才是当下社会当中每个人都需要具备的基础能力这个事实。</p><p>那么话又说回来，我认为我的多线程能力还是不错的，因为在主业之外我一直以来都或多或少地参与到学院、学校的学生工作中。在相对一板一眼的计算机知识、代码编写和需要社交活动的谈话开会、学生事务之间频繁切换也没有被我归入困扰我的事情当中。这样长期以来的“训练”让我对社交行为本身脱了敏，甚至有时还会主动发起社交活动；也让我对“同时处理很多事情”这个现象习以为常。</p><p>随着课程结课，我有了更多的时间可以投入到课题组项目里。我在课题组的工作投入在一定范围内是正反馈的：投入时间增加产出增加 –&gt; 工作产出增加 –&gt; 安排给我的工作增多 –&gt; 投入时间增加。实验室有位同学开玩笑地说我是“劳模”，每天都早早来到实验室但很晚才回寝。这个状态从暑假一直持续到现在，我自己是乐在其中了。我在课题组里承担的工作让我拥有了难以替代性，在这个过程当中我收获的知识、激励还有认可都成了我齿轮转动的润滑剂——即使有的时候这种难以替代性也带来不小的压力。这个反馈过程却有点像我高中的学习历程：<strong>认真学习带来的收获主、客观上都有助于我继续认真学习</strong>，学习换成工作也受用。我觉得这样的状态是比较难得的，我享受这一状态。我觉得我很幸运，学的专业做的工作都是自己喜欢的，所以能够一定程度上保持自驱。</p><h1 id="2021-下半年：偶然与想象"><a href="#2021-下半年：偶然与想象" class="headerlink" title="2021 下半年：偶然与想象"></a>2021 下半年：偶然与想象</h1><p>喜欢记录为什么不拍照呢？我在 5 月入手了一台富士相机，并立马带上它去了青岛。不深挖构图角度也不用 Photoshop，光是拨动相机滚轮，摁下相机快门在任何一处拍下软糯或嶙峋的云彩，波光粼粼的海面还是叶影斑驳的片片树荫、铺满和煦光影的高矮楼房，都让我感受到极为愉悦。虽然没有太多机会到外面旅游，但在学校里面简单记录四时风景也是很好的体验。</p><img src="/2022/01/15/SomethingFor2022/cloud-on-mountain.jpg" class="" title="云海"><p>8 月开始捡起闲置已久的吉他，在琴包里放了近两年，音孔部分的琴弦竟然有些锈迹斑斑。完全从零开始学，在不懂乐理的情况下，我照着吉他入门教材学习了几个基本的和弦。弹唱的曲子从教材里比较简单的《送别》到自己感兴趣的《杀死那个石家庄人》《平凡之路》等等，也逐渐意识到自己水平有限需要加强练习。下面这张图虽然没有标识我的所有练琴记录，但可以大致体现我的练琴状态：有段时间练习比较密集，有段时间又比较松懈，指尖和食指侧的茧长了又消。以前听人说吉他很简单，可能跟“Python 很简单”道理一样吧，我到目前为止我学到稍微深入一点的技巧也只有横按和泛音而已。</p><p>这半年没有课程没有作业的时间里，原本以为会枯燥乏味的生活却过得很丰富，果然<strong>生活是需要偶然与想象的</strong>。</p><img src="/2022/01/15/SomethingFor2022/guitar-practice.jpg" class="" title="联系吉他时间记录"><h1 id="2022-的小目标"><a href="#2022-的小目标" class="headerlink" title="2022 的小目标"></a>2022 的小目标</h1><p>2022 年还剩下 350 天，剩余的 95%时间里我希望自己可以有更多从容不迫、处变不惊的心态和能力，有“彼可取而代也”、不惧跃入人海的傲骨和锐气；对待喜欢的人要满怀热情，对待讨厌的人要爱憎分明。之前总说“想的多了，做的就少”，务虚的话简单说说就好，人不能总活在空中楼阁。给我的 2022 定几个务实些的小目标（排序不分先后，包括但不限于）：</p><ul><li>每个季度至少读两本<strong>非技术类</strong>书目；</li><li>每个月至少更新一次博客，类型不限；</li><li>每两周至少看一部非<strong>所谓商业片</strong>的电影；</li><li>每周至少锻炼一次，有氧&#x2F;无氧、室内&#x2F;室外均可；</li><li>协助所带班级内每位同学捋清未来职业发展规划；</li><li>学习乐理，能够转换吉他谱和五线谱；</li><li>开源至少<code>3个代码仓库</code>，做些有意思的开发。</li></ul><p>以上。2022 来年再会。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 胡思乱想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 基础</title>
      <link href="/2021/08/15/NginxBasics-1/"/>
      <url>/2021/08/15/NginxBasics-1/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Nginx 读作 <code>engine x</code>，是一个高性能的 HTTP 和反向代理服务器，还能用作邮件代理服务器或是通用的 TCP&#x2F;UDP 代理服务器。有过后端程序部署经历的同学应该会有所了解，用 Nginx 能够很方便地完成反向代理、服务静态文件、实现负载均衡、接入 HTTPS 协议等任务。</p><p>根据官方文档里面写到的，除了提供静态文件服务、反向代理和负载均衡等功能之外，还提供以下包括单不限于若干个方面的支持：</p><ol><li>FastCGI, uwsgi 之类服务器和反向代理服务器的缓存支持；</li><li>以域名&#x2F;IP 为基础的虚拟服务器、Keep-alive 和流水线链接的支持；</li><li>访问日志、错误日志的输出和格式化，带缓存的日志写机制；</li><li>3xx-5xx 错误码重定向，根据正则表达式重写 URI (Rewrite)；</li><li>基于客户端地址的访问控制和函数调用；</li><li>HTTP referer 的验证、支持除了 GET 外的几种 HTTP 方法： PUT&#x2F;DELETE&#x2F;COPY&#x2F;MOVE&#x2F;MKCOL；</li><li>FLV&#x2F;MP4 的流播放、响应限流、限制单点的并发连接数和请求数；</li><li>等等…（上面只列了我读得懂的）</li></ol><p>Nginx 的功能实在太多了，在这里全部列出来不太可能。一直以来我对 Nginx 都停留在“配置是什么，work 就行”的态度。因为这周程序部署时遇到的一点问题，上网搜了好多帖子、博客寻求解决方法那种捉襟见肘、有病乱投医的样子让我觉得很狼狈。借此为契机，决定周末看一下 Nginx 的官方文档。nginx 旧版的官网文档组织混乱，建议移步 <a href="https://docs.nginx.com/">Nginx Plus (Nginx 的商业版)官网</a>。Nginx 和 Nginx Plus 的对比<a href="https://www.nginx.com/products/nginx/compare-models">放在这里</a>。</p><span id="more"></span><h1 id="基本功能概况"><a href="#基本功能概况" class="headerlink" title="基本功能概况"></a>基本功能概况</h1><h2 id="Name-IP-based-Virtual-servers"><a href="#Name-IP-based-Virtual-servers" class="headerlink" title="Name&#x2F;IP-based Virtual servers"></a>Name&#x2F;IP-based Virtual servers</h2><p>Nginx 接收到请求之后会首先决定让哪个 server 来接受这个请求。在 nginx 的配置文件中使用 <code>server</code> 这个指令可以定义“服务器”区域，当然最后到底是谁处理这个请求也是看 server 是如何定义的。下面是示例代码块：</p><figure class="highlight bash"><figcaption><span>demo.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen      80;</span><br><span class="line">    server_name example.org www.example.org;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen      80;</span><br><span class="line">    server_name example.net www.example.net;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen      80;</span><br><span class="line">    server_name example.com www.example.com;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置文件定义了 3 个服务器，都监听了 *:80 端口。Nginx 接收到请求之后会转发给 <code>server_name</code> 字段与请求头中的 <code>Host</code> 字段相同的 server 进行处理。如果没有完全对应的 Server 那么请求会被转发到默认服务器进行处理。<code>default_server</code> 是 <code>listen</code> 指令的可选参数，如果在端口号后加上 <code>default_server</code> 表示这个服务器是默认服务器。<strong>如果没有任何 server 有 <code>default_server</code>，那配置文件中定义的第一个 server 就是默认的服务器</strong>。</p><p>对 <code>listen</code> 中的 IP 地址进行配置也是可行的。下面再看一个配置文件：</p><figure class="highlight bash"><figcaption><span>demo2.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen      192.168.1.1:80;</span><br><span class="line">    server_name example.org www.example.org;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen      192.168.1.1:80;</span><br><span class="line">    server_name example.net www.example.net;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen      192.168.1.2:80;</span><br><span class="line">    server_name example.com www.example.com;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置文件下，Nginx 会先判断请求的 IP，再判断 <code>server_name</code> 字段。</p><h2 id="Locations"><a href="#Locations" class="headerlink" title="Locations"></a>Locations</h2><h2 id="路径配置规则"><a href="#路径配置规则" class="headerlink" title="路径配置规则"></a>路径配置规则</h2><p>在 <code>server</code> 区域之中，可以定义若干个 <code>location</code> 区域。<code>location</code> 指令可以根据请求的 URI 将请求分发到不同的代理或者不同的静态文件目录中，后面提到的所有 <code>location</code> 配置都在 <code>server</code> 区域之中。</p><p><code>location prefix</code> 匹配符合 <code>prefix</code> 前缀的 URI，如果一个请求的 URI 匹配了很多 location 的 prefix 那么请求会被分发到 prefix 定义最长的 location 块中。另外，<code>location</code> 指令还可以有标识符配置：</p><ol><li><code>location = path</code> 表示 URI 需要准确的等于 path 才会落到这个 location 区域进行处理；</li><li><code>location ~ regex</code> 表示 URI 匹配相应的正则表达式。如果是 <code>~*</code> 的话，是忽略大小写的；</li><li><code>location ^~ prefix</code> 表示这个 prefix 匹配的话，不考虑相应的正则表达式；</li></ol><h2 id="匹配优先级"><a href="#匹配优先级" class="headerlink" title="匹配优先级"></a>匹配优先级</h2><p>要找到最好的 <code>location</code> 块来匹配一个 URI，Nginx 会先匹配所有的 prefix，然后再匹配所有的正则表达式。但是 Nginx 会给正则表达式更高的优先级，除非有 <code>^~</code> 标识符。准确的匹配流程如下：</p><ol><li>将 URI 与所有的 prefix 进行比对；</li><li>如果 <code>=</code> 标识符的 location 命中了，直接使用该 location 进行处理，匹配过程终止；</li><li>如果有 <code>^~</code> 标识符标识某个 prefix，则后续不用正则表达式检测这个 prefix 命中的 URI；</li><li>保存最长的匹配的 prefix；</li><li>将 URI 与所有的正则表达式进行比对；</li><li>如果 URI 匹配到某个正则表达式，立即停止比对，用这个正则表达式对应的 location 进行处理；</li><li>如果没有正则表达式匹配，用第 4 步保存的最长的 prefix 来处理。</li></ol><p>那么根据这个流程，在配置 <code>/</code> 对应的处理方式时，使用 <code>=</code> 标识符能够提高 Nginx 的响应速度。</p><h2 id="root-index-proxy-pass"><a href="#root-index-proxy-pass" class="headerlink" title="root, index, proxy_pass"></a>root, index, proxy_pass</h2><p><code>root</code>, <code>index</code>, <code>proxy_pass</code> 是几个在 <code>location</code> 区域内常用的指令，这里专门查一下它们的用法。</p><ul><li><code>root path</code> 用文件系统路径来表示，表示在这个 location 中从哪个目录找静态文件来服务；</li><li><code>index file ...</code> 定义首页文件，按照给定顺序注意匹配，最后一个文件名可以是绝对路径；</li><li><code>proxy_pass url</code> 将请求转发到某个代理服务器上。</li></ul><h2 id="变量和改写"><a href="#变量和改写" class="headerlink" title="变量和改写"></a>变量和改写</h2><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在 Nginx 的配置文件中可以使用以 <code>$</code> 开头的变量，和 linux 的 shell 变量相似。Nginx 预定义了很多变量如 <code>$remote_addr</code> 表示客户端的 IP 地址，<code>$uri</code> 表示目前 URI 的值。用户也可以使用 <a href="https://nginx.org/en/docs/http/ngx_http_rewrite_module.html#set">set</a> 和 <a href="https://nginx.org/en/docs/http/ngx_http_map_module.html#map">map</a> 这两个指令在配置文件中自定义变量。</p><p>Nginx 内置的变量列表在这里可以查看：<a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#variables">core HTTP</a></p><h2 id="改写"><a href="#改写" class="headerlink" title="改写"></a>改写</h2><p><strong>return</strong> 使用 <code>return code [url/&quot;string&quot;]</code> 可以给请求返回相应的状态码，或者直接以 <code>30x</code> 的状态码跳转到后续的 <code>url</code>，以 <code>200</code> 的状态码返回一个 string。</p><figure class="highlight bash"><figcaption><span>demoReturn.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location /wrong/url &#123;</span><br><span class="line">    <span class="built_in">return</span> 404;</span><br><span class="line">&#125;</span><br><span class="line">location /permanently/moved/url &#123;</span><br><span class="line">    <span class="built_in">return</span> 301 http://www.example.com/moved/here;</span><br><span class="line">&#125;</span><br><span class="line">location /text/url &#123;</span><br><span class="line">    <span class="built_in">return</span> 200 <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>rewrite</strong> 使用 <code>rewrite regex target cmd</code> 可以将 regex 匹配的路径改写到 target，cmd 这个参数有 <code>break</code> 和 <code>last</code> 这两个最常用的。它们俩的区别有两点：</p><ul><li><code>last</code> 会终止在当前 server 或者 location 区域当中的 rewrite 执行，但是重写到 target 之后落在新的 location 中的 rewrite（如果有的话）还是会继续执行；</li><li><code>break</code> 终止当前背景下的 rewrite 执行之外，新的 location 中的 rewrite 也不会执行。</li></ul><p>rewrite 的例子可以看下面的配置：</p><figure class="highlight bash"><figcaption><span>demoRewrite.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location /users/ &#123;</span><br><span class="line">    rewrite ^/users/(.*)$ /show?user=<span class="variable">$1</span> <span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    rewrite ^(/download/.*)/media/(\w+)\.?.*$ <span class="variable">$1</span>/mp3/<span class="variable">$2</span>.mp3 last;</span><br><span class="line">    rewrite ^(/download/.*)/audio/(\w+)\.?.*$ <span class="variable">$1</span>/mp3/<span class="variable">$2</span>.ra  last;</span><br><span class="line">    <span class="built_in">return</span>  403;</span><br><span class="line">    <span class="comment"># 可以组合使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次走马观花看了一篇最基础的教程有了较多的新认识，服务静态文件、反向代理、压缩和解压缩、内容缓存等等内容在 Nginx Plus 的文档中都有比较系统的讲解，之后有需要或者有时间的时候再看看吧。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deployment </tag>
            
            <tag> Web Server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何相对优雅地使用 GraphQL</title>
      <link href="/2021/07/23/UseGraphQLElegantly/"/>
      <url>/2021/07/23/UseGraphQLElegantly/</url>
      
        <content type="html"><![CDATA[<p>关于 GraphQL，它的<a href="https://graphql.org/">官网</a>(需要科学上网)是这样介绍的：</p><blockquote><p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。</p></blockquote><p>作为 RESTful API 的竞品，GraphQL 从开源之初就备受关注，一是因为它是由 Facebook 开源的项目，二是它<strong>挑战了 RESTful API 的地位</strong>，这是很关键的一点。RESTful API 利用 URI 的具体内容和请求方法来区分请求的资源或者方法，其中的资源 URI 容易与路由路径产生混淆和重复；资源数量达到一定的数目之后，如何给资源 URI 起名或许也是一件困难的事情。而 GraphQL 则鼓励开发者将所有需要请求的信息显式的写在请求体当中，精确到具体的字段，不多也不少。</p><p>我参与的几个项目都是用 GraphQL 作为 API 的基础，我总结出了一个在前端相对优雅地使用 GraphQL 的方法。这篇博客不讨论 GraphQL 的基本概念，主要介绍这个方法。（为省篇幅，这篇博客里面的代码均不做异常处理）</p><span id="more"></span><h1 id="GraphQL-的原始用法"><a href="#GraphQL-的原始用法" class="headerlink" title="GraphQL 的原始用法"></a>GraphQL 的原始用法</h1><p>GraphQL 在前端的表现其实并不新奇：根据定义好的 schema，前端用 post 请求将 query string 和可选的 variables 包装在 body 当中传给后端的某个节点，后端正确响应之后以前端查询的结构将数据返回。</p><h2 id="利用基础方法"><a href="#利用基础方法" class="headerlink" title="利用基础方法"></a>利用基础方法</h2><p>那么根据这个基础我们就能够想到在代码中的用法了，首先在 api.js 中定义一个请求的基础方法：</p><figure class="highlight javascript"><figcaption><span>api/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">graphql</span>(<span class="params">q, vars</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> resp = <span class="keyword">await</span> $axios(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="variable constant_">BASE_URL</span> + <span class="string">&quot;/api/graphql&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">query</span>: q,</span><br><span class="line">      <span class="attr">variables</span>: vars,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="attr">token</span>: <span class="title function_">getYourToken</span>(),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> resp.<span class="property">data</span>.<span class="property">data</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在所有需要请求的地方使用这个基础方法就可以完成 graphql 的请求，可以直接把请求参数嵌在具体的请求方法里面，也可以使用 variables 的方法（但这样会需要在字符串中多写些变量定义）。</p><figure class="highlight javascript"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; graphql &#125; <span class="keyword">from</span> <span class="string">&quot;./api&quot;</span>;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getPerson1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> resp = <span class="keyword">await</span> <span class="title function_">graphql</span>(</span><br><span class="line">    <span class="string">`query &#123;</span></span><br><span class="line"><span class="string">      person(id: <span class="subst">$&#123;id&#125;</span>) &#123;</span></span><br><span class="line"><span class="string">        id name address </span></span><br><span class="line"><span class="string">        age gender mobile</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;`</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getPerson2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> resp = <span class="keyword">await</span> <span class="title function_">graphql</span>(</span><br><span class="line">    <span class="string">`</span></span><br><span class="line"><span class="string">      query ($id: ID!) &#123;</span></span><br><span class="line"><span class="string">        person(id: $id) &#123;</span></span><br><span class="line"><span class="string">          id</span></span><br><span class="line"><span class="string">          name</span></span><br><span class="line"><span class="string">          address</span></span><br><span class="line"><span class="string">          age</span></span><br><span class="line"><span class="string">          gender</span></span><br><span class="line"><span class="string">          mobile</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    &#123; id &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="体验糟糕的查询字符串"><a href="#体验糟糕的查询字符串" class="headerlink" title="体验糟糕的查询字符串"></a>体验糟糕的查询字符串</h2><p>或许你觉得上面的方法还可以接受，但是如果变量中存在数组、枚举值和布尔值时，直接在 query string 中插入变量的体验就会变的很糟糕。像下面这样，我这辈子都不再想见到这样的写法。</p><figure class="highlight javascript"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">heyGuys</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> guys = [<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;carol&quot;</span>, <span class="string">&quot;dave&quot;</span>];</span><br><span class="line">  <span class="keyword">const</span> resp = <span class="keyword">await</span> <span class="title function_">graphql</span>(<span class="string">`</span></span><br><span class="line"><span class="string">    query &#123;</span></span><br><span class="line"><span class="string">      heyGuys(guys: [<span class="subst">$&#123;guys.map((n) =&gt; <span class="string">&#x27;&quot;&#x27;</span> + n + <span class="string">&#x27;&quot;&#x27;</span>).join(<span class="string">&quot;,&quot;</span>)&#125;</span>])</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  `</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="统一管理查询字符串"><a href="#统一管理查询字符串" class="headerlink" title="统一管理查询字符串"></a>统一管理查询字符串</h2><p>在逻辑代码中写大量的 query string 不太利于维护，为此可以将所有字符串分类整理好统一管理。例如放在某个 <code>documents.js</code> 文件内，其他地方需要请求的时候直接从该文件导入即可。这样可以在真正的业务逻辑中避免大量的字符串。</p><figure class="highlight javascript"><figcaption><span>api/documents.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getPersonDoc = <span class="string">`</span></span><br><span class="line"><span class="string">  query ($id: ID!) &#123;</span></span><br><span class="line"><span class="string">    person(id: $id) &#123;</span></span><br><span class="line"><span class="string">      id name address </span></span><br><span class="line"><span class="string">      age gender mobile</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;`</span>;</span><br></pre></td></tr></table></figure><h2 id="问题仍然存在"><a href="#问题仍然存在" class="headerlink" title="问题仍然存在"></a>问题仍然存在</h2><p>上面统一管理查询字符串的体验还凑合，但是真正开发起来就会发现有以下几个问题绕不开：</p><ol><li>我如何知道一个字符串对应的变量应该是什么？只能查看字符串本身的定义；</li><li>我写字符串的时候如何获得代码提示呢？还是说我只能对着后端的 schema 逐字段慢慢写呢？</li><li>既然都统一管理了查询字符串，是不是还得再封装一层查询方法呢？这样业务逻辑处的代码还能更省。</li><li>如果都用字符串如何使用 Fragment 呢？（或许可以看一下 <a href="https://github.com/apollographql/graphql-tag">graphql-tag</a>）</li></ol><h1 id="更好的方法：代码生成"><a href="#更好的方法：代码生成" class="headerlink" title="更好的方法：代码生成"></a>更好的方法：代码生成</h1><p>如果完成一个请求需要先写查询字符串，再封装一个关于这个查询字符串的请求方法，开发效率不会很高。可以看到上面的代码很多都是琐碎且平凡的，既然如此，可以尝试生成代码。为此我们需要了解以下的包或者插件：</p><ol><li><code>@graphql-codegen</code>: <a href="https://www.graphql-code-generator.com/">graphql 代码生成器</a>，一个 npm 包。通过定义的 schema 和 operation 生成包含请求方法的 typescript 文件；</li><li><code>GraphQL</code>: vscode 插件，用作写 <code>.graphql</code> 文件时的自动补全；</li></ol><h2 id="配置-graphql-codegen"><a href="#配置-graphql-codegen" class="headerlink" title="配置 @graphql-codegen"></a>配置 @graphql-codegen</h2><p>按照该包官方文档的指示进行安装配置即可，不需要太多的配置。其官网上还有下图所示的 live example，非常容易弄懂。</p><img src="/2021/07/23/UseGraphQLElegantly/live.png" class="" title="@graphql-codegen 官网的 live example"><p>我在开发中一般会配置两个代码生成配置文件，一个用于同步后端、生成代码补全所依赖的 schema 文件，一个用于生成 operation 对应的请求方法。如下是两个配置文件的大致内容。</p><figure class="highlight yml"><figcaption><span>schema.codegen.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">generates:</span></span><br><span class="line">  <span class="string">./graphql/schema.graphql:</span></span><br><span class="line">    <span class="attr">schema:</span> <span class="string">&quot;BASE_URL/api/graphql&quot;</span></span><br><span class="line">    <span class="attr">plugins:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">schema-ast</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><figcaption><span>operation.codegen.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">generates:</span></span><br><span class="line">  <span class="string">./api/demo.ts:</span></span><br><span class="line">  <span class="attr">documents:</span> <span class="string">&quot;./graphql/operations.graphql&quot;</span></span><br><span class="line">  <span class="attr">schema:</span> <span class="string">&quot;BASE_URL/api/graphql&quot;</span> <span class="comment"># 或者直接使用 &#x27;./graphql/schema.graphql&#x27;</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">typescript</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">typescript-operations</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">typescript-graphql-request</span></span><br></pre></td></tr></table></figure><p>配置文件中的 <code>plugins</code> 配置项是关键。<code>schema.codegen.yml</code> 中的 <code>schema-ast</code> 是生成 schema 的 graphql 文件；<code>operation.codegen.yml</code> 中的 <code>typescript-*</code> 则是生成请求方法所依赖的插件。我这里给出的是使用 <a href="https://github.com/prisma-labs/graphql-request">graphql-request</a> 的例子，<code>graphql-request</code> 是一个轻量、简洁，支持 ts 和 promise-based API 的 GraphQL 客户端，在前后端都能使用。</p><p>生成请求方法所依赖的插件根据项目特点选定，例如 <code>graphql-request</code> 这个插件我用在 Vue2.x 的项目当中，而在 React 的项目中我是用的插件是 <code>React-Query Hooks</code>。每个插件对应的基础库的特点不一样，生成的代码风格也不尽相同，根据需要灵活选择即可。</p><h2 id="编写-operations"><a href="#编写-operations" class="headerlink" title="编写 operations"></a>编写 operations</h2><p>operations 顾名思义就是操作，在 GraphQL 里面操作分为 <code>query</code> 和 <code>mutation</code>，编写具名操作会被 <code>@graphql-codegen</code> 转换成为请求方法。下面给一个例子：</p><figure class="highlight graphql"><figcaption><span>schema.graphql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Gender <span class="punctuation">&#123;</span></span><br><span class="line">  Female</span><br><span class="line">  Male</span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="symbol">id</span><span class="punctuation">:</span> ID<span class="punctuation">!</span></span><br><span class="line">  <span class="symbol">name</span><span class="punctuation">:</span> String<span class="punctuation">!</span></span><br><span class="line">  <span class="symbol">address</span><span class="punctuation">:</span> String<span class="punctuation">!</span></span><br><span class="line">  <span class="symbol">age</span><span class="punctuation">:</span> Int<span class="punctuation">!</span></span><br><span class="line">  <span class="symbol">gender</span><span class="punctuation">:</span> Gender<span class="punctuation">!</span></span><br><span class="line">  <span class="symbol">mobile</span><span class="punctuation">:</span> String<span class="punctuation">!</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">Query</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="symbol">persons</span><span class="punctuation">:</span> <span class="punctuation">[</span>Person<span class="punctuation">!</span><span class="punctuation">]</span><span class="punctuation">!</span></span><br><span class="line">  person<span class="punctuation">(</span><span class="symbol">id</span><span class="punctuation">:</span> ID<span class="punctuation">!</span><span class="punctuation">)</span><span class="punctuation">:</span> Person</span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">Mutation</span> <span class="punctuation">&#123;</span></span><br><span class="line">  setPersonGender<span class="punctuation">(</span><span class="symbol">id</span><span class="punctuation">:</span> ID<span class="punctuation">!</span>, <span class="symbol">gender</span><span class="punctuation">:</span> Gender<span class="punctuation">!</span><span class="punctuation">)</span><span class="punctuation">:</span> Boolean</span><br><span class="line">  greet<span class="punctuation">(</span><span class="symbol">id</span><span class="punctuation">:</span> ID<span class="punctuation">!</span><span class="punctuation">)</span><span class="punctuation">:</span> String<span class="punctuation">!</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight graphql"><figcaption><span>operations.graphql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">query</span> getPersons <span class="punctuation">&#123;</span></span><br><span class="line">  persons <span class="punctuation">&#123;</span></span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">query</span> getPerson<span class="punctuation">(</span><span class="variable">$id</span>: ID<span class="punctuation">!</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  person<span class="punctuation">(</span><span class="symbol">id</span><span class="punctuation">:</span> <span class="variable">$id</span>) <span class="punctuation">&#123;</span></span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    address</span><br><span class="line">    age</span><br><span class="line">    gender</span><br><span class="line">    mobile</span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mutation</span> sayHello<span class="punctuation">(</span><span class="variable">$id</span>: ID<span class="punctuation">!</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  greet<span class="punctuation">(</span><span class="symbol">id</span><span class="punctuation">:</span> <span class="variable">$id</span>)</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>因为用了 vscode 的插件 <code>GraphQL</code>，所以在写 operations 的时候其实是有代码补全的，开发体验比较好，下图是在 vscode 上的代码补全，在 jetBrains 的 IDE 上面的代码自动补全应该会更完善。</p><img src="/2021/07/23/UseGraphQLElegantly/codeSection.png" class="" title="写 .graphql 文件时的代码补全"><h2 id="生成-typescript-代码"><a href="#生成-typescript-代码" class="headerlink" title="生成 typescript 代码"></a>生成 typescript 代码</h2><p>写完上面的 schema 和 operations 之后，运行 <code>graphql-codegen --config operations.codegen.yml</code> 即在 <code>./api</code> 目录下可生成一个 <code>demo.ts</code> 文件。其中包含了下面这样的代码：</p><figure class="highlight typescript"><figcaption><span>api/demo.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 省略了很多</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">defaultWrapper</span>: <span class="title class_">SdkFunctionWrapper</span> = <span class="function">(<span class="params">action, _operationName</span>) =&gt;</span> <span class="title function_">action</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getSdk</span>(<span class="params"></span></span><br><span class="line"><span class="params">  client: GraphQLClient,</span></span><br><span class="line"><span class="params">  withWrapper: SdkFunctionWrapper = defaultWrapper</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">getPersons</span>(</span><br><span class="line">      variables?: <span class="title class_">GetPersonsQueryVariables</span>,</span><br><span class="line">      requestHeaders?: <span class="title class_">Dom</span>.<span class="property">RequestInit</span>[<span class="string">&quot;headers&quot;</span>]</span><br><span class="line">    ): <span class="title class_">Promise</span>&lt;<span class="title class_">GetPersonsQuery</span>&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">withWrapper</span>(</span><br><span class="line">        <span class="function">(<span class="params">wrappedRequestHeaders</span>) =&gt;</span></span><br><span class="line">          client.<span class="property">request</span>&lt;<span class="title class_">GetPersonsQuery</span>&gt;(<span class="title class_">GetPersonsDocument</span>, variables, &#123;</span><br><span class="line">            ...requestHeaders,</span><br><span class="line">            ...wrappedRequestHeaders,</span><br><span class="line">          &#125;),</span><br><span class="line">        <span class="string">&quot;getPersons&quot;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">getPerson</span>(</span><br><span class="line">      <span class="attr">variables</span>: <span class="title class_">GetPersonQueryVariables</span>,</span><br><span class="line">      requestHeaders?: <span class="title class_">Dom</span>.<span class="property">RequestInit</span>[<span class="string">&quot;headers&quot;</span>]</span><br><span class="line">    ): <span class="title class_">Promise</span>&lt;<span class="title class_">GetPersonQuery</span>&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">withWrapper</span>(</span><br><span class="line">        <span class="function">(<span class="params">wrappedRequestHeaders</span>) =&gt;</span></span><br><span class="line">          client.<span class="property">request</span>&lt;<span class="title class_">GetPersonQuery</span>&gt;(<span class="title class_">GetPersonDocument</span>, variables, &#123;</span><br><span class="line">            ...requestHeaders,</span><br><span class="line">            ...wrappedRequestHeaders,</span><br><span class="line">          &#125;),</span><br><span class="line">        <span class="string">&quot;getPerson&quot;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">sayHello</span>(</span><br><span class="line">      <span class="attr">variables</span>: <span class="title class_">SayHelloMutationVariables</span>,</span><br><span class="line">      requestHeaders?: <span class="title class_">Dom</span>.<span class="property">RequestInit</span>[<span class="string">&quot;headers&quot;</span>]</span><br><span class="line">    ): <span class="title class_">Promise</span>&lt;<span class="title class_">SayHelloMutation</span>&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">withWrapper</span>(</span><br><span class="line">        <span class="function">(<span class="params">wrappedRequestHeaders</span>) =&gt;</span></span><br><span class="line">          client.<span class="property">request</span>&lt;<span class="title class_">SayHelloMutation</span>&gt;(<span class="title class_">SayHelloDocument</span>, variables, &#123;</span><br><span class="line">            ...requestHeaders,</span><br><span class="line">            ...wrappedRequestHeaders,</span><br><span class="line">          &#125;),</span><br><span class="line">        <span class="string">&quot;sayHello&quot;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Sdk</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> getSdk&gt;;</span><br></pre></td></tr></table></figure><p>可以看到 <code>getSdk</code> 这个函数会返回一个对象，其中包含了刚刚在在 <code>operations.graphql</code> 中定义的几个操作。这样就从类型上锁定了这个方法的名字、参数以及返回值。这对于项目维护和开发来说无疑都是利好的。</p><h2 id="使用生成的代码"><a href="#使用生成的代码" class="headerlink" title="使用生成的代码"></a>使用生成的代码</h2><p>因为真正使用的请求方法肯定是要鉴权的，我们需要再调整一下生成的代码，看到上面 <code>demo.ts</code> 中的 <code>defaultWrapper</code> 函数了吗？我们只需要在调用 <code>getSdk</code> 时传入自定义的 Wrapper 即可。下面给个例子：</p><figure class="highlight typescript"><figcaption><span>api/index.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getSdk <span class="keyword">as</span> getDemoSdk &#125; <span class="keyword">from</span> <span class="string">&quot;./demo&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getClientOptions</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> apiWrapper = <span class="keyword">async</span> &lt;T&gt;<span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  action: (headers?: Record&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;) =&gt; <span class="built_in">Promise</span>&lt;T&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> headers = &#123; <span class="attr">token</span>: <span class="title function_">getYourToken</span>() &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">action</span>(headers);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> demoClient = <span class="title function_">getDemoSdk</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">GraphQLClient</span>(<span class="string">&quot;/api/graphql&quot;</span>, <span class="title function_">getClientOptions</span>()),</span><br><span class="line">  apiWrapper</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在需要用到的地方只需要导入 <code>demoClient</code> 即可，我们再用几行代码重写一遍上面的 <code>getPerson</code> 函数：</p><figure class="highlight javascript"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; demoClient &#125; <span class="keyword">from</span> <span class="string">&quot;./api&quot;</span>;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getPerson3</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> resp = <span class="keyword">await</span> demoClient.<span class="title function_">getPerson</span>(&#123; id &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> GraphQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记2021年小程序大赛</title>
      <link href="/2021/07/20/TheThirdMiniprogramCompetition/"/>
      <url>/2021/07/20/TheThirdMiniprogramCompetition/</url>
      
        <content type="html"><![CDATA[<p>从本科到现在总共参加过三次微信小程序大赛，前几天刚完成赛区决赛的答辩，心想着以后应该都不想再参加了，于是想记录一下这次的参赛经历。</p><h1 id="2018-和-2020"><a href="#2018-和-2020" class="headerlink" title="2018 和 2020"></a>2018 和 2020</h1><h2 id="2018-阴差阳错"><a href="#2018-阴差阳错" class="headerlink" title="2018 阴差阳错"></a>2018 阴差阳错</h2><p>微信小程序从 2017 年正式上线博得广大关注，在第二年 2018 年春季，微信就推出了全国高校微信小程序开发大赛，吸引了很多大学生参加，我就是其中一个。正在读大二的我报名了一位学长组织的 SRT(Student Research Training) 项目，原本的题目是要开发一款在线客服平台。然而当时已经把项目申请里面提到的客服平台提前完成了，于是我们真正做的就变成了小程序。甚至还用这个小程序参加了第一届的微信小程序大赛。</p><span id="more"></span><p>虽然做的东西和项目选题没太大关系，不记得当时具体开发的小程序有些什么功能，最后也没有拿到什么奖项（但隐约记得有证书）但通过这项目我第一次接触到了 Javascript、Vue 和微信小程序这些新东西，也认识了几位非常靠谱的队友（在之后的课程作业组队当中也延续了组队），我的收获不少，所以还是非常感谢这次项目经历的。</p><h2 id="2020-毫无波澜"><a href="#2020-毫无波澜" class="headerlink" title="2020 毫无波澜"></a>2020 毫无波澜</h2><p>第二次是在 2020 年用课题组的一个项目参加的比赛，进了华北赛区的决赛，但着实因为我们准备的不够充分而且其他队伍的作品也比较优秀，我们最终也止步于此。得到这个结果我不是特别遗憾，因为我在准备赛区答辩时就有了心理预期，所以说这次参加比赛的内心感受就是毫无波澜吧。</p><h1 id="2021-年"><a href="#2021-年" class="headerlink" title="2021 年"></a>2021 年</h1><h2 id="小程序背景"><a href="#小程序背景" class="headerlink" title="小程序背景"></a>小程序背景</h2><p>如果说对第二次参加比赛的小程序我只是一知半解，那么今年参加比赛的作品我就是了如指掌。因为这是我们大三学期上《软件工程》课程时做的课程作业，它的背景是给学校艺教中心开发一套能够方便琴房管理和琴房预约的系统。</p><p>本来以为这个作业像往常那样只停留在“作业”这个层面，不会有实际使用价值。但是授课老师认为我们组做得不错，于是真正帮我们联系到了艺教中心的老师开了个会。会上艺教中心老师对我们的系统非常满意，这让我们喜出望外，但同时也给我们提了一些问题，例如还没有接入清华校内统一身份认证接口、没有接入校内支付接口等等，但我们相信后面都可以解决的。</p><p>那个学期过得很快，我们组的作品获得了 A 的评分，但是我们小程序的上线过程却不那么顺利：因为要接入校内的接口，我们需要把程序部署到校内的服务器上，之后经历了漫长的申请服务器、申请域名、申请安全扫描、申请证书、申请身份认证接口权限、申请财务接口权限等流程，期间还经历了新冠疫情爆发回不了学校的一个学期以及需求变动重新开发新模块… 功夫不负有心人，终于万事俱备申请上线了，那报名参加比赛吧。小程序名字叫做“掌上艺教”。</p><h2 id="定位和需求分析"><a href="#定位和需求分析" class="headerlink" title="定位和需求分析"></a>定位和需求分析</h2><h2 id="小程序的定位"><a href="#小程序的定位" class="headerlink" title="小程序的定位"></a>小程序的定位</h2><p>掌上艺教是一个涵盖清华大学艺术教育中心琴房租赁和课程管理的一站式系统。面向三类不同的用户，他提供不同的功能。 <br>面向在校师生、教职工和居民，掌上艺教提供了校内外两种安全高效的身份认证方式，认证用户可查看琴房空闲时间、预约琴房、在线付款、查看订单和核验电子票等；面向艺教中心开课教师，除了琴房预约外，还提供课程申报、志愿填报等功能；艺教办公室老师可以使用系统的管理后台应用对琴房租赁和课程业务进行管理；</p><h2 id="需求痛点"><a href="#需求痛点" class="headerlink" title="需求痛点"></a>需求痛点</h2><p>清华大学艺教中心历史悠久，业务众多。它每年开设艺术类选修课程 160 门次，指导学生艺术团 12 支队伍共 1300 名队员的排练，同时需要管理校内众多文艺场馆。</p><p>但是艺教中心目前的业务存在<strong>信息化不足、办公效率低</strong>的问题。表现在具体的业务当中有以下两个方面：</p><ol><li><p><strong>在琴房业务中</strong>，艺教中心采用“办卡储值，打孔消费”这样比较原始的机制，容易造成浪费和卡片丢失的问题；同学们要想预约琴房只能亲自去艺教中心询问是否有空余的琴房，这样费时又费力；另外，老师如果想查询、统计和备份数据或者是进行用户管理就很难办到了。这样的局面对于老师管理琴房和同学预约使用琴房来说都非常麻烦。</p></li><li><p><strong>在课程管理上</strong>，开课教师和办公室老师们通过邮件和微信沟通开课意向和期望志愿缺乏系统性，而且在邮件或微信往来过程中信息很容易丢失；最最要命的是，收集到课程信息后，办公室老师需要把 160 门课程的开课时间、上课地点手动地排在一张 Excel 大表里。手动操作出错的概率很高，但是一旦出错会给开课教师、艺教中心和学校教务带来很大的麻烦。下面这张图片就是手动排课时用的表格截图，当然这只是冰山一角。</p></li></ol><img src="/2021/07/20/TheThirdMiniprogramCompetition/manuallySchedule.png" class="" title="手动排课的表格"><p>我们的系统就是要解决上述的痛点。</p><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>我们开发了<strong>掌上艺教小程序</strong>和与之配套的两个管理后台（分别对应<strong>琴房和课程业务</strong>），其中小程序的主要功能有：</p><ol><li><strong>身份认证：</strong>对校内外用户分别进行相应的身份认证，对接清华大学统一身份认证；</li><li><strong>查看课程表：</strong>开课教师能够查看当前学期自己开课的课程表；</li><li><strong>课程信息查看：</strong>开课教师能够查看自己或者其他教师所开课程的信息；</li><li><strong>开课意向填报：</strong>开课征集期间，任课教师可以在小程序中填写开课意向和排课志愿；</li><li><strong>排课信息确认：</strong>艺教办公室老师在后台生成排课表之后，开课教师能够查看并确认课表是否符合预期；</li><li><strong>琴房浏览：</strong>使用掌上艺教能查看艺教中心对外开放租赁的琴房列表并查看它们的信息如空闲时间、租赁单价、位置简介等；</li><li><strong>支付定金：</strong>预订琴房后可在线支付定金，完成支付后将获取订单核验二维码；</li><li><strong>代金券折扣：</strong>支付定金时可使用代金券抵扣指定额度的琴房定金；</li><li><strong>电子票核验：</strong>琴房入检人员可以扫描支付完成的订单二维码核验信息并准入。</li></ol><p>课程管理后台的主要功能有：</p><ol><li><strong>课程信息管理：</strong>可以对系统内课程信息进行增删改查，包括但不限于某一学期内开课教师所创建的课程；</li><li><strong>教学场地资源管理：</strong>可在系统中维护教学场地包括教室地点、教室容量、教室属性等在内的信息；</li><li><strong>排课表生成与调整：</strong>开课教师提交完成排课志愿后，系统将根据开课教师的志愿信息和在系统中设置的权重策略，对所有课程进行自动编排。自动生成出的课表可以进行手动调整；</li><li><strong>后台账号管理：</strong>可以对人员进行账号管理，包括启用&#x2F;禁用账号、账号密码重置及权限管理；</li><li><strong>教师名单维护：</strong>通过维护教师名单可控制哪些用户能够使用排课系统；</li><li><strong>通知公告：</strong>在管理后台可使用富文本编辑器编辑发布通知公告，并查看教师们的阅览情况（已读或者未读）。</li></ol><p>琴房管理后台的主要功能有：</p><ol><li><strong>琴房信息维护：</strong>可以对琴房列表和琴房信息进行维护，包括琴房名称、位置、头图和占用规则（规律性占用）等；</li><li><strong>订单管理：</strong>可以通过姓名、手机号、证件号、预约时间段、预约琴房等条件进行订单查询与统计，并查看或修改订单详情；</li><li><strong>用户管理：</strong>可通过姓名、手机号、证件号等字段查询用户详情，进入用户详情可将用户纳入黑名单、查看用户的订单和代金券等；</li><li><strong>用户组管理：</strong>通过设置用户组对琴房的预约权限、租赁单价和用户列表，可以实现用户的权限管理和租赁单价管理；</li><li><strong>代金券管理：</strong>可向指定用户手动发放代金券或向指定用户组周期性发放代金券用于琴房定金抵扣。</li></ol><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><img src="/2021/07/20/TheThirdMiniprogramCompetition/architecture.png" class="" title="系统架构图"><p>系统架构方面，我们选用了 Vue.js 作为 Web 应用的开发框架，小程序则使用微信原生框架进行开发。前后端通讯方面我们使用的是 <a href="https://graphql.org/">GraphQL</a>（可能需要科学上网），这和传统的 RESTful API 相比有很多优点，在这里就不展开说了。后端则借鉴了流行的微服务架构的思想，把两部分后端服务进行了实现和部署上的拆分（可以看到两个后端服务的开发语言都不一样），同时两个服务都采取了容器化的部署方式，极大地降低了开发和运维成本，同时减少了系统整体不可用的风险。</p><p>后端服务拆分实现部署的开发方式我们还是第一次采用，这确实给我们的系统带来了很高的灵活性，技术栈的选择也更加自由。而且，通过实现服务间通信，各个实体之间的交流更加密切，可以做到更多有趣的事情。例如微信小程序用户的登录状态存在一个服务 A 上，当另一个服务 B 也需要用到该状态时，可以通过直接向 A 发请求拿到相应的信息。在我们的系统当中，服务间通信是直接发 HTTP 请求，以前实习时做的系统用的是 <a href="https://grpc.io/">gRPC</a> 和 <a href="https://developers.google.com/protocol-buffers/docs/overview">protobuf</a> 来完成的。不过本质都差不多。</p><h2 id="比赛结果"><a href="#比赛结果" class="headerlink" title="比赛结果"></a>比赛结果</h2><p>赛区决赛当天晚上其实就已经出结果了，我们的小程序是华北赛区第 5 名，是三次比赛当中名次最高的了。虽然可能进不了全国决赛，但是我还是能够接受这个名次的。前几名的作品确实有着非常好的产品定位（例如第 2 名“帮你学拼音打字”目标是帮助中老年人学习使用手机拼音打字）和非常高的完成度（例如第 1 名“方仔照相馆”），我们的小程序作为一款在校内使用的半开放式小程序，格局比起他们的来说还是小了不少。</p><h1 id="最后的感想"><a href="#最后的感想" class="headerlink" title="最后的感想"></a>最后的感想</h1><p>2021 年的微信小程序大赛其实已经稍见颓势，从取消微信小游戏赛道这方面就能看出微信不太重视这场比赛了。参赛作品的<strong>多样性和创新性也随着时间的推移逐渐降低</strong>，越来越难以见到让人眼前一亮的好的作品。所以比赛不再受重视也不奇怪，微信一开始推出这个比赛就是想借助有热情有活力的大学生群体带动小程序的市场，而到了 2019~2020 年微信小程序其实已经占据市场主导地位，不再需要依靠比赛来扩大影响力了。</p><p>另外比赛的风气也不太好，2020 年的华北赛区决赛好像就出现了相互举报的状况，有点无语也有点无聊。不知道明年这个比赛还会不会办下去，不过就算继续办我也不太想再参与：我的热情被小程序开发消磨掉不少，也没有太多创新的点子想付诸小程序开发。小程序对于用户来说有着很不错的体验，但是对于我们开发者来说小程序是处处受限的前端应用，这也不能用那也不行。没错现在我已经不想“用户至上”了，我想做更纯粹一些的开发。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 胡思乱想 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我毕业了</title>
      <link href="/2021/06/29/Graduation2021/"/>
      <url>/2021/06/29/Graduation2021/</url>
      
        <content type="html"><![CDATA[<p>从 2016 年 8 月来到北京上学，到现在已经快要五年了。近期借着学校给 2020 届补办毕业典礼的契机，得以穿上学士服跟朋友们同学们一起拍毕业照。课程学习生活暂告一段落，心里有很多感慨不吐不快。</p><p>大概从以下几个方面来聊一聊吧：专业选择给我的影响，母校之于我的意义以及自己的成长和收获。</p><h1 id="专业选择"><a href="#专业选择" class="headerlink" title="专业选择"></a>专业选择</h1><p>用为期两天的高考结束了漫长枯燥的高中生活之后，我进入了软件学院继续学习，专业名称是<strong>软件工程</strong>。其实我填报志愿时对母校的专业不是很了解，在招生组老师和学长学姐的介绍之下选择了这个和计算机相关性最大的专业。（对没错，当时我们省不招计算机）</p><span id="more"></span><h2 id="差距很大"><a href="#差距很大" class="headerlink" title="差距很大"></a>差距很大</h2><p>作为小镇做题家的零基础计算机小白，在入学之后很快地就感受到了和其他同学的差距，尤其是编程作业一些同学一小时完成而我要花上一下午甚至一整天的时候。学校的学期中学习压力很大，<strong>26 学分</strong>左右的课程基本上意味着一周五天都是课，每天都有作业要做。当时编程能力十分落后带来的影响导致一些基础数理课也有些吃紧，好在最后都没有触到挂科这个的情况。我经常问我室友或者年级里的其他同学作业问题，怕总是问一个同学把他问烦我就在一些同学之间来回换着问。<strong>在这里要由衷感谢几位大神和我的室友们。</strong></p><h2 id="兴趣渐浓"><a href="#兴趣渐浓" class="headerlink" title="兴趣渐浓"></a>兴趣渐浓</h2><p>我从小就对电脑这东西比较感兴趣，不管是电脑游戏还是一些电脑应用，总是喜欢自己捣鼓。来到软件学院也算是得偿所愿，尤其是很多课程的大作业（或许有的学校叫做“课程设计”）都是写游戏，很对我的胃口。本科应该一共写了 3 个游戏，虽然质量都很差，但是写的过程还是快乐的。我发现我喜欢自己造一些东西出来，写一个游戏、发布一个包或者库、开发一个系统这些都是比较吸引我的事情。<strong>比起考试这样的紧张刺激的课程考核形式，开发游戏或者系统这样成果看得见摸得着的事情，让我觉得更加踏实。</strong>可能总的来说我还是比较希望规避不确定性，拥抱更多的确定性吧。或许这也从一个方面体现了其实我不是天赋型选手，勤能补拙应该是我需要考虑的第一要义。</p><p>大三上了《软件工程》这门课，和另外三个队友真刀真枪的开发一个系统：需求分析、原型设计、技术选型、数据库设计、功能实现、系统测试、文档撰写这些软工流程我们完整地体验了下来，最后课程成绩比较好。我也发现了我确实挺喜欢写代码的。后来的数据库、计算机网络等课程，包括后来到旷视实习的经历都进一步加深了我的兴趣。让我逐渐明晰喜欢的事情。</p><h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><p>开发的琴房预约系统目前已经上线，虽然之前的队友不太有热情来维护这个项目了，但是就算是我一个人我也会把这个项目好好维护到我自己毕业；作为辅导员，我自己开发了一个系统给自己和同学们用来查询成绩和排名，也给其他辅导员开发了一个计算排名和查询成绩的网站；面对新颖的、高效的、优雅的技术我总是会心生向往，很难控制自己想去了解一下的冲动，可能就是喜欢折腾吧。每次想尝试一个东西我都会在 github 上创建一个叫做 XXX-taste 的 repository，现在类似的 repo 好像已经有十来个了。我觉得目前我对我所做的事情还是保有相当的热情，也愿意为之投入更多的时间。</p><h1 id="母校之于我"><a href="#母校之于我" class="headerlink" title="母校之于我"></a>母校之于我</h1><p>在学校待了五年，要说它给我带来了什么或者让我失去了什么可能很难用言语梳理出来，列一下现在能想到的几点吧：</p><ol><li><p>学校给我上的第一课就是接受平凡，在高中三年大大小小的考试中我很少考第二名，但是到了这里要接受自己是个计算机小白，排名只在中等水平的事实。</p></li><li><p>如果拿不了95分，那么80分也挺好，好好完成课业任务，心态要稳。与其跟别人在成绩上卷，不如做自己感兴趣的、有意义的事情。</p></li><li><p>大学里学的不只是课内知识，更要学习待人处事的方法，增强面对挫折的勇气，拓宽所处世界的视野。</p></li><li><p>朋友很重要，尤其在校园这个小社会当中，他们就是自己的靠山了。</p></li><li><p>入党是一件非常庄严的事情，如果不是明确清晰地认同党的路线和纲领，请不要申请入党或者发展这样的同学。</p></li><li><p>不要总是窝在寝室打游戏，户外真实的风和阳光比游戏中的虚拟更加美好。</p></li></ol><h1 id="总结和展望"><a href="#总结和展望" class="headerlink" title="总结和展望"></a>总结和展望</h1><p>大学里拿过一些4.0，也险些挂了某些课程；当过班长、学生会主席，现在还在继续做着辅导员这份学生工作；感情方面谈过异地恋、异国恋，当过舔狗，被劈过腿。生活体验可以说是非常丰富了（甚至有些离谱），从这些经历中得到了什么成长呢？得到了较强的心理承受能力吗哈哈，挺过挂科边缘的压力还是需要一定的承受力的；一边忙着各种课程作业，一边手忙脚乱地筹办学生节也是很难得的体验，更何况我们还产出了很多优秀的文艺节目；谈的几段感情都是异地，美好的回忆当然是有的，但是遗憾更多吧，这几段经历都无一例外地让我变得更加成熟了。</p><p>距离完全跃入人海还剩下不到两年的时间，通过这五年的时间我应该能够以更好的姿态来迎接未来两年的挑战，也希望剩下的两年里可以多做些自己想做的事情，不留遗憾。冲鸭~</p><p>再回过头来看，我发现自己是极其幸运的，所学专业和兴趣爱好高度重合，这使得我在持续的学习过程中能够保持专注、维持平和。关于平稳心态的一切对我过去、当今和未来的生活都有着、都将有至关重要的影响。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 胡思乱想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>青岛（二）</title>
      <link href="/2021/06/13/JourneyToTsingTao-2/"/>
      <url>/2021/06/13/JourneyToTsingTao-2/</url>
      
        <content type="html"><![CDATA[<p>从青岛回来之后马上就是学生节和一系列的课程、任务和作业，根本没时间和心情来写这篇博客，所以青岛（二）这一篇拖了很久…<br>但是过了一个多月的时间很难再拾起当时的心情了，从拍下来的照片里才能记起来去过哪里有哪些好玩的地方，可以说是看图说话。反正也没人看，我直接这样随便写写就当给自己一个交代好了，不喜欢做半途而废的事情。正义虽然会迟到，但永远不会缺席。</p><p>这一篇我们主要是去了崂山、信号山公园、天主教堂、五四广场转了转。</p><span id="more"></span><h1 id="崂山仰口"><a href="#崂山仰口" class="headerlink" title="崂山仰口"></a>崂山仰口</h1><h2 id="海边"><a href="#海边" class="headerlink" title="海边"></a>海边</h2><p>不知道我们怎么想的，不远千里的到青岛去爬山受累，可能这就是正经的游客吧？在前往青岛的高铁上我们才开始做攻略，在马蜂窝上找了几个青岛游的攻略，都说崂山是必须要去的地方，所以我们把崂山列在我们第二天的行程当中。好巧不巧我们选了仰口区，从市区里过去要做两个小时的地铁大巴，实在是太久了。在第一天的 2 万步之后我坐完这两小时的行程时已经有一点蔫了，到了景区下车的时候热浪扑面，虽然前一天很冷，但是这天中午阳光非常充足，把前一天的凉意一扫而空。仰口景区的结构是这样的，景点的起点是在山脚，离海非常近的位置，我们先在海边玩了玩。买了风筝想在海边放，但是奈何海风太猛且方向不确定，很难让风筝飞得高远且持久。朋友都弄的鞋里都是沙子了，但就是不能让风筝飞得让自己满意——只能怪风况不佳咯。</p><p>此时已经是 12 点多，我们还没有吃午饭，于是灰溜溜的到周边去找地方吃饭。景点里的餐厅又贵又难吃这是我们的共识，于是我们找了一家超市，各吃了一桶方便面（实惨）并买了一些饮料和物资背在包里开始上山了。</p><h2 id="山和海"><a href="#山和海" class="headerlink" title="山和海"></a>山和海</h2><p>天公不作美，我们刚检票入园就下起了雨，我们撑伞走了一段时间雨才完全停。不过这也算好，这也使得景区没有特别热。仰口景区有些道观和寺庙，这些我不是特别感兴趣就不提了。随着爬的高度越来越高，视野逐渐开阔时，我的心情还是很激动的，毕竟很少看到这样的山海景，波澜壮阔、云海翻涌的场景不由的在脑海里开始放映。我们爬到一定高度后在一个亭子里拍了下面第一张照片，山、海、天交相辉映…很难形容我当时的想法。</p><img src="/2021/06/13/JourneyToTsingTao-2/level1.jpg" class="" title="山麓的某亭中"><img src="/2021/06/13/JourneyToTsingTao-2/level2.jpg" class="" title="又上了一些高度"><img src="/2021/06/13/JourneyToTsingTao-2/level3.jpg" class="" title="又又上了一些高度"><img src="/2021/06/13/JourneyToTsingTao-2/level4.jpg" class="" title="山顶的样子"><p>上面的照片是随着高度的不断提升排列的，每上一定的高度都会有不同的景象，每个地方我都拍了一些，其中最后一张是在山顶拍的。</p><p>山顶风特别大。有一个景点叫做“天苑”，一块巨石被另外的石块三个点支撑着却稳稳地立了起来，很有意思。山顶的驻足点由山体本身和一些悬空的木质围栏、栈道组成，些微恐高的我站在木质栈道上有点胆战心惊的，生怕被风给吹垮了或者是被这么多人的重量给压垮。站在上面看着山麓茂密的树林和蔚蓝的海水及其上随风而动的云的阴影，体会到了在北京爬山体会不到的感觉。（毕竟在北京爬山都看不到海）</p><h2 id="觅天洞"><a href="#觅天洞" class="headerlink" title="觅天洞"></a>觅天洞</h2><p>明明可以走平坦的路，我们偏偏选了特别难走的一条。去往山顶可以走常规的楼梯和一个叫做觅天洞的地方，我们也没多想就选择走觅天洞这条路了。进“洞”之前我们看到了一些警示标语——“患心脏病或者心脑血管疾病人士请折返”，我们还纳闷这不就是一个景点至于这样警告游客吗？我们偏不信就进去了。</p><p>然而结果就是它真的和它的名字一样是一个洞，内部非常的潮湿、狭窄、黑暗。我们在其中全程蹲下来扶着墙走，遇到需要爬楼梯的地方我们也几乎是贴墙爬行，用“贴地爬行”一点也不夸张，非常狼狈。爬了二十多米的高度之后终于到了开阔一点的地方，能够看到阳光了。我至今能够想起当时大家一起“苟”的样子，除了我们几个小伙子外还有一些爷爷奶奶辈的人，我非常担心这些人群的安全。非常不推荐以后有人走这个地方：我觉得这个地方作为一个景点是不合格的，标语警示强度不足，谁能知道里面是这样一个样子呢？</p><p>没有图，就是一个约莫一人宽的洞。非要说它给我留下什么好的印象的话，那就是或许可以当作体验一下桃花源记渔人见到“山有小口，仿佛若有光，便舍船，从口入”的经历吧。</p><h2 id="下山"><a href="#下山" class="headerlink" title="下山"></a>下山</h2><p>下山感觉比上山还累，因为上山的时候腿脚已经很疲惫了，下山走楼梯又要不断地给膝盖压力，到山脚的时候感觉膝盖有点废了。又是两个小时的大巴地铁回到住处之后天已经黑了，随便吃了一点东西我们就休息了。</p><p>其实还按照网上的攻略指示去了一趟“劈柴院”，就是一条哪里都有的古风商业街。真的是 哪 里 都 有。一点意思都没有。</p><h1 id="天主教堂、五四广场"><a href="#天主教堂、五四广场" class="headerlink" title="天主教堂、五四广场"></a>天主教堂、五四广场</h1><p>其实没有什么新颖的和印象深刻的东西值得一提。就放几张照片吧，从上到下依次是天主教堂里的窗户、鱼山路某咖啡馆里的大猫、奥帆中心的帆船和海。</p><img src="/2021/06/13/JourneyToTsingTao-2/church.jpg" class="" title="天主教堂里的窗户"><img src="/2021/06/13/JourneyToTsingTao-2/cat.jpg" class="" title="鱼山路咖啡馆的猫"><img src="/2021/06/13/JourneyToTsingTao-2/sailingBoat.jpg" class="" title="奥帆中心"><h1 id="在六月的夏天里写五月的海"><a href="#在六月的夏天里写五月的海" class="headerlink" title="在六月的夏天里写五月的海"></a>在六月的夏天里写五月的海</h1><p>一篇游记拖了一个月才凭借着回忆来写属实有点不可思议，但是这一个月里有很多的课程任务、课题组和辅导员的工作需要处理。直到自己最近把课程的事情都处理完，才能闲下来写这篇博客。</p><p>我发现当我有其他非常要紧且糟心的事情需要解决的时候，我总是很难静下心来做写博客、拍照片、写闲代码这样的事情。可能我的“多线程”能力还有待提高吧，或许是我的抗压能力不太行？听过很多关于现代人时间管理方面的说法，时间是海绵里的水，挤一挤总是会有的，觉得现在看大家在朋友圈里玩得很欢乐，其实玩乐之后还是有很多事情是亟待完成的。</p><p>绝大多数的人无非都是带着脚镣跳舞，但是我带着脚镣的时候我想的不是如何跳舞，而是如何把脚镣解开。这或许是不太现实、不太成熟的想法。生活中谁能够完全把手铐脚镣解开呢？解开一个脚镣之后又会发现自己被新的、更大的脚镣锁住，如何戴着脚镣跳舞，如何把脚镣舞跳好可能是未来的我给自己的重要课题。</p><p>北京的六月特别热，让我又想起了青岛五月的海风了。</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 旅游 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>青岛（一）</title>
      <link href="/2021/05/05/JourneyToTsingTao-1/"/>
      <url>/2021/05/05/JourneyToTsingTao-1/</url>
      
        <content type="html"><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><p>最近两个月遇到了不少的烦心事，让我颓废了好一阵子：懒得写博客，懒得跟人说话。很久没有到过海边，都要忘了在海边吹风是什么感觉了，趁着这次五一假期，和两个朋友一起去青岛玩了玩。虽然总共只待了 3 天 4 晚，但是还是有两点收获：</p><ol><li>青岛是一个不错的城市；</li><li>不要在黄金周出游；</li></ol><p>首先，临海的青岛让我这个南方人感受到了久违的湿润，终于不用担心因为干燥导致的皮肤瘙痒和手指倒刺，让我能够把身体乳和护手霜安心地放在行李箱里。青岛风景很美，海鲜很丰富，从视觉和味觉上都给了我满足感。</p><span id="more"></span><p>可能也是因为它的好，让大家在黄金周里都想去看看。我们 4 月 29 号晚上到时还很冷清，街道上车马稀疏，但到了 5 月 1 号立马到处都人挤人起来——我们计划中的不少的去处都是被人海给劝退的，比如信号山公园和小麦岛等等。我很讨厌人扎堆的地方，不管再好的去处，一旦人群密集起来我就会变得很焦躁。今年五一期间大家因为疫情缓和而报复性出游，让我感受到了人们的热情。所以趁着还在学校读书，假期安排比较自由，以后还是尽可能在非公共节假日出游吧。</p><h1 id="栈桥、啤酒和皮皮虾"><a href="#栈桥、啤酒和皮皮虾" class="headerlink" title="栈桥、啤酒和皮皮虾"></a>栈桥、啤酒和皮皮虾</h1><h2 id="栈桥"><a href="#栈桥" class="headerlink" title="栈桥"></a>栈桥</h2><p>4 月 30 号我们开始了第一天的游玩，风特别大，尤其是在海边。虽然 14 度的气温不比北京低多少，但是直观感受起来体感温度可能只有七八度，大概率是 60%的湿度导致的吧。</p><img src="/2021/05/05/JourneyToTsingTao-1/skyOn28Floor.png" class="" title="28楼的窗外"><p>我们住在青岛火车站旁边的一栋高楼里，距离海边特别近，随便吃了点早餐就往海边走了。路上遇到了很多位推销旅游项目（游船、快艇、潜水等）的大叔大妈，“4 月 30 号人少半价，明天再来就不划算了”。我对这种主动推销的旅游项目不是特别感兴趣，我只想自己沿着海岸走走看看、踩踩沙滩，不想因为“今天便宜”就去坐船或者潜水。</p><p>但是旅游嘛，总是要花些冤枉钱的。他们俩很想坐游船和潜水捕捞，一起来的还是不要扫他们兴比较好，我就也买了游船的票。潜水是真的不敢去，大风低温的天气下水和冬泳没什么区别了。游览栈桥的计划就暂停了，我们坐上一辆面包车被一起送到了不远的潜水俱乐部。在他俩潜水的时间里，我就在八大峡广场周围走了走，吹吹海风，拍拍照片。下面是几张我比较喜欢的照片。</p><img src="/2021/05/05/JourneyToTsingTao-1/shore1.png" class="" title="晌午的阳光"><img src="/2021/05/05/JourneyToTsingTao-1/shore2.png" class="" title="远处的电视塔"><img src="/2021/05/05/JourneyToTsingTao-1/ship1.png" class="" title="大海和行船"><p>因为是刚接触摄影，对用光、构图和相机参数都没有特别深入的了解，基本都是用半自动模式靠感觉瞎拍的。但是把看到的东西好好的拍下来的仪式感也非常契合我对“记录”本身的喜爱。</p><p>他们俩从水里出来之后很长一段时间都在瑟瑟发抖，可以看出确实很冷，同时我也庆幸自己没跟着去。他们还从海底捞出来一些贝壳和海星，观感不太好就不在这里放照片了，而且到晚上它们都发臭了…收拾好后我们才开始往栈桥方向走。这时候是中午 12 点多，但是温度反而比上午 10 点更低了，沿着海边从俱乐部走到栈桥的过程中经历了急风骤雨和雨过天晴，现在想起来这也算是一种奇妙的体验了。</p><p>栈桥景区的结构挺漂亮的，拱桥长廊和末端的回澜阁一起组成了“海上如意”的形状。有很多人喂海鸥，有人把吃食放手掌上，海鸥都不过来；有人直接把吃食往空中抛，靠近的海鸥们会竞相争食。还挺有意思的。</p><img src="/2021/05/05/JourneyToTsingTao-1/seagull.png" class="" title="拍不清的海鸥"><img src="/2021/05/05/JourneyToTsingTao-1/ship2.png" class="" title="回澜阁背后的海"><h2 id="啤酒博物馆"><a href="#啤酒博物馆" class="headerlink" title="啤酒博物馆"></a>啤酒博物馆</h2><p>每去到一个地方我就想去当地的博物馆。提起青岛肯定就会想起青岛啤酒，在网上看了攻略的我们在这样寒冷的天气里还是决定离开栈桥前往啤酒博物馆。我们叫了辆滴滴，但是司机偏偏不走系统推荐的稍微远一点但是不堵的路线，而是选择了走大学路。虽然行程时间比预计的多了一倍，我们却能够在车上仔细品味网红街的美，嗯我就是在吐槽这个出租车司机。</p><p>我觉得青岛啤酒博物馆建设和运营得非常好。它分成了 A&#x2F;B 馆，A 馆是不收费的，视角宏大地讲述了青岛啤酒的历史和成就，B 馆里则细致地介绍了啤酒的酿造工艺，赠饮啤酒原浆，出售文创纪念品，甚至还展示了青岛啤酒的生产车间。中途和终途酒馆都可以领取啤酒，对于喜欢喝啤酒的人来说这里是个不错的去处。</p><img src="/2021/05/05/JourneyToTsingTao-1/produce.jpg" class="" title="忘了叫什么的设备"><img src="/2021/05/05/JourneyToTsingTao-1/beer.jpg" class="" title="满墙的啤酒"><img src="/2021/05/05/JourneyToTsingTao-1/cheer.jpg" class="" title="为我们的友谊干杯"><h2 id="晚餐"><a href="#晚餐" class="headerlink" title="晚餐"></a>晚餐</h2><p>从啤酒博物馆出来我们就到了台东步行街，这里整条街都是海鲜大排档。我们几个人在“晚饭吃什么”这个问题上出现了分歧，有人想回去吃，有人想就近吃，有人想在回去路上边走边看，一度有些不愉快。这时也有店家从路对面走过来招徕，拉踩其他家店，看到这个状况我们都不想在这边吃任何一家店了。</p><p>回去路上看到一家店叫做“沂水人家”，大众点评上查了一下发现评价还不错，我们就选定了这家店。不过，不知道是不小心还是有意为之，他家菜单里写的烤多宝鱼是 78 元&#x2F;只，但是我们点了一只之后店家跟我们说是 78 元&#x2F;斤，虽然味道还可以，但是感觉上还是比较奇怪的。除此之外，我们还点了酱猪蹄、清炒茼蒿、辣炒蛤蜊和椒盐皮皮虾，味道都还不错。尤其是椒盐皮皮虾，椒盐永远的神！火候控制得很好，香酥的、椒盐味的壳变得很有风味的同时，虾肉保持了鲜嫩的状态。在这顿饭里皮皮虾毫无疑问是 MVP。</p><img src="/2021/05/05/JourneyToTsingTao-1/fish.jpg" class="" title="烤多宝鱼"><img src="/2021/05/05/JourneyToTsingTao-1/pipixia.jpg" class="" title="椒盐皮皮虾!"><h1 id="崂山、天主教堂、五四广场和海"><a href="#崂山、天主教堂、五四广场和海" class="headerlink" title="崂山、天主教堂、五四广场和海"></a>崂山、天主教堂、五四广场和海</h1><p>我发现开始写之后就变得很啰嗦，总是想把看到的听到的都写下来，记录一天的行程就花了很长的时间。索性拆成两篇来写吧！</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 旅游 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESLint 入门</title>
      <link href="/2021/03/28/EslintTaste/"/>
      <url>/2021/03/28/EslintTaste/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近一两年写前端项目时一直都有接触 ESLint，很多文档和博客也一直都推荐使用开发者 ESLint，但是一直以来都没有好好地学习过它。最近因为使用 Nuxt 开发时 ESLint 缓存出问题导致浪费了半个小时，我越发觉得有必要深入地了解一下这个前端开发中最常使用的代码风格规范工具了。（不得不说，Nuxt 这个框架真的有点难用。）</p><h1 id="ESLint-的用途和初衷"><a href="#ESLint-的用途和初衷" class="headerlink" title="ESLint 的用途和初衷"></a>ESLint 的用途和初衷</h1><p>ESLint 是在 ECMAScript&#x2F;JavaScript 代码中识别和报告模式匹配的工具，它的目标是保证代码的一致性和避免错误。维基百科上这样解释的：lint, or a linter, is a static code analysis tool used to flag programming errors, bugs, stylistic errors, and suspicious constructs. 就是说 ESLint 是写 javascript 时用来分析静态代码是否存在语法错误、代码风格错误和可疑结构的工具。</p><span id="more"></span><h1 id="ESLint-的配置文件"><a href="#ESLint-的配置文件" class="headerlink" title="ESLint 的配置文件"></a>ESLint 的配置文件</h1><h2 id="配置文件基础"><a href="#配置文件基础" class="headerlink" title="配置文件基础"></a>配置文件基础</h2><p>配置文件可以使用 .js, .yaml&#x2F;.yml, .json 格式的文件和 package.json 中的 <code>eslintConfig</code> 属性来定义。读取的优先级如下：</p><ol><li>.eslintrc.js</li><li>.eslintrc.cjs</li><li>.eslintrc.yaml</li><li>.eslintrc.yml</li><li>.eslintrc.json</li><li>package.json</li></ol><p><strong>注：eslint 只会读取优先级最高的一个配置文件。</strong></p><h2 id="最重要的-rules"><a href="#最重要的-rules" class="headerlink" title="最重要的 rules"></a>最重要的 rules</h2><p>ESLint 的配置文件通过配置检查规则来给代码做静态检查，<code>rules</code> 对象中的键值对都代表一个规则，规则的值是一个数组，数组的第一个值是规则的检查力度，从 0 到 2 代表检查的力度越来越严格，0 代表不提示，1 代表给出 warning，2 代表给出 error。也可以直接用力度单词表示，如”off”, “warning” 和 “error”。数组第二个及以后的值表示的是传给该规则的参数。</p><p>下面给的配置文件片段规定在项目中 1. 如果使用了分号则报错；2. 引号只能用双引号，使用了单引号就会报错。</p><figure class="highlight javascript"><figcaption><span>.eslintrc.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="attr">semi</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;always&#x27;</span>],</span><br><span class="line">    <span class="attr">quotes</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;double&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="共享规则库"><a href="#共享规则库" class="headerlink" title="共享规则库"></a>共享规则库</h2><p>另外，ESLint 还可以使用其他共享规则进行扩展。在配置文件中使用 <code>extends</code> 即可，如下面的一行配置项表示引入了 eslint 官方推荐的规则。（官方非常推荐使用这个规则库）</p><figure class="highlight javascript"><figcaption><span>.eslintrc.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">extends</span>: <span class="string">&#x27;eslint:recommended&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然有 recommended 就有 all, 但官方不推荐在生产环境下使用 all 这个共享库，因为其中的核心规则会随着版本的变化而改变，会导致预料之外的情况。</p><p>引入第三方规则库会有三种效果：1. 打开相应的规则；2. 改变检查力度但是不修改其它选项；3. 直接覆盖原本的规则。</p><h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>eslint 的插件其实就是一个 npm 包，可以给 eslint 提供包括但不限于加入新规则和导出共享规则的功能。如下面的配置文件就引入了 react 的 eslint 插件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&#x27;react&#x27;</span>],</span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&#x27;eslint:recommended&#x27;</span>, <span class="string">&#x27;plugin:react/recommended&#x27;</span>],</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;react/no-set-state&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Glob-模式匹配"><a href="#Glob-模式匹配" class="headerlink" title="Glob 模式匹配"></a>Glob 模式匹配</h2><p>eslint 运行后会默认在指定的目录下对<strong>所有的 .js 文件</strong>进行扫描，如果在配置文件中使用了 overrides 参数，则可以对需要进行检测的文件进行指定。如下面的配置文件则指定扫描 <code>bin/*.js</code> 和 <code>lib/*.js</code> 并排除了所有的测试文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="attr">quotes</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;double&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">overrides</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">files</span>: [<span class="string">&#x27;bin/*.js&#x27;</span>, <span class="string">&#x27;lib/*.js&#x27;</span>],</span><br><span class="line">      <span class="attr">excludedFiles</span>: <span class="string">&#x27;*.test.js&#x27;</span>,</span><br><span class="line">      <span class="attr">rules</span>: &#123;</span><br><span class="line">        <span class="attr">quotes</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;single&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用配置注释"><a href="#使用配置注释" class="headerlink" title="使用配置注释"></a>使用配置注释</h2><p>在文件的开头使用 <code>eslint</code> 开头的注释语句可以控制 eslint 对该文件的检测行为。在配置文件中如果配置了 <code>noInlineConfig</code> 属性为 true 的话，就不能使用文件内注释的方式进行配置了。下面摘抄几个配置注释的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1. 整个文件不检查 ===， 使用分号会报错&#x27;</span>)</span><br><span class="line"><span class="comment">/* eslint eqeqeq: &quot;off&quot;, semi: [&quot;error&quot;, &quot;always&quot;] */</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2. 在 -- 之后给出一些说明&#x27;</span>)</span><br><span class="line"><span class="comment">/* eslint eqeqeq: &quot;off&quot;, curly: &quot;error&quot; -- Here&#x27;s a description about why this configuration is necessary. */</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3. 在此文件中直接禁用/启用 eslint&#x27;</span>)</span><br><span class="line"><span class="comment">/* eslint-disable */</span></span><br><span class="line"><span class="comment">/* eslint-enable */</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4. 整个文件中禁用某些规则&#x27;</span>)</span><br><span class="line"><span class="comment">/* eslint-disable no-alert, no-console */</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;5. 下一行禁用某项规则&#x27;</span>)</span><br><span class="line"><span class="comment">// eslint-disable-next-line</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;6. 这一行禁用规则&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// eslint-disable-line</span></span><br></pre></td></tr></table></figure><h2 id="常用配置项"><a href="#常用配置项" class="headerlink" title="常用配置项"></a>常用配置项</h2><p>摘自另外一篇<a href="https://blog.poetries.top/2018/01/27/eslint-config/">博客</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="string">&#x27;no-var&#x27;</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">  <span class="comment">// 要求或禁止 var 声明中的初始化</span></span><br><span class="line">  <span class="string">&#x27;init-declarations&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="comment">// 强制使用单引号</span></span><br><span class="line">  <span class="attr">quotes</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;single&#x27;</span>],</span><br><span class="line">  <span class="comment">// 要求或禁止使用分号而不是 ASI</span></span><br><span class="line">  <span class="attr">semi</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;never&#x27;</span>],</span><br><span class="line">  <span class="comment">// 禁止不必要的分号</span></span><br><span class="line">  <span class="string">&#x27;no-extra-semi&#x27;</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">  <span class="comment">// 强制使用一致的换行风格</span></span><br><span class="line">  <span class="string">&#x27;linebreak-style&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;unix&#x27;</span>],</span><br><span class="line">  <span class="comment">// 空格2个</span></span><br><span class="line">  <span class="attr">indent</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="number">2</span>, &#123; <span class="title class_">SwitchCase</span>: <span class="number">1</span> &#125;],</span><br><span class="line">  <span class="comment">// 指定数组的元素之间要以空格隔开(,后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格</span></span><br><span class="line">  <span class="string">&#x27;array-bracket-spacing&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;never&#x27;</span>],</span><br><span class="line">  <span class="comment">// 在块级作用域外访问块内定义的变量是否报错提示</span></span><br><span class="line">  <span class="string">&#x27;block-scoped-var&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="comment">// if while function 后面的&#123;必须与if在同一行，java风格。</span></span><br><span class="line">  <span class="string">&#x27;brace-style&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;1tbs&#x27;</span>, &#123; <span class="attr">allowSingleLine</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">  <span class="comment">// 双峰驼命名格式</span></span><br><span class="line">  <span class="attr">camelcase</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="comment">// 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号，</span></span><br><span class="line">  <span class="string">&#x27;comma-dangle&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;never&#x27;</span>],</span><br><span class="line">  <span class="comment">// 控制逗号前后的空格</span></span><br><span class="line">  <span class="string">&#x27;comma-spacing&#x27;</span>: [<span class="number">2</span>, &#123; <span class="attr">before</span>: <span class="literal">false</span>, <span class="attr">after</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">  <span class="comment">// 控制逗号在行尾出现还是在行首出现</span></span><br><span class="line">  <span class="string">&#x27;comma-style&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;last&#x27;</span>],</span><br><span class="line">  <span class="comment">// 圈复杂度</span></span><br><span class="line">  <span class="attr">complexity</span>: [<span class="number">2</span>, <span class="number">9</span>],</span><br><span class="line">  <span class="comment">// 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always</span></span><br><span class="line">  <span class="string">&#x27;computed-property-spacing&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;never&#x27;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h1><p>使用 eslint 的同名命令行工具可以对代码进行分析并将分析报告输出，其主要的使用方式是 <code>eslint [options] [file|dir|glob]*</code>，即最终的分析对象可以是文件、目录和 glob。可以通过选项对工具的行为进行自定义，下面总结一些比较重要的命令行工具选项。</p><ul><li><code>--ext</code>: 指定检测的文件拓展名，eslint 将在给定目录中对指定类型的文件进行扫描检测。如果不给出该选项，默认是 <code>*.js</code>；</li><li><code>--fix</code>: 修复检测出来的问题，但是有时候给了这个选项也修复不了相应的问题，这时候就得手动修改相应位置的代码了；</li><li><code>--fix-dry-run</code>: 修改检测出来的问题但是不进行保存；</li><li><code>--cache</code>: 传递该参数运行命令行工具的话会将检测结果进行缓存，下一次再执行缓存模式时将只针对<strong>有变化的文件</strong>进行扫描；</li><li><code>--init</code>: 初始化 eslint 的配置文件，传入这个参数会进入 eslint 的配置向导，从而生成符合用户期望的配置文件。配置向导如下所示：</li></ul><img src="/2021/03/28/EslintTaste/eslint-wizard.png" class="" title="eslint配置向导">]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ECMAScript </tag>
            
            <tag> Lint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从 Vue 到 React —— 第一印象</title>
      <link href="/2021/03/27/Vue2React-1/"/>
      <url>/2021/03/27/Vue2React-1/</url>
      
        <content type="html"><![CDATA[<h1 id="学习-React-的初衷"><a href="#学习-React-的初衷" class="headerlink" title="学习 React 的初衷"></a>学习 React 的初衷</h1><p>之前说过想要学习 React，秉持着边学边记录的想法，我随即开启了这篇帖子。</p><h2 id="从-Vue-说起"><a href="#从-Vue-说起" class="headerlink" title="从 Vue 说起"></a>从 Vue 说起</h2><p>我是一个 Vue 的忠实粉丝，虽然没有全部读过 Vue 的源码，但是对它的基本实现原理和大体的使用方法还是比较熟悉的。我自己思考过，我觉得我喜欢 Vue 大概率是因为我最早接触的前端开发框架就是 Vue。记得是 2018 年参加一项 SRT 的时候，为了开发一款简单的后台管理系统，我开始学习 javascript 以及 Vue。</p><p>当时我还是第一次接触脚本语言，对没错，我接触 javascript 比接触 python 更早一些。熟悉了 C&#x2F;C++ 的继承机制之后，突然要接受 javascript 的原型链继承一时间有点缓不过来。但是后来还是被磨平了棱角，被迫接受了原型这一设计。为了开发 Web 应用通过一位学长的介绍接触到了 Vue 这个框架。我直接惊为天人，还能这样写？因为根据我更早之前的一些浅显的印象，Web 开发是分别要编写 HTML，javascript 和 CSS 三种文件的。现在用 Vue 一个文件就可以生成一个完好的页面，着实非常酷炫。也是在 Vue 这里，我了解到了组件、生命周期、全局状态管理、前端路由等等一些重要的概念，所以先入为主地对 Vue 有强烈好感也正常吧。</p><span id="more"></span><img src="/2021/03/27/Vue2React-1/prototypes.jpg" class="" title="javascript 中的原型"><p>Vue 的好处就不说了，这里主要想说以下我遇到的问题：</p><ol><li>在写 Nuxt 项目写到功能比较重的组件时，一个组件 Vue 文件代码可能会到 800 ~ 900 行，写完 template 后滑滚轮滑到 script 部分找到 methods 里对应的地方写函数，如果模板部分出问题了还得滑回去。文件行数一旦长了，这个上下滑动找代码块的过程真的有点难受，一旦思考过程中出现一小段的空挡，那么就有可能导致思绪完全断掉。</li><li>另外，Vue 的代码复用方案我觉得不是特别好：模板方面的<strong>槽</strong>和脚本方面的<strong>混入</strong>这两个我觉得不是特别优雅，尤其是混入。混入的文件一旦多了可能会造成组件难以维护的问题，例如不知道模板中使用的某个属性到底是 mixin 中来的还是从 data 或者 props 中来的，如果出现覆盖那么覆盖规则、覆盖后的值又是什么。</li><li>插件支持我觉得也没有做得特别好，虽然 Vetur 已经做到相当好了，但有一些情况仍旧是解决不了的，比如上面说的 mixin，其中的属性或者方法就没有办法在调用的页面当中提供补全提醒。</li><li>最后，因为总是遇到一些不可名状的 Bug，我打算以后项目的开发要用 typescript，但是 Vue 对 typescript 的支持不是特别好（听说 Vue 3.x 版本有所改善，但是看了一下 Vue3 的文档觉得 composition API 和 React 实在是太像了，不是特别感冒），所以有些打退堂鼓。</li></ol><p>总的来说，Vue 的问题不是特别大，我也没有在做很大型很复杂的项目，上面说的小瑕疵不是本质问题（有问题应该也是我自己能力还没到位）。但是总让我觉得有可以更好的地方。</p><h2 id="React-哪里吸引我"><a href="#React-哪里吸引我" class="headerlink" title="React 哪里吸引我"></a>React 哪里吸引我</h2><p>React 是 Facebook 推出的<strong>用于构建用户界面的 Javascript 库</strong>，应该是目前最热门的“前端框架”，加上引号是因为我觉得它其实不算是一个框架，只是一个“库”，扩展了 js&#x2F;ts 的语法特性，使它们可以更方便地写 Web 应用。</p><p>它很火，看着也很酷，更原汁原味，更轻量化，更自由，有更多的可能性，这应该就是我想了解它的原因吧。</p><h1 id="对-React-的第一印象"><a href="#对-React-的第一印象" class="headerlink" title="对 React 的第一印象"></a>对 React 的第一印象</h1><p>读了一下官方的入门教程，React 给我印象最深的有下面几个方面：</p><ol><li>完全使用 js&#x2F;ts 编写，没有增加新的文件类型，在 vscode 中编码体验良好（jsx&#x2F;tsx 不太算新类型吧）；</li><li>state 与普通属性区别开来，如果需要更新需要显式的调用 setState 方法，虽然牺牲了一定的灵活性，但是也一定程度上促进了数据的安全访问；同时，这样近于“严苛”的 state 更改方法会鼓励开发者将组件拆分成更小的部分；</li><li>提供函数组件和类组件两种写法，函数组件的写法可以省很多空间；</li><li>React Hooks 看起来像是 Vue Composition API 的原型，函数组件用起来会比较“优雅”；</li><li>JSX 渲染函数的写法可以将实现某功能项的代码尽可能的收缩到同一个空间区域，拥有更好的空间“局部性”，免于在 template 和 script 之间来回切换打断思路的困扰；</li><li>阿里的 <a href="https://ant.design/index-cn">Ant Design</a> 为 React 前端开发提供了一个很好的组件库和设计规范，不得不说，阿里对优化用户体验真的有很深入的研究。</li></ol><h1 id="之后探索的方向"><a href="#之后探索的方向" class="headerlink" title="之后探索的方向"></a>之后探索的方向</h1><p>但是其实前端框架归根结底做的事情都是一样的，是让开发者能够较为轻松地开发出易于测试、易于维护、方便拓展、体验良好的跨平台的 Web 应用。不管是之前写 Vue 代码还是之后要写的 React 的代码，都是为了这样一个同样的目的。然而如果仅仅光想着实现功能而不去思考更多，很容易陷入为写代码而写代码的陷阱当中。</p><p>因为我在实验室课题组里负责了几个项目，几乎每个项目都是不超过3人的小团队。如果开发周期稍微变长一些，项目的功能就会变得异常复杂，而作为开发者，在测试的时候很容易就会局限在正常（或者说正确的）业务逻辑当中，不会发现一些匪夷所思的问题。（感觉真的很难让一个要写正确逻辑业务代码的开发者去做一些极不符合预期的事情。）测试很重要。只要不是自己小打小闹的学习性质地写着玩儿，测试就是极其重要的。测试保障的是软件的质量，在任何有甲方的项目当中，没有进行详尽测试都是不负责的。在写后端代码的时候，测试起来比较容易，因为提供的 API 是可预期的，传入什么样的参数，返回什么样的响应，都是清清楚楚的。至少对于开发者自己来说，后端代码都是白盒，将单元测试覆盖率提高就可以显著地提高代码的可靠程度。那么前端测试呢？</p><p>前端测试中主要有单元测试、<a href="https://zhuanlan.zhihu.com/p/100555246">组件测试</a>和<a href="https://www.jianshu.com/p/bbf4686c2cb6">端到端测试</a>。单元测试其实并不区分写的是前端还是后端的代码，都是追求更高的代码覆盖率。而组件测试和端到端测试可能对于前端应用来说更重要吧，因为前端应用给用户操作的组合是无限的，用户可以选择以任何路径，触发页面任何元素可能的动作，想要详尽地测试属实比较困难，但是组件测试和端到端测试应该都是比较成熟的测试方案，能够在一定程度上提高应用的可靠程度。</p><p>之后除了继续接触 React 之外，我还会去了解一些组件测试和端到端测试的最佳实践，扩充一下自己的前端知识储备。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> React </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序框架：WePY、uni-app 和 Taro</title>
      <link href="/2021/03/14/MiniprogramFrameworks/"/>
      <url>/2021/03/14/MiniprogramFrameworks/</url>
      
        <content type="html"><![CDATA[<p>在<a href="/2021/01/21/WechatMiniprogram/">上一篇博客《聊聊微信小程序及其框架》</a>里面立了个调研微信小程序开发框架的 flag ，这篇博客就来填这个坑——我迫不及待地想要掌握一个能够“舒适编写”小程序代码的框架。</p><p>我之前提到我最想先要了解的是 WePY 和 uni-app 这两个小程序框架，WePY 是微信官方出品的小程序框架，uni-app 是使用 Vue 开发小程序的最火的小程序框架，但是这两个框架都让我特别失望。</p><span id="more"></span><h1 id="令人失望的-WePY-和-uni-app"><a href="#令人失望的-WePY-和-uni-app" class="headerlink" title="令人失望的 WePY 和 uni-app"></a>令人失望的 WePY 和 uni-app</h1><h2 id="WePY"><a href="#WePY" class="headerlink" title="WePY"></a>WePY</h2><p>其实最期待的应该是微信的亲儿子 WePY 吧，毕竟是官方出品，质量应该会有所保障，但是看了文档并自己安装运行之后发现还是不对胃口。原因主要有以下几个方面：</p><ol><li>语法以 Vue 为基础但是又在 Vue 的基础上进行了一点魔改，让人产生一定程度的混乱。如果要使用类 Vue 的语法来写小程序，为什么不直接用 Vue 来写呢？</li><li>插件支持不到位，例如 vscode 中的插件 <code>Wepy</code> 就是完全用 <code>Vetur</code> 魔改出来的，在 .wpy 文件中的提示和各项支持并不到位，会提示有各种 warning 和 error；</li><li>使用 <code>@wepy/cli</code> 工具创建标准模板项目之后发现并不能正常编译。</li></ol><p>第一印象很重要，如果这个框架第一时间没有让我感觉到便利，甚至是让我觉得很麻烦，那我是绝对不会再继续在继续研究它的。到这里，WePY 的尝试就结束了。</p><h2 id="uni-app"><a href="#uni-app" class="headerlink" title="uni-app"></a>uni-app</h2><p>uni-app 是由 DCloud 开发的一个小程序框架，致力于让开发者用 Vue 写一套代码编译到 10 个平台都能运行。虽然一开始对于这种为系统引入过多复杂性的框架有些抵触，但是最简单的 WePY 凉了，所以也愿意相信 uni-app 说的:</p><blockquote><p>即使不跨端，uni-app 也是更好的小程序开发框架、更好的 App 跨平台框架、更方便的 H5 开发框架。不管领导安排什么样的项目，你都可以快速交付，不需要转换开发思维、不需要更改开发习惯。</p></blockquote><p>知乎上也有相关的帖子，说 uni-app 比较香，写起来很省心。抱着尝试的心态看了一下 uni-app 的官方文档、用 vue-cli 安装了 DCloud 官方的项目模板尝试编译运行、下载了 HBuilderX 尝试编译运行。运行是能运行，但是效果马马虎虎，体验有点糟糕，印象大打折扣。主要的问题有以下几点：</p><ol><li>官网文档有些混乱，非常非常非常着重的说明如何进行跨端的适配、条件编译有何注意事项等等，对于只想简单在单一平台编译运行小程序的开发者来说不够简洁；</li><li>命令行工具的表现和 HBuilderX 的不一致，大部分情况下命令行下都编译运行不了，或者是当我想引入一些如 Vant 的组件库的时候小程序就编译错误；</li><li>上一条提到的部分问题如果使用 DCloud 的官方 IDE HBuilderX 的话就可以用“导入插件”的方式解决一部分。但是体验非常非常差，简直就是道德绑架——要编译就要用我的 HBuilderX。什么？你没安装啊，那打扰了；</li><li>尝试使用官方推出的插件将使用原生微信小程序语法编写的代码转换成 vue 风格的 uni-app 代码，但是转换出来之后一团糟，根本没办法运行。</li></ol><p>uni-app 最大的问题在于它太复杂、太希望构建自己的生态、太希望牢牢抓住开发者了。复杂的东西往往都很脆弱，经不起折腾，稍微碰一下就错误百出。它几乎是强制开发者使用他们的 HBuilderX 来进行小程序开发，这一点我无法接受，你不让我自由选择开发工具，我就可以不用你。但是这些问题也情有可原，毕竟它是 DCloud 的主要业务之一，需要给公司带来一定比例的收益。</p><h1 id="Taro-宇宙最强的泰罗奥特曼"><a href="#Taro-宇宙最强的泰罗奥特曼" class="headerlink" title="Taro 宇宙最强的泰罗奥特曼"></a>Taro 宇宙最强的泰罗奥特曼</h1><h2 id="Taro-文档阅读"><a href="#Taro-文档阅读" class="headerlink" title="Taro 文档阅读"></a>Taro 文档阅读</h2><p>我一直觉得很多开发者都非常可爱，从起名上就可见一斑，比如 Taro 这个小程序跨端框架、分布式应用程序协调服务 ZooKeeper 和分布式系统基础框架 Hadoop 等。Taro 是京东的凹凸实验室推出的小程序跨端框架，和 uni-app 一样支持写一套代码编译到不同的地方。目前已经进入了 3.x 阶段，除了可以用 React&#x2F;Nerv 进行开发，还支持了 Vue&#x2F;Vue3。我马上看了看 Taro 的官方文档，比 uni-app 好太多了：快速开始、基础教程、进阶指南、迁移指南层层递进；官方组件库和 API 列表罗列清楚，对它们在 React 和 Vue 中的使用方法说明得很清楚；还提供了专门的“教程”模块，对于刚上手的开发者十分友好；更重要的是，它提供了一套原生的 UI 组件库 taro-ui ，甚至还照顾了 Vue 的版本推出了 taro-ui-vue。依靠这些了解，我就觉得以后就是它了，要是再有新的小程序项目，我应该会首选使用 Taro 进行开发。</p><h2 id="尝试初始项目"><a href="#尝试初始项目" class="headerlink" title="尝试初始项目"></a>尝试初始项目</h2><p>于是，我赶紧创建了 <code>taro-taste</code> 文件夹。</p><p>本来打算随便写一个 demo 小程序，又不想再单独写一套后端代码（再简单也懒得弄了），就用之前申请的一个小程序用来作为云开发的基础。用 taro 自带的 cli 工具初始化了一个微信小程序的云开发模板。用微信开发者工具打开之后，一切表现都很正常，没有什么复杂的事情，没有类似 uni-app 一样的满屏 error，云函数也能够正常调用。但是用 Vue 开发小程序有一些其他的点是需要重新适应的，例如：</p><ol><li>template 部分的基础元素只能用 view 而不能用 div；</li><li>事件名称或许不一样，如点击事件需要用 tap 而不用 click 等；</li><li>安装 taro 官方的 package 最好改用淘宝的源或者直接使用 cnpm ，不然就会出现安装失败的问题。</li></ol><p>不过整体而言已经很满意了，对 Vue 的支持也比较全面，之后应该会真正用它来进行开发吧。</p><h2 id="不如了解一下新东西"><a href="#不如了解一下新东西" class="headerlink" title="不如了解一下新东西"></a>不如了解一下新东西</h2><p>但是有一点比较奇怪的是，在 Vue 项目模板的首页文件中，根节点 view 元素有个 <code>className=&quot;index&quot;</code> 的属性，这是 React 类名的写法。想到 Taro 在 3.x 版本以前只支持 React&#x2F;Nerv 的情况，出现 className 这个属性应该是 3.x 版本目前还没有把对 Vue 的支持做得很完善吧。</p><p>恰好我最近在做其他项目开发的时候感觉 Vue 在<strong>代码复用、数据更新和访问方面的一些体验不是特别友好，而且组件文件规模很难控制（这应该是我的编码水平问题…）</strong>，不如去学习尝试一下 React 吧。听说 Hooks 配合函数组件用起来很舒服，而且 React 完全是在写 javascript&#x2F;typescript，开发起来应该会比一个文件里写 template&#x2F;script&#x2F;style 来回切会容易把控一点吧。</p><p>当然，它们归根到底只是开发框架而已，前端项目开发万变不离其宗，但是了解一个很酷的新东西本身就可以给我很大的动力，对吧？</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊微信小程序及其框架</title>
      <link href="/2021/01/21/WechatMiniprogram/"/>
      <url>/2021/01/21/WechatMiniprogram/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么是微信小程序"><a href="#为什么是微信小程序" class="headerlink" title="为什么是微信小程序"></a>为什么是微信小程序</h1><p>微信很早就有一套专用的<code>JS-SDK</code>在微信客户端上面使用，其开放了录音、二维码、地图、支付等几十个 API，能够支持微信服务号的运转，当时大部分支付、扫码等功能的对接方都是这样的服务号。但是在 2016 年 1 月 11 日微信之父张小龙表示服务号还不够优秀，微信正在研究一个新的服务形态，起名叫做“微信小程序”。在 2017 年 1 月 9 日，第一批微信小程序低调上线，而选择这一天也是为了向 iPhone 1 代的发布致敬。</p><img src="/2021/01/21/WechatMiniprogram/iPhoneRelease.jpg" class="" title="向 iPhone 致敬"><span id="more"></span><p>很快，微信小程序依靠微信的庞大用户量迅速的占领了市场，其他各个大厂见势相继效仿，但是从目前来看它们都很难和微信小程序再抗衡了——不管是用户数量还是开发者数量。这倒也不太奇怪，这种行业往往都是快鱼吃慢鱼不是大鱼吃小鱼，emmm…不过背靠腾讯的微信也不能说是小鱼吧。</p><img src="/2021/01/21/WechatMiniprogram/otherMiniprograms.jpg" class="" title="各厂小程序出现的时间轴"><h1 id="为什么要写微信小程序"><a href="#为什么要写微信小程序" class="headerlink" title="为什么要写微信小程序"></a>为什么要写微信小程序</h1><p>首先想说的是，微信小程序的生态是比较混乱的，开发起来有一点难受，有不少情绪比较激动的开发者直接说微信小程序就是“s**t”，我也能够理解其中的一大部分感情。</p><p>我从大二参加微信举办的第一届大学生微信小程序大赛到现在已经有 3 年了，这期间虽然不是一直在开发小程序，但是每年都会或多或少因为课程或者是项目的原因接触小程序开发，所以对微信小程序还是有一定的了解的。</p><p>小程序<strong>非常</strong>不好写。我觉得有以下几个方面的原因:</p><img src="/2021/01/21/WechatMiniprogram/structure.jpg" class="" title="微信小程序的基本架构"><ol><li>一个页面(Page)拆成四个文件这样分散的组织形式让我觉得有点难受，有的人可能会说这是关注点分离，但是我觉得 Vue 在单文件内拆成多个部分的形式可能更好一点，<a href="https://cn.vuejs.org/v2/guide/single-file-components.html">一个重要的事情值得注意，关注点分离不等于文件类型分离</a>。而且你说一个叫做<code>page</code>的页面，它下面的四个文件名是叫<code>page.wxml</code>好还是叫<code>index.html</code>好呢？</li><li>微信开发者工具非常不好用，首先它很占内存，内存小的机器上运行微信开发者工具一段时间后会出现奇奇怪怪的问题，因为遇到的次数有点多也没有特别记得，在这里也说不出来了。</li><li>因为在微信的生态里面，处处都要依照微信的规矩来进行开发或者运维（这倒也没办法），用某某接口需要是某某类目的小程序，需要有某某资质的主体等等……申请接口、申请上线等种种流程都十分繁琐。</li><li>官方文档有些混乱，而且最近两三年内没有进行过较大的更新改进。</li></ol><p>但是有的时候又不得不写它，因为它<strong>对用户更加友好</strong>。如果换作是我的话，我也不会为了去餐厅点餐或者是在奶茶店买奶茶专门下载一个 App，为了扫健康码就更不会。微信小程序就是为了替代微信服务号这样的“用完就关”的应用场景的，开发的时候把它当作微信服务号 2.0 来开发就好了，不要提高自己的心理预期以为自己是在开发一款 App。这样想的话，开发起来就会好接受多了。</p><h1 id="小程序框架浅析"><a href="#小程序框架浅析" class="headerlink" title="小程序框架浅析"></a>小程序框架浅析</h1><h2 id="逻辑层和渲染层"><a href="#逻辑层和渲染层" class="headerlink" title="逻辑层和渲染层"></a>逻辑层和渲染层</h2><img src="/2021/01/21/WechatMiniprogram/mpImplementation.jpg" class="" title="微信小程序的系统框架"><p>微信小程序通过微信客户端(Native)这一桥梁向外界服务器发送请求和接受响应、调用手机本地接口(拍照、上传文件等)。小程序分为了渲染层和逻辑层，小程序页面的 WXSS、WXS 和 WXML 运行在渲染层，而 JS 运行在逻辑层。WXS 是专门给小程序推出的一个脚本语言，是 JS 的子集，运行在渲染层执行一些简单的数据处理任务，据官方文档说使用 WXS 在 Android 上没有太多性能提升，但是在 iOS 上用其执行相关任务能加速 2~20 倍。</p><p>微信小程序的渲染层与逻辑层也通过 Native 进行通信，比如渲染层将触发的事件传输到逻辑层，逻辑层将更新的数据传输到渲染层等等。可以看到上面这张图里渲染层分了很多个 Webview，其中每个 Webview 都代表了一个小程序页面。</p><img src="/2021/01/21/WechatMiniprogram/viewLogic.jpg" class="" title="逻辑层与渲染层共同渲染"><p>WXML 文件其实是标识了页面的元素及其相互关系，在微信小程序的编译过程中，WXML 文件会被编译成为 JS 对象用来在渲染层维护一个虚拟的 DOM 树。通过与逻辑层的数据进行组合，形成一个数据和结构都完整的虚拟 DOM 树用以渲染。<strong>每次在逻辑层调用 setData 方法时，逻辑层都会将这个消息传输到渲染层</strong>，渲染层通过对比发来的数据与之前的数据，将有差异的数据应用到 DOM 树上，从而进行更新渲染。</p><p>目前市面上有许多的小程序开发框架，如 Taro、Uni-App、mpvue、WePY 等，有实验显示使用小程序框架进行开发会使得小程序性能提升，其中很大一部分原因就是开发框架会对 setData 的调用进行优化，减少逻辑层和渲染层的实际通讯次数，从而提升性能。</p><p>而采用渲染层和逻辑层的架构主要是为了阻断页面渲染和逻辑处理，从而加强监管、提升性能。</p><h2 id="小程序页面生命周期"><a href="#小程序页面生命周期" class="headerlink" title="小程序页面生命周期"></a>小程序页面生命周期</h2><img src="/2021/01/21/WechatMiniprogram/lifecycle.jpg" class="" title="小程序页面对象生命周期"><p>从微信小程序官方文档上面的生命周期图示(方便起见，我把纵向的长图拆成了左右两个部分)可以看得很清楚，逻辑层与渲染层分别进行初始化。</p><ol><li>逻辑层执行完 onLoad 和 onShow 两个生命周期函数之后，等待渲染层初始化完成的通知；</li><li>逻辑层收到通知之后，将初始数据传输给渲染层，渲染层拿到数据进行首次渲染之后再次通知逻辑层，让其执行 onReady 生命周期函数；</li><li>执行完 onReady 函数之后，小程序就处在 Active 状态了；</li><li>如果小程序在激活状态下被最小化到微信的后台或从后台被唤起，则会调用 onHide 和 onShow，如果在激活状态被关闭，则会调用 onUnload (一般不会用到)。</li></ol><p>小程序从后台被唤起时的启动叫做热启动，第一次打开或者距离上一次打开已经过去了足够长的时间时叫做冷启动。他们进入页面生命周期的位置不同，开发的时候需要格外注意一下。</p><h1 id="我自己的小程序开发方法"><a href="#我自己的小程序开发方法" class="headerlink" title="我自己的小程序开发方法"></a>我自己的小程序开发方法</h1><p>开发微信小程序有许许多多的方式，最原始质朴的方式就是直接使用微信开发者工具进行编码和调试，这是我在大二的时候使用的方法。我已经很久没有用过这种方法了，但是它至今仍然给我很不好的回忆，究其根本主要是因为 IDE 实在是太难用了。</p><p>后来使用 WebStorm 来进行微信小程序编码，但是发现我自己的笔记本电脑(18 年老电脑了)同时带 WebStorm 和微信开发者工具两个“重型” IDE 实在是有点吃不消，遂作罢。</p><p>后来接触到了 gulp 这个前端工程化工具，可以让编码过程更加自由，尤其是能够使用 sass 等 css 预处理器，让我觉得开发起来清爽了很多。目前我是用<code>VS Code</code>进行编码，同时使用了<code>minapp</code>, <code>Live Sass Compiler</code>这两个插件，能够原地使用 sass，也没有增加过多的复杂性，很符合我自己的“编码哲学”hhhh。</p><p>我在写代码的时候一直觉得奥卡姆剃刀原理是真理，可以不要的就一定不要。这样的想法使得我在之前的开发中从没有想过用小程序开发框架，“一次编码自动构建多个平台的小程序”，我需要开发的只有“微信小程序”这一个而已，不需要增加那么多的复杂性。</p><p>但是最近越来越受不了小程序复杂的设计了，尤其是写惯了 Vue 再来写小程序，简直就和降智了似的。</p><p>之后我应该会看一些小程序框架的文档，先从 Uni-App 和 WePY 这两个开始吧。Uni-App 是用 Vue 语法开发小程序的框架，支持一键生成多端小程序。而 WePY 则是微信官方推出的小程序开发框架，仅支持微信小程序。这也算是立了 flag 吧。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么我要写博客？</title>
      <link href="/2021/01/16/WhyBlog/"/>
      <url>/2021/01/16/WhyBlog/</url>
      
        <content type="html"><![CDATA[<h1 id="内外因素"><a href="#内外因素" class="headerlink" title="内外因素"></a>内外因素</h1><h2 id="我喜欢记录"><a href="#我喜欢记录" class="headerlink" title="我喜欢记录"></a>我喜欢记录</h2><p>我很喜欢记录，就像首页那句话说的“有着记录的想法，没有记录的时间”一样：我喜欢把生活里有趣的、激发自己思考的事物都记下来，倒不是为了写给谁看或者写给未来的自己看，光是写下来的过程会让我觉得很好，不知道怎么用语言形容的一种“满足感”；但是在学校的时候事情实在是太多了，学习、社工、项目还有各种琐碎的事情让我根本没有时间把所想所见记录下来，所以也就有了这个博客里年更的情况出现了。</p><p>2019 年的 12 月 31 日，我在自己的非主流 QQ 空间发了一篇名为《别了，我的一零年代》的日志，回顾了一下自己的中学和大学本科时期的得与失，2020 年年底实在是太忙了，没能够再写一篇“年终总结”。不过现在想起来也不是很遗憾，因为 2020 年不是很能激起我的记录欲。好！在！已经研一，兵荒马乱的研一上学期也已经度过了，至少未来一年半内不会有太多课程上的压力，这样可以让我有更多连续的时间能够用来记录。这是让我非常开心的，我猜我今后会多写一些东西在博客上吧，应该会。</p><span id="more"></span><h2 id="我应该记录"><a href="#我应该记录" class="headerlink" title="我应该记录"></a>我应该记录</h2><p>“学计算机的人应该有一个博客”是我从大学入学时就有的一个想法，这样朴素的情感大概是在我拜读了阮一峰和廖雪峰等大神博客之后就在心里扎根了的。确实，不管是大一入学、大二做课程大作业、大三在校外实习，通过查询和浏览博客是我解决特定问题的主要方式。所以我觉得自己应该也要成为这样的一个“博主”，虽然没有特别亮眼的技术实力，但是通过写博客督促自己不断的学习也是一件足够酷且有益的事情。</p><p>还有一件事情值得一提，在写<a href="/2020/05/09/HowToUseGithubActions">《Github Actions 的基本使用》</a>时其实我是边学边写，一开始觉得有个地方是 GitHub Actions 的 Bug ，迫于无奈和夜深，发布博客之后就赶紧溜去睡觉了。第二天回看博客的时候一眼就发现了问题所在，这样的特点也从另一方面激励我继续写博客。</p><p>“记录”对我是有好处的。</p><h1 id="近期的一点牢骚"><a href="#近期的一点牢骚" class="headerlink" title="近期的一点牢骚"></a>近期的一点牢骚</h1><p>清华的竞争氛围太强了：每个人都是高中的佼佼者，到了大学有的人依旧游刃有余，有的人就力不从心了，不管排名保持高中的状态还是变好或变坏都是非常正常的事情。找准自己的定位和方向，保持努力就可以了，没有什么比热情更重要。在知乎上经常能看到“清华 XX 系大四了还一事无成怎么办”这样的问题，如果要我回答的话我确实无法组织出一段话来回答这样的问题，在提问者的上下文里我其实也是一事无成的。</p><p>跟人比较确实上头，确实会增加焦虑。可是我不会把自己推到这样的焦虑当中，我不喜欢跟别人比，我只希望自己可以充实和从容，不用妄自菲薄，也不要自以为是。自己只要保持这样的心态和步调就不太在意身边的压力了。</p><h1 id="之后写点什么"><a href="#之后写点什么" class="headerlink" title="之后写点什么"></a>之后写点什么</h1><p>之前有的两个标签是“学习”和“瞎写”，现在觉得“瞎写”有点莫名其妙，之后打算换成“随笔”。有考虑增加一两个标签（例如“游记”和“相册”等），也希望自己能够维持“学习”和其他标签博客的比例。</p><p>最后，希望 2021 年一切都好。</p><p>迟到的新年小作文</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 胡思乱想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当我写H5时，我到底在写什么？</title>
      <link href="/2020/06/07/WhatIsH5/"/>
      <url>/2020/06/07/WhatIsH5/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>“活动宣传写个H5就可以了”，”学生节不如做一个H5小游戏吧，比如之前那种学堂路躲避乌鸦“……在这几年的学习和生活中我听到过很多次H5，也真正看到过、使用过、制作过H5，但是我对H5这一个词的真正定义还是不太了解。它给我的直观印象就是在手机上运行的、包含许多动画甚至音乐的纯前端&#x2F;弱后端页面，最常见于微信群、公众号和朋友圈，或许这也是大多数人对其的印象。对自己接触的东西一点也不了解是不能接受的，所以要简单调查调查。</p><h1 id="H5的由来"><a href="#H5的由来" class="headerlink" title="H5的由来"></a>H5的由来</h1><h2 id="几种定义"><a href="#几种定义" class="headerlink" title="几种定义"></a>几种定义</h2><ul><li>h5是HTML的第5级标题标签；</li><li>H5是<em>在手机上运行的、包含许多动画甚至音乐的纯前端&#x2F;弱后端页面</em>；</li><li>h5是2014年10月由W3C制定的HTML新一代标准，其中包含了新标签、新属性、多媒体和本地存储等特性。</li></ul><span id="more"></span><h2 id="H5为什么火？"><a href="#H5为什么火？" class="headerlink" title="H5为什么火？"></a>H5为什么火？</h2><p>H5是HTML的第5代标准，它不是一个新的应用，不是一个编程语言，甚至不是一个实体(Web应用、微信小程序等)，他就是常规意义上的HTML新版本，和C++17、C++20差不多。HTML等Web应用相关语言和Golang、C++等语言还不一样，它们的标准还需要各大浏览器的运行时支持才算是“真正”拥有了新特性。但是如今大多数用户都能够很方便地通过电脑、手机接触到Web应用，其中不乏动画酷炫、插画精美、音乐好听、让人眼前一亮的应用，开始有人将这样的应用叫做H5，后来逐渐传开再也无法很好地定义了。</p><p>普通用户是不会去了解H5到底是什么的，隔行如隔山，弄明白这个对用户来说作用不大。据我观察，各大H5应用模板网站也不会强调这个H5到底是怎么做的，而是统一作为模板打包卖给用户就行。H5可能是纯前端的，也有可能有弱后端，但是“注重呈现”应该是H5的核心，有“动态海报”内味儿。接下俩的H5统一取第二个定义。</p><h1 id="H5的组成"><a href="#H5的组成" class="headerlink" title="H5的组成"></a>H5的组成</h1><img src="/2020/06/07/WhatIsH5/html5.jpg" class="" title="什么是 H5"><p>H5也是Web应用，那么就离不开HTML、CSS和JavaScript，HTML负责文档结构、CSS负责视觉样式、JS负责业务逻辑，在写H5的时候其实是在写这三种语言。HTML5中的如<code>&lt;canvas&gt;</code>、<code>&lt;audio&gt;</code>、<code>&lt;video&gt;</code>和<code>&lt;svg&gt;</code>等新标签确实为前端的图形渲染提供了良好的载体，但是应用的代码组织与以前差别并不是很大。如今许多浏览器都支持HTML5标准，许多前端程序员也在使用HTML5标准提供的新标签，那么可以说现在只要是写前端都是在写H5。</p><h1 id="SPA-高级H5"><a href="#SPA-高级H5" class="headerlink" title="SPA - 高级H5"></a>SPA - 高级H5</h1><p>单页面应用(Single Page Application)的说法最近几年非常流行，前后端分离的开发风格、Web技术和云计算的发展使得浏览器中运行的Web应用无论是<strong>开发流程</strong>还是<strong>使用体验</strong>上都越来越接近原生应用(Native Application)。许多SPA的功能全体量大，不输给原生应用。HTML5中提供的本地存储(localStorage)特性相信许多开发者都用过，使用它可以构建相当强大的功能。那么把它叫做高级H5也不过分吧？（doge</p><p>另外，如Vuejs、Reactjs等在内的前端开发框架也简化了SPA的开发。</p><p>我以前接触过Vuejs和微信小程序，当时觉得微信小程序是大部分借鉴了Vuejs的精髓。前一阵子又看了看Reactjs的文档，发现微信小程序的架构里也能发现Reactjs的影子……虽然React有facebook官方的支持，但是有一说一它的中文文档是真的不行，过时的文档google出来结果竟然还在前列。相比之下Vue虽然没有大公司支持，但是越来越赢得开发者的青睐，其文档的完善也是一大因素吧。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读: Role-Based Access Control Models, 1996</title>
      <link href="/2020/05/18/ReadRBAC/"/>
      <url>/2020/05/18/ReadRBAC/</url>
      
        <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>论文描述的方法简称 RBAC，基于角色的访问控制，是目前非常主流的访问控制方法。用户（User）、角色（Role）和权限（Permission）是论文中最主要的三个概念。角色和用户组这个概念很像，但是用户组仅仅只是一个用户集合，而角色则联系着用户和权限。说到底都是为了让用户获取权限来执行相应的操作，不管是加入角色还是用户组，都只是一个中间态。</p><p>RBAC0 是基础模型，是任何系统实现 RBAC 的最低要求。RBAC1 和 RBAC2 都包含了 RBAC0，但是分别加入了不同的特性。RBAC1 加入了角色层级特性，即角色 A 可以通过继承角色 B 获取角色 B 拥有的权限。RBAC2 加入了约束特性，控制用户对 RBAC 中不同资源、组件的权限。而 RBAC3 包括了角色层级和约束。示意图如下所示，其中基础模型 RBAC0 是实线部分。</p><span id="more"></span><img src="/2020/05/18/ReadRBAC/fig1.png" class="" title="RBAC 模型族"><p>文章并没有给出模型具体的实现方案，这些模型主要用作产品开发的指导准则或设计原型。</p><h1 id="RBAC-模型族"><a href="#RBAC-模型族" class="headerlink" title="RBAC 模型族"></a>RBAC 模型族</h1><h2 id="RBAC0"><a href="#RBAC0" class="headerlink" title="RBAC0"></a>RBAC0</h2><p>基础模型主要由用户 U，角色 R 和权限 P 三个实体集组成，图表中也表示出了会话 S。用户代表使用系统的每一个“人”；角色代表负责一系列职责的人群，用职业或者岗位来理解；会话是将从用户到多个角色的映射。权限需要详细说明。</p><p>权限是访问一个或多个数据对象或其他资源的许可证，权限通常是正向的，即拥有权限后可以访问对应的对象。但是有的模型把权限设计成为负向的，即获得这个权限后将无法访问对象。RBAC 模型中将负向权限建模成为“约束”，后文会提及。权限的含义完全取决于系统的类别和系统的实现细节。操作系统中区分了文件、目录、设备和端口等对象的读、写和执行操作；数据库对关系、元组、属性和视图等对象的查询、更新、删除和插入操作进行了区分。</p><p>图 1 还展示了用户分配 UA 和权限分配 PA 关系，它们都是多对多关系。RBAC 的关键就蕴藏在这两个关系当中。RBAC0 中各组成部分为：</p><ul><li>U, R, P, S，分别代表用户、角色、权限和会话</li><li>PA，权限分配，权限到角色的多对多关系</li><li>UA，用户分配，用户到角色的多对多关系</li><li>_user_， 从一个会话映射到一个用户的函数</li><li>_roles_，从一个会话映射到一个角色集的函数</li></ul><h2 id="RBAC1"><a href="#RBAC1" class="headerlink" title="RBAC1"></a>RBAC1</h2><p>RBAC1 在 0 的基础上加入了角色层级，这个特性在现代组织管理当中显得很自然。层级高的角色继承层级低的角色的权限，如 Team Leader 可以访问所有项目的细节而 Project Programmer 只能访问所属项目。</p><p>从离散数学的角度来说，角色间的层级是偏序关系，即满足了自反性、传递性和反对称性的关系。</p><p>私有权限或私有角色通常用于控制角色继承时的权限作用域，如对进展中的为完成工作访问权限如果从低级角色直接继承到高级角色似乎不是特别合适。如 Team Leader 不应总是收到每一位 Programmer 的 CI Build 失败通知。</p><h2 id="RBAC2"><a href="#RBAC2" class="headerlink" title="RBAC2"></a>RBAC2</h2><p>RBAC2 在 0 的基础上加入了约束特性，这个特性有时被称作 RBAC 的灵魂。<br>约束是是一个强力的机制，可以用来打造更高水准的组织管理架构。下面是文章介绍到的一些常见约束：</p><ul><li>互斥约束，互斥顾名思义就是用户只能获得其中一个角色身份，或者同样的权限只能赋予其中一个角色；</li><li>基数约束，一个角色最多只能拥有一定数量的成员；</li><li>先需角色约束，给用户分配角色 A 之前需要该用户拥有角色 B 的身份；</li><li>角色层级约束，没错就是 RBAC1 中的角色层级，它也可以被看作是一类约束。</li></ul><h2 id="RBAC3"><a href="#RBAC3" class="headerlink" title="RBAC3"></a>RBAC3</h2><p>RBAC3 就是把 1 和 2 组合起来，既有角色层级又有约束条件。</p><h1 id="基于-RBAC-的管理模型"><a href="#基于-RBAC-的管理模型" class="headerlink" title="基于 RBAC 的管理模型"></a>基于 RBAC 的管理模型</h1><p>上面提到 RBAC 模型当中所有组成部分都是由一个安全管理员直接负责，这样的情况只有在极小的系统中才有可能存在。任何稍大一些的系统都有多个安全管理员。由于 RBAC 的主要好处就是实现了权限的管理，那么如何让 RBAC 来管理 RBAC 本身呢？论文提出的管理模型在图 4 中展示，其上半部分就是之前的图 1(b)部分，其下半部分是上半部的镜像，其中包含了管理角色 AR 和管理权限 AP。权限只能授予给角色，管理权限只能授予给管理角色。</p><img src="/2020/05/18/ReadRBAC/fig4.png" class="" title="RBAC 管理模型"><p>RBAC 模型中的管理权限可以视作修改用户分配 UA，权限分配 PA 和用户层级 RH 关系的能力。这样就可以实现用 RBAC 模型管理自己了。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Sandhu R S, Coyne E J, Feinstein H L, et al. Role-based access control models[J]. Computer, 1996, 29(2): 38-47.</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reading </tag>
            
            <tag> AccessControl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github Actions的基本使用</title>
      <link href="/2020/05/09/HowToUseGithubActions/"/>
      <url>/2020/05/09/HowToUseGithubActions/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在毕业设计时捣鼓了一会应用的持续集成(Continuous Integration, CI)和持续部署(~ Deployment, CD)，发现确实可以为自己省下很多力气：</p><ul><li>不用每次把代码通过 scp 或者 sftp 传到服务器上再 build 运行</li><li>也不用在本地交叉编译之后再传到服务器上</li></ul><p>之前在公司实习时所有的分支合并都会涉及到 CI 和 CD，当时为了让代码编译通过费了很多心思。虽然自己push代码的时候比较费劲，但是确确实实可以给应用的部署和可用性提供保障。</p><p>最近在看阮一峰大神的技术博客时偶然看到了<a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">Github Actions的入门基本教程</a>，发现 github 把 CI 脚本商品化、组件化放到 Marketplace 里供用户挑选和使用是一个非常不错的思路，让 github 的开源文化更加吸引人了。<br>我把上面那篇博客看完之后发现其实和 Travis CI 差不多，或者说其实所有的 CI 系统都差不多。抱着接触新事物的热情，我还去看了 github actions 的<a href="https://help.github.com/en/actions">官方文档</a>，下面对我所了解到的一些信息进行一个汇总。</p><span id="more"></span><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><p>Github actions 中有下面几个重要的概念，直接上原文档：</p><ul><li>Workflow</li><li>Jobs</li><li>Steps</li><li>Actions</li><li>Runner</li></ul><p><strong>1. Workflow</strong></p><p>工作流，工作流是由在 git 项目目录中的 .github&#x2F;workflows&#x2F;*.yml 文件定义的自动执行程序，可用于项目的构建、测试、打包、发布和部署。工作流又由一个或多个任务组成。</p><p><strong>2. Jobs</strong></p><p>任务，由一组步骤组成的单位。在工作流文件中可以定义任务如何运行：是并行执行还是顺序执行，以及以什么条件、什么顺序执行。在 Github-hosted 宿主机中，每一个任务都是在一个全新的虚拟环境中运行的。</p><p><strong>3. Steps</strong></p><p>每一个步骤都是一个单独的任务，可以执行 shell 命令或者是执行 action。一个任务里的所有步骤都是在相同的虚拟环境中执行的，使得不同的步骤可以通过文件系统共享信息。</p><p><strong>4. Actions</strong></p><p>翻译成动作有点太难听了，还是就叫 Action 吧。Action 是工作流中最小的可移植构建模块，你可以创建自己的 action，也可以使用社区里的 action，还可以对公开的 action 进行DIY。如果在工作流中使用，必须将 action 包含在步骤当中。</p><p><strong>5. Runner</strong></p><p>我把它叫做宿主机，宿主机分为两种：<strong>Github组装</strong>的和<strong>用户自组装</strong>的，他们存在着一些不同。宿主机等待用户的各种任务，一旦宿主机接受了任务，它会执行任务里的 actions，并把运行进度、日志和结果传给 github，用户可以在 actions 页面中查看这些信息。日志最多保存 30 天。</p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>我的博客用的是 hexo 在 github pages 上构建的，博客所在位置是一个 repo，hexo 源码所在位置又是另一个 repo，我希望可以合并这两个 repo。或者退而求其次，我希望可以一次 commit 实现两个 repo 的 work done。<br>这就要求我：</p><ol><li>在源码 repo 处启用 actions 进行自动构建</li><li>将构建好的 repo 源码推送到 gh-pages repo 当中</li></ol><h2 id="在-Marketplace-中寻觅"><a href="#在-Marketplace-中寻觅" class="headerlink" title="在 Marketplace 中寻觅"></a>在 Marketplace 中寻觅</h2><p>我找了四个公开的社区 action 想进行使用，发现他们存在着各式各样的问题，难怪最多的一个项目也只有 21 个 star。</p><img src="/2020/05/09/HowToUseGithubActions/actions-4.png" class="" title="在插件市场中寻找可用插件"><h2 id="自己写工作流文件"><a href="#自己写工作流文件" class="headerlink" title="自己写工作流文件"></a>自己写工作流文件</h2><figure class="highlight yml"><figcaption><span>deploy.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">macos-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo</span> <span class="string">-g</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo</span> <span class="string">--save</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">hexo</span> <span class="string">g</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span> <span class="string">git</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">&quot;$EMAIL&quot;</span> <span class="string">&amp;&amp;</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">&quot;@NAME&quot;</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">EMAIL:</span> <span class="string">***</span></span><br><span class="line">          <span class="attr">NAME:</span> <span class="string">***</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">bind</span> <span class="string">github</span> <span class="string">remote</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          cd ./public</span></span><br><span class="line"><span class="string">          git init</span></span><br><span class="line"><span class="string">          git remote add origin https://$PERSONAL_TOKEN@github.com/$USERNAME/$USERNAME.github.io.git</span></span><br><span class="line"><span class="string"></span>        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">USERNAME:</span> <span class="string">fool-wang</span></span><br><span class="line">          <span class="attr">PERSONAL_TOKEN:</span> <span class="string">$</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">push</span> <span class="string">public</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          cd ./public</span></span><br><span class="line"><span class="string">          git add .</span></span><br><span class="line"><span class="string">          git commit -m &quot;auto deploy&quot;</span></span><br><span class="line"><span class="string">          git push -f origin master</span></span><br></pre></td></tr></table></figure><p>该工作流每次在我向 master 分支 push 代码时会触发，其中任务只有一个 <code>build</code>，我给他设定的名字也是 <code>Build</code>。<br><code>runs-on</code> 指定宿主机，在这里因为我的电脑是 macos 系统，所以我希望宿主机可以和我的电脑操作系统相同，所以选择了 <code>macos-latest</code>。<br>下面到了最最关键的步骤，一条一条地解释我做了什么（其实我也知道我的 <code>push -f</code> 很不优雅）：</p><ol><li>用了官方的 actions&#x2F;checkout 来获取 repo 文件内容</li><li>用了官方的 actions&#x2F;setup-node 来获取 node.js 运行时环境，其实主要就是需要 npm </li><li>运行 <code>npm install</code> 命令，为项目安装依赖</li><li>运行 <code>npm isntall hexo -g</code> 命令，为虚拟环境全局安装 hexo</li><li>运行 <code>npm install hexo --save</code> 命令，<strong>这一步我非常不解</strong>，但是如果没有这一步之后的步骤会报错</li><li>运行 <code>hexo g</code> 命令，生成 public 静态页面文件</li><li>配置 git 信息，通过环境变量传入我的邮箱地址和姓名信息</li><li>通过我的 personal access token 将博客 repo 绑定到生成的 public 文件夹远端</li><li>将 public 内的文件强制 push 到博客 repo 中，希望实现文件替换，也就是实现了部署过程</li></ol><h2 id="问题，大问题"><a href="#问题，大问题" class="headerlink" title="问题，大问题"></a>问题，大问题</h2><p>我发现宿主机内执行 <code>hexo g</code> 命令生成的文件与在本地电脑上生成的文件不一致，下面放几张图片：</p><img src="/2020/05/09/HowToUseGithubActions/local-g.png" class="" title="本地执行命令的生成的文件"> <p>上图是本地执行命令的生成的文件，下图是宿主机执行命令生成的文件，差别那么大就很离谱。</p><img src="/2020/05/09/HowToUseGithubActions/runner-g.png" class="" title="宿主机执行命令生成的文件"> <p>更离谱的是，博客 repo 上新部署的 <code>index.html</code> 文件内容是空。</p><img src="/2020/05/09/HowToUseGithubActions/generated-index.png" class="" title="更新的index.html文件"><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>Github actions 的基本使用倒是已经掌握了，但是没办法实现博客源码自动构建和自动部署是有点困扰我，其中最神奇的问题就是 <code>hexo g</code> 生成的文件不同。不知道这个是我的打开方式错误，还是 github actions 环境有问题，还是 hexo 有问题。（最后一般都是我有问题）</p><p>Github actions 使用体验不错：</p><ol><li>在私有 repo 中也能够免费使用，真心觉得微软爸爸好</li><li>任务执行流程、日志和结果呈现十分友好</li><li>marketplace 的思路新奇，有许许多多开发者贡献代码，社区活跃度高，今后一定会变得更易用</li><li>构建失败后会有邮件提醒</li></ol><p>之后有时间还会继续深入了解 actions，争取把今天遇到的<a href="#%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A4%A7%E9%97%AE%E9%A2%98">问题</a>给解决掉了。</p><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p><code>hexo g</code> 命令生成的文件与在本地不同是因为…我漏掉了 <code>git clone</code> 模板库的步骤。第二天早上在 <code>hexo g</code> 之前补上了下载模板库的命令之后就正常工作了。<br>熬夜害人熬夜害人。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">GitHub Actions 入门教程</a></li><li><a href="https://help.github.com/en/actions">GitHub Action 官方文档</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CI/CD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暑期的生活啊</title>
      <link href="/2019/07/27/SummerVocation/"/>
      <url>/2019/07/27/SummerVocation/</url>
      
        <content type="html"><![CDATA[<p>已经实习四周了，学院安排的实习期已经只剩下一周，但是直到这两天公司 Buddy 才给我安排了一个比较重要且连续的工作，让我有点左右为难：下周之后我到底还去不去呢？<br>之前四周的工作都是延续暑假前所做，多是一些较零散、不系统的碎活儿，其实这样的安排确实容易让人觉得枯燥无味，缺乏意义和价值。<br>“摸鱼”让我觉得内心有愧，如果要做自己的事情，为什么不回学校呢？</p><p>一周五天上班的日子让我分外珍惜周末的两天，因为周中下班回到宿舍已经快晚上 8 点了。这一晚上一般就会在我是要刷题，还是要看一些资讯，还是看 B 站这样的纠结之中过去，第二天有点后悔，但是回来之后又重复前一天的过程。究其根本，我觉得是因为我暑假想做的事情太多了。</p><blockquote><ol><li>实习</li><li>刷题</li><li>社工</li><li>上线小程序</li><li>写诸如这篇博客的东西</li><li>学习一些奇妙有趣的东西</li><li>blabla<br>（我觉得这个引用框好好看</li></ol></blockquote><p>暑假我也更加清晰地认识了我的本质，我对不了解的事物很难提起兴趣，但是一旦喜欢某件事物之后就会开始不断的去了解去接触，就是这样一个循环。所以，我的生活好小啊。</p><p>看到手机上给自己的警言：“想的多了，做的就少”，这是高中时期自己给自己打气用的，希望自己能够心无旁骛地做自己该做的事情。<br>但是来到大学之后发现，没有明确的事情是那么的该做了，只有想做的事情比较明确，然而想做的事情太多，在纠结之中又会不经意掉入“想太多”的境地。<br>给自己定一个小目标吧，8 月里把心沉下来，否则这个暑假将和去年暑假一样浮躁。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 胡思乱想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对Python,Golang和C++三种语言GC机制的简单调查</title>
      <link href="/2019/06/12/GarbageCollectionSurvey/"/>
      <url>/2019/06/12/GarbageCollectionSurvey/</url>
      
        <content type="html"><![CDATA[<h1 id="调查背景"><a href="#调查背景" class="headerlink" title="调查背景"></a>调查背景</h1><p>在公司一项任务是需要调用Python的SDK爬取相关的数据信息，数据的量在<code>10亿</code>这个量级，故不能够一下子得到结果。<br>这个程序运行十来天的可能性比较大，但是问题来了，程序跑过一阵子（1小时）之后爬取效率明显降低。<br>重启之后效率恢复，这就让人有点不爽了，本来数据量就多，用初速度爬取也需要十来天，这样一减速得爬到什么时候呢？<br>通过使用<code>top</code>工具，观察到爬虫脚本在运行过程中占用的内存从<strong>800MB</strong>上升到了<strong>1.4GB</strong>，速度也随内存占用量的上升而减慢。（图片来自MacOS的top，与程序的运行环境中的top不太一样）</p><img src="/2019/06/12/GarbageCollectionSurvey/top.png" class="" title="使用 top 工具展示内存使用情况"><p>我猜可能是内存泄漏了，各种查资料之后用python的<code>gc</code>和<code>objgraph</code>进行程序内存使用情况分析。<br>虽然针对于爬虫程序的分析无果，但是对GC机制有了一点兴趣，于是稍微了解了一下。</p><p><em>下文的 GC 既指 Garbage Collection， 也指 Garbage Collector。</em></p><p>接触Python一年多，Golang九个月，C++是大一时OOP课上教授的语言。其实都只是了解了皮毛，仅仅停留在“会用”这个层面。</p><span id="more"></span><h1 id="三种语言的GC机制"><a href="#三种语言的GC机制" class="headerlink" title="三种语言的GC机制"></a>三种语言的GC机制</h1><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><strong>1. 引用计数</strong><br>引用计数是一个很简单的实现方式，顾名思义：</p><ul><li>当一个对象被引用时，该对象的引用次数+1；</li><li>当引用这个对象的另一个对象被GC回收时，该对象的引用次数-1；<br>当GC监测到某对象的引用次数为0时则将该对象回收。</li></ul><p>但是这个方案无法解决<a href="https://baike.baidu.com/item/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">循环引用</a>。</p><p><strong>2. 分代回收</strong><br>根据对象的存活周期不同将内存划分为新生代和老年代，存活周期短的为新生代，存活时间长的为老年代。<br>这样就可以根据每块内存的特点采用适当的收集算法。<br>在新生代对象中进行高频回收，在这次回收中没有被清理的对象移动到老年代对象中，老年代对象执行低频回收。</p><hr><p>上面是分代回收的定义，但是python没有简单的把对象分为<strong>新</strong>和<strong>老</strong>两个代际，而是分为了三代。每一代的对象达到了一定的数量（Threshold）之后GC会执行相应代际的对象回收，这个阈值是可以通过<code>gc</code>包进行设置的（<code>gc.set_threshold</code>），我调用<code>gc.get_threshold()</code>得到的结果是<code>(700, 10, 10)</code>。<br>不像引用计数，分代回收是可以进行控制的，甚至是关闭。如果觉得GC太频繁造成了性能瓶颈，那么可以提高阈值，降低GC频率。</p><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><p><strong>1. STW</strong><br>Golang的早期版本被无数人所诟病的问题之一就是它的GC，它用的是<strong>标记清除</strong>方法，也叫<strong>Stop The World(STW)<strong>。<br>该方法从根变量开始迭代，遍历所有被引用的对象，能够访问到的都标记上“被引用”；之后对没有标记过的对象进行清理，即回收不可达的对象。但是每次执行该算法都会让正常执行的</strong>内存负荷型程序</strong>出现明显的卡顿，这也是为什么该方法又被叫做STW的原因。</p><p><strong>2. 三色标记法</strong><br>该方法是对标记清除算法的改进，原理如下：</p><ol><li>起初所有对象都是白色的；</li><li>从根对象出发扫描所有可达对象，标记为灰色，放入待处理队列；</li><li>从队列取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色；</li><li>重复步骤3，直到灰色对象的队列为空。这时仍为白色的对象被当作垃圾回收。</li></ol><p>下面是演示图：</p><img src="/2019/06/12/GarbageCollectionSurvey/three-colors.gif" class="" title="三色标记法"><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><blockquote><p>In early programming languages, developers were responsible for all memory management in their programs. This meant before creating a list or an object, you first needed to allocate the memory for your variable. After you were done with your variable, you then needed to deallocate it to “free” that memory for other users.[2]</p></blockquote><p>C++就是<strong>early programming language</strong>，它较Python和Golang而言更偏底层和接近系统，将内存管理的工作交给程序员来完成。简而言之，就是没有GC（当然后来的C++11、14的新特性在此不提及）我之前写的某程序就因为想要释放整个数组的空间但是只写了<code>delete xxx</code>而不是<code>delete[] xxx</code>，仅释放了数组首位元素的空间，导致了剩余所有元素内存资源的浪费。<br>为了减轻程序员手动管理内存的痛苦，C++11推出的<a href="https://www.zhihu.com/question/20368881">智能指针</a>算是一个宝贝。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://segmentfault.com/a/1190000018161588">GO GC 垃圾回收机制</a></li><li><a href="https://stackify.com/python-garbage-collection/">Python Garbage Collection: What It Is and How It Works</a></li><li><a href="https://www.zhihu.com/question/20368881">如何理解智能指针？ - 知乎</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
